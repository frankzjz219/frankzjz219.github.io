<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/rPi.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/rPi.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/rPi.png">
  <link rel="mask-icon" href="/images/rPi.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"frankzjz219.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Frank&#39;s blogs">
<meta property="og:url" content="https://frankzjz219.github.io/page/2/index.html">
<meta property="og:site_name" content="Frank&#39;s blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FrankZhang">
<meta property="article:tag" content="C, C++, Leetcode, Linux, 嵌入式, Ununtu, 驱动">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://frankzjz219.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Frank's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Frank's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">永远好奇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/frankzjz219" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/04/30/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84Netlink%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/30/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84Netlink%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">使用内核线程的Netlink内核模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-30 21:02:43" itemprop="dateCreated datePublished" datetime="2024-04-30T21:02:43+08:00">2024-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 14:47:31" itemprop="dateModified" datetime="2024-05-01T14:47:31+08:00">2024-05-01</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用内核线程的Linux内核的Netlink服务器"><a href="#使用内核线程的Linux内核的Netlink服务器" class="headerlink" title="使用内核线程的Linux内核的Netlink服务器"></a>使用内核线程的Linux内核的Netlink服务器</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/frankzjz219/kernelNetlinkServer">代码仓库</a></li>
<li><code>./client</code>下是客户目录</li>
<li>根目录下执行<code>make</code>可以编译模块，执行<code>./remake.sh</code>可以一键编译安装</li>
<li>此服务器运行在Ubuntu系统，内核版本为<code>6.5.0-27-generic</code>，基于NETLINK协议</li>
<li>主要实现了基于netlink的通信响应，每次响应的时候都创建一个内核线程（kthread）来执行操作，执行完之后线程自动结束<ul>
<li>在内核中，不需要手动的执行<code>wait</code>或者是<code>join</code>等负责回收工作，内核会自动回收内核线程</li>
<li>可以在需要强行停止的时候执行<code>kthread_stop()</code> 函数。该函数会向内核线程发送一个停止请求,并等待线程完全退出。在内核线程函数中,我们可以使用 <code>kthread_should_stop()</code> 函数来检查是否收到了停止请求, 检测到该函数返回值为真的时候退出内核线程的工作函数。<h2 id="netlink"><a href="#netlink" class="headerlink" title="netlink"></a>netlink</h2></li>
</ul>
</li>
<li>内核创建netlink服务端<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">nl_sk = <span class="built_in">netlink_kernel_create</span>(&amp;init_net, NETLINK_USER, &amp;cfg);</span><br></pre></td></tr></table></figure></li>
<li>上面注意<code>NETLINK_USER</code>协议号必须跟用户态的程序设置的相同，否则无法通信</li>
<li>发送数据使用<code>nlmsg_new</code>, <code>nlmsg_put</code>两个函数构造信息，使用<code>nlmsg_unicast</code>发送数据（不区分多播组）</li>
<li>接收数据使用回调函数实现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建netlink socket</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netlink_kernel_cfg</span> <span class="title">cfg</span> =</span> &#123;</span><br><span class="line">    .input = &lt;call back function&gt;,</span><br><span class="line">&#125;;</span><br><span class="line">nl_sk = <span class="built_in">netlink_kernel_create</span>(&amp;init_net, NETLINK_USER, &amp;cfg);</span><br></pre></td></tr></table></figure></li>
<li>回调函数会自动传入此时接收到的数据，使用内核提供的宏<code>NLMSG_DATA</code>和<code>NLMSG_PAYLOAD</code>等可以提取到信息和长度<h3 id="用户端的相关操作"><a href="#用户端的相关操作" class="headerlink" title="用户端的相关操作"></a>用户端的相关操作</h3></li>
<li>创建sock<code>sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_USER);</code></li>
<li>绑定后可以通信<code>bind(sock_fd, (struct sockaddr*)&amp;src_addr, sizeof(src_addr))</code></li>
<li>发送<code>sendmsg(sock_fd, &amp;msg, 0)</code></li>
<li>接收<code>recvmsg(sock_fd, &amp;msg_recv, 0)</code><h2 id="proc下的文件"><a href="#proc下的文件" class="headerlink" title="/proc下的文件"></a>/proc下的文件</h2></li>
<li>在<code>/proc</code>下创建一个文件用于读取内核模块的信息<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">proc_entry = <span class="built_in">proc_create</span>(<span class="string">&quot;netlink_stats&quot;</span>, <span class="number">0666</span>, <span class="literal">NULL</span>, &amp;proc_file_fops);</span><br></pre></td></tr></table></figure></li>
<li>处理用户的读取操作<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proc文件的读取操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">proc_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *user_buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;Messages received: %d\nTotal bytes: %d\n&quot;</span>, message_count, total_bytes);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">simple_read_from_buffer</span>(user_buf, count, ppos, buffer, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2></li>
<li><code>kthread_run(threadfn, data, namefmt, ...)</code></li>
<li>第一个函数是一个<code>int(*)(void*)</code>的函数，接收一个<code>void*</code>的参数，返回一个返回码</li>
<li>第二个是传入的参数</li>
<li>第三个是名称<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2></li>
<li><img src="/imgs/899d1ad68264dd9dfd56b30e838b5564e165b87d08f957991a2d73790683f724.png" alt="picture 0">  </li>
<li><img src="/imgs/b2f8c24b6d4e4787ec28c1dcf76a3f07a193cccab86307193c17763b79a27500.png" alt="picture 1"> </li>
<li><img src="/imgs/e167e9f8ba08d456270b8ed77aacbd1a7f249178b20f8d54f4b6c06f34e65931.png" alt="picture 2">  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/03/13/%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/13/%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E6%A0%88%E5%8D%8F%E7%A8%8B/" class="post-title-link" itemprop="url">什么是无栈协程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-13 22:43:48 / 修改时间：22:47:59" itemprop="dateCreated datePublished" datetime="2024-03-13T22:43:48+08:00">2024-03-13</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是无栈协程"><a href="#什么是无栈协程" class="headerlink" title="什么是无栈协程"></a>什么是无栈协程</h2><ul>
<li>无栈协程是一种轻量级的协程实现方式，相比有栈协程，它们不拥有独立的调用栈。这种设计让无栈协程更加轻量，因为它们不需要为每个协程分配独立的栈空间，从而减少了内存的使用量。</li>
<li>全程都在使用系统<strong>自动分配的栈空间</strong>，只不过是将一次调用和下一次调用之间所需要的数据利用某种数据结构（比如类的局部变量）<strong>手动保存了下来</strong></li>
<li>无栈协程的核心原理是将协程中的代码转换成一个或多个状态机。每当执行到协程内的一个异步调用时，协程会保存当前的状态（例如局部变量的值、程序执行到哪一行等），然后暂停执行，将控制权交回给协程的调度器或事件循环。当异步调用完成后，协程根据保存的状态恢复执行</li>
<li>实际上就是利用系统的数据结构（比如类的成员）保存状态，外界需要其重新执行的时候读取该状态再执行</li>
<li>例子<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程状态</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">CoroutineState</span> &#123;</span></span><br><span class="line">    BeforeStart = <span class="number">0</span>,</span><br><span class="line">    AfterHello,</span><br><span class="line">    AfterWorld,</span><br><span class="line">    Completed</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldCoroutine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 协程当前状态</span></span><br><span class="line">    CoroutineState state = CoroutineState::BeforeStart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程的执行函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CoroutineState::BeforeStart:</span><br><span class="line">                <span class="comment">// 第一个操作：打印&quot;Hello&quot;</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line">                <span class="comment">// 更新状态到下一步</span></span><br><span class="line">                state = CoroutineState::AfterHello;</span><br><span class="line">                <span class="comment">// 退出当前执行，模拟异步操作的暂停</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> CoroutineState::AfterHello:</span><br><span class="line">                <span class="comment">// 第二个操作：打印&quot;World&quot;</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// 更新状态到完成</span></span><br><span class="line">                state = CoroutineState::AfterWorld;</span><br><span class="line">                <span class="comment">// 退出当前执行</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> CoroutineState::AfterWorld:</span><br><span class="line">                <span class="comment">// 协程已完成，不做任何操作</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 非法状态</span></span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Invalid state&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查协程是否完成</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCompleted</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state == CoroutineState::AfterWorld;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HelloWorldCoroutine coroutine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环执行，直到协程状态表示完成</span></span><br><span class="line">    <span class="keyword">while</span> (!coroutine.<span class="built_in">isCompleted</span>()) &#123;</span><br><span class="line">        coroutine.<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实际上就是将需要的状态手动保存了下来，在被外界调用的时候手动的恢复，是一种比较间接的协程实现方法</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/03/13/windows%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/13/windows%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="post-title-link" itemprop="url">windows系统如何创建定时任务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-13 17:42:02 / 修改时间：17:46:15" itemprop="dateCreated datePublished" datetime="2024-03-13T17:42:02+08:00">2024-03-13</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>146</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Windows系统如何创建一个定时任务"><a href="#Windows系统如何创建一个定时任务" class="headerlink" title="Windows系统如何创建一个定时任务"></a>Windows系统如何创建一个定时任务</h2><ul>
<li>使用<strong>管理员权限</strong>打开一个控制台<ul>
<li><img src="/imgs/05b3098b43134a50913a3deb074131da39556d7d4ac3caa671c1254635d09220.png" alt="picture 0">  </li>
</ul>
</li>
<li>在其中输入<code>taskschd.msc</code><ul>
<li><img src="/imgs/ed1e4e8aadb2ab28e974680377859595ba24de404eed7c0d945ace3b3618edcc.png" alt="picture 1">  </li>
</ul>
</li>
<li>打开的管理器中点击<code>创建基本任务</code><ul>
<li><img src="/imgs/16cddef12607d83abfab09b7aff666eb054d0abc3dc388c60df294b2070f2a8d.png" alt="picture 2">  </li>
</ul>
</li>
<li>选择<code>每日</code><ul>
<li><img src="/imgs/73b385370bed1b8b084c405e7e96506a22846ab1690f8908e4515a9289e9dde0.png" alt="picture 3">  </li>
</ul>
</li>
<li>指定的开始时间就是每天的开始时间</li>
<li>执行的操作选择<code>执行程序</code></li>
<li>选择自己需要执行的脚本(.bat)文件或者直接在输入框里输入自己需要在命令行执行的命令也可以</li>
<li>完成即可</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/02/27/%E7%BB%99Jetson-Orin%E5%88%B7%E5%85%A5%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/%E7%BB%99Jetson-Orin%E5%88%B7%E5%85%A5%E5%AE%9E%E6%97%B6%E5%86%85%E6%A0%B8%E7%9A%84%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">给Jetson_Orin刷入实时内核的方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 17:57:16" itemprop="dateCreated datePublished" datetime="2024-02-27T17:57:16+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-18 16:01:48" itemprop="dateModified" datetime="2024-04-18T16:01:48+08:00">2024-04-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>964</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://docs.nvidia.com/jetson/archives/r35.1/DeveloperGuide/text/SD/Kernel/KernelCustomization.html#to-build-the-real-time-kernel">内核交叉编译参考</a></p>
</li>
<li><p>工具链的位置在<a target="_blank" rel="noopener" href="https://docs.nvidia.com/jetson/archives/r35.1/DeveloperGuide/text/AT/JetsonLinuxToolchain.html#at-jetsonlinuxtoolchain">工具链</a></p>
</li>
<li><p>先按照<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31985307/article/details/131499050">这个</a></p>
<ul>
<li>下载好内核源码之后，在<code>kernel</code>目录下输入命令<code>./kernel-5.10/scripts/rt-patch.sh apply-patches</code></li>
<li>执行结束后会输出<code>The PREEMPT RT patches have been successfully applied!</code></li>
</ul>
</li>
<li><p>然后在内核目录下执行<code>make menuconfig</code></p>
<ul>
<li>在General Setup下找到抢占的设置<code>preemption model</code></li>
<li><img src="/imgs/0f72dd5883389f992edc5d0f1120c66b4d983d40367140d3b3f63d0327b3c76b.png" alt="picture 2">  </li>
<li>设置为Real Time</li>
</ul>
</li>
<li><p>然后可能遇到报错，根据提示在内核源码目录下执行<code>make ARCH=arm64 mrproper</code></p>
</li>
<li><p>然后在<code>kernel</code>目录的根目录下执行<code>./nvbuild.sh -o $HOME/kernel_output</code></p>
<ul>
<li>输出到用户目录下的<code>kernel_output</code>目录下</li>
</ul>
</li>
<li><p><img src="/imgs/4a945185255bec8a132abb2b4ba6f2499463fe3991db2b0a0b2ebbb89a31ed95.png" alt="picture 3">  </p>
<ul>
<li>注意这一步编译的驱动所需要的SYSSRC是之前编译的内核源码的位置，而不是jetpack SDK下载的内核源码的位置</li>
</ul>
</li>
<li><p>但是又遇到报错</p>
<ul>
<li><img src="/imgs/cb8e8712b49db29b12288cd5ee486c801f50295f1eb2ac7841d226b74cace260.png" alt="picture 4">  </li>
</ul>
</li>
<li><p>暂时跳过这一步，先进行后面的rootfs构造</p>
</li>
<li><p>使用<code>sudo ./flash.sh jetson-agx-orin-devkit internal</code>刷机的时候，可以看到提示</p>
<ul>
<li><img src="/imgs/5d3e6ac968752060b3abf84a772935f6e04dd5e06ddb0334e0d100e32a26aed0.png" alt="picture 5">  </li>
<li>可以看出内核已经是rt内核了</li>
</ul>
</li>
<li><p>正在烧录中</p>
<ul>
<li><img src="/imgs/8883564a1d87479f161a1418df6b684aba778bb41cd53d4a1701bee7f46791cb.png" alt="picture 6">  </li>
</ul>
</li>
<li><p>然后小盒会自动重启</p>
<ul>
<li><img src="/imgs/c84bef522a1f99b075a3d50546bda1b82a6945a80562bbb38a4db7c16b44ea24.png" alt="picture 7">  </li>
</ul>
</li>
<li><p>遇到无法连接WiFi的情况，先链接eth0等跳过这个界面，遇到DHCP失败直接选择之后再配置即可</p>
</li>
<li><p>然后重启几次开发板，使用<code>sudo nmtui</code>命令在命令行UI界面配网即可</p>
</li>
</ul>
<h2 id="遇到刷机后因为SSH链接过而无法链接的问题"><a href="#遇到刷机后因为SSH链接过而无法链接的问题" class="headerlink" title="遇到刷机后因为SSH链接过而无法链接的问题"></a>遇到刷机后因为SSH链接过而无法链接的问题</h2><ul>
<li>windows一般在<code>用户/用户名/.ssh/known_hosts</code>文件，根据目标设备的IP地址查找到对应的条目，删除即可</li>
</ul>
<h2 id="手动启动-停止某个CPU核心的运行"><a href="#手动启动-停止某个CPU核心的运行" class="headerlink" title="手动启动/停止某个CPU核心的运行"></a>手动启动/停止某个CPU核心的运行</h2><ul>
<li><code>sudo sh -c &#39;echo 1 &gt; /sys/devices/system/cpu/cpu11/online&#39;</code>启动</li>
<li><code>sudo sh -c &#39;echo 1 &gt; /sys/devices/system/cpu/cpu11/online&#39;</code>停止<h2 id="某些实时内核下的CPU时序问题"><a href="#某些实时内核下的CPU时序问题" class="headerlink" title="某些实时内核下的CPU时序问题"></a>某些实时内核下的CPU时序问题</h2></li>
<li>这个小盒在部分CPU开启部分CPU关闭的时候，可能导致向量计算出错，推测是<code>simd</code>指令的问题，此时使用<code>torch</code>的时候，需要手动指定<code>torch.tensor</code>的设备<code>device=&quot;cpu&quot;</code>，同时使用上面的指令手动启动所有CPU核心</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/02/16/%E4%BD%BF%E7%94%A8Epoll%E5%92%8C%E5%8D%8F%E7%A8%8B%E5%A4%84%E7%90%86%E9%93%BE%E6%8E%A5%E7%9A%84socket%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/16/%E4%BD%BF%E7%94%A8Epoll%E5%92%8C%E5%8D%8F%E7%A8%8B%E5%A4%84%E7%90%86%E9%93%BE%E6%8E%A5%E7%9A%84socket%E5%BA%93/" class="post-title-link" itemprop="url">使用Epoll和协程处理链接的socket库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-16 12:03:12" itemprop="dateCreated datePublished" datetime="2024-02-16T12:03:12+08:00">2024-02-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:41:25" itemprop="dateModified" datetime="2024-04-27T15:41:25+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>953</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用epoll和协程处理信息的socket通信库"><a href="#使用epoll和协程处理信息的socket通信库" class="headerlink" title="使用epoll和协程处理信息的socket通信库"></a>使用epoll和协程处理信息的socket通信库</h1><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/frankzjz219/EpollWithCothread">github链接</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/frankzjz219/EpollWithCothread/blob/master/README.md">详细文档见readme</a></li>
<li>底层是<code>ucontext</code>和<code>epoll</code></li>
<li>提供一个<code>EpollServer</code>类</li>
<li><u>基于上一个协程库进行了面向对象的重构实现</u><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2></li>
<li>创建一个服务器socket</li>
<li>使用epoll检测每个事件</li>
<li>检测到新的客户端连接的时候，给对应的线程置一个flag，提示这个线程需要创建一个新的协程处理客户端链接的问题</li>
<li>新的协程自己在线程内创建协程（最好在同一个线程内创建和使用协程，否则会导致容易产生segmentation fault</li>
<li>创建之后将协程状态设置为suspend</li>
<li>等待epoll接收到信号之后，通过一个哈希映射将对应的协程状态设置为runnable提示该协程的调度器可以上处理机运行</li>
<li>然后对应的线程将协程调度上处理及，协程处理完之后会继续将自己设置为suspend状态并且下处理机，等待epoll激活自己</li>
<li>增加了定时器的功能，防止协程在睡眠的时候阻塞，提高时间利用率</li>
<li><img src="/imgs/e640db7fe4441dacd50fb75168ec849f663fb217507466062a98192ca46d2c0b.png" alt="picture 3">  </li>
</ul>
<h3 id="在命令行输出有颜色和格式的字符"><a href="#在命令行输出有颜色和格式的字符" class="headerlink" title="在命令行输出有颜色和格式的字符"></a>在命令行输出有颜色和格式的字符</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\033[0m  # 重置所有属性</span><br><span class="line">\033[1m  # 加粗</span><br><span class="line">\033[4m  # 下划线</span><br><span class="line">\033[5m  # 闪烁</span><br><span class="line">\033[7m  # 反显</span><br><span class="line">\033[8m  # 隐藏</span><br><span class="line">\033[30m # 黑色字体</span><br><span class="line">\033[31m # 红色字体</span><br><span class="line">\033[32m # 绿色字体</span><br><span class="line">\033[33m # 黄色字体</span><br><span class="line">\033[34m # 蓝色字体</span><br><span class="line">\033[35m # 洋红色字体</span><br><span class="line">\033[36m # 青色字体</span><br><span class="line">\033[37m # 白色字体</span><br><span class="line">\033[40m # 黑色背景</span><br><span class="line">\033[41m # 红色背景</span><br><span class="line">\033[42m # 绿色背景</span><br><span class="line">\033[43m # 黄色背景</span><br><span class="line">\033[44m # 蓝色背景</span><br><span class="line">\033[45m # 洋红色背景</span><br><span class="line">\033[46m # 青色背景</span><br><span class="line">\033[47m # 白色背景</span><br><span class="line">\033[100m # 灰色背景</span><br></pre></td></tr></table></figure>
<ul>
<li>红色字：<code>echo -e &quot;\033[31mHello, World!\033[0m&quot;</code></li>
<li>加粗、下划线、红色字体<code>echo -e &quot;\033[1;4;31mHello, World!\033[0m&quot;</code><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EpollServer <span class="title">ep</span><span class="params">(&lt;线程数&gt;, &lt;端口号&gt;)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>头文件是<code>epollServer.h</code></li>
<li>测试文件是<code>client.cpp</code></li>
<li>编译指令<code>g++ cothread.cpp main2.cpp epollServer.cpp -o test1 -lpthread -g</code></li>
</ul>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul>
<li><img src="/imgs/ae626bfbba4df521282f396667db59bfd973b27b5c08c2b72a6424160add6908.png" alt="picture 0">  </li>
<li><img src="/imgs/8639637e99dfcedbb0c55310eb593ff91154c22020a12c15b662f121dbf2bf54.png" alt="picture 1">  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/02/03/Linux%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/03/Linux%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/" class="post-title-link" itemprop="url">Linux信号量Semaphore进程间同步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-03 23:02:50 / 修改时间：23:23:10" itemprop="dateCreated datePublished" datetime="2024-02-03T23:02:50+08:00">2024-02-03</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Semaphone-信号量多进程同步"><a href="#Semaphone-信号量多进程同步" class="headerlink" title="Semaphone 信号量多进程同步"></a>Semaphone 信号量多<u>进程</u>同步</h2><ul>
<li>可以使用 POSIX 信号量（semaphore）来进行进程间的同步</li>
<li><code>#include &lt;semaphore.h&gt;</code></li>
<li>然后可以在使用<code>fork()</code>创建新的进程的时候，使用<code>semaphone</code>控制进程同步，两个进程可以利用semaphore互相控制</li>
<li>主要的api是<ul>
<li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code>创建</li>
<li><code>int sem_destroy(sem_t *sem);</code>销毁</li>
<li><code>int sem_wait(sem_t *sem);</code>阻塞等待</li>
<li><code>int sem_trywait(sem_t *sem);</code>尝试等待，不阻塞</li>
<li><code>int sem_post(sem_t *sem);</code>释放</li>
<li><code>int sem_getvalue(sem_t *sem, int *sval);</code>获取信号量的值<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span> mySemaphore;</span><br><span class="line">    sem_init(&amp;mySemaphore, <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 参数 1 表示信号量在进程间共享，初始值为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> childPid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (childPid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Fork failed.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childPid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        sem_wait(&amp;mySemaphore);  <span class="comment">// 等待信号量</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child process is executing.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        sem_post(&amp;mySemaphore);  <span class="comment">// 释放信号量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        sem_wait(&amp;mySemaphore);  <span class="comment">// 等待信号量</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent process is executing.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        sem_post(&amp;mySemaphore);  <span class="comment">// 释放信号量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待子进程结束</span></span><br><span class="line">        wait(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;mySemaphore);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>也可以在不同的线程之间用于同步<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> mySemaphore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunction</span><span class="params">(<span class="keyword">int</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在线程内等待信号量</span></span><br><span class="line">    sem_wait(&amp;mySemaphore);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; threadId &lt;&lt; <span class="string">&quot; is in the critical section.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开临界区后释放信号量</span></span><br><span class="line">    sem_post(&amp;mySemaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;mySemaphore, <span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 在线程间共享，初始值为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个线程</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(threadFunction, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(threadFunction, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    sem_destroy(&amp;mySemaphore);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/31/Linux%E4%B8%8BC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/31/Linux%E4%B8%8BC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Linux下C语言开发技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-31 11:39:58" itemprop="dateCreated datePublished" datetime="2024-01-31T11:39:58+08:00">2024-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-05 11:29:44" itemprop="dateModified" datetime="2024-02-05T11:29:44+08:00">2024-02-05</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="比较的宏以及typeof-类型判断宏"><a href="#比较的宏以及typeof-类型判断宏" class="headerlink" title="比较的宏以及typeof()类型判断宏`"></a>比较的宏以及<code>typeof()</code>类型判断宏`</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="comment">// 上述无法处理包含a++等的情况</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>typeof()</code><strong>类转换宏</strong>处理<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) (&#123;        \</span></span><br><span class="line"><span class="meta">    typeof(a) _a = (a);      \</span></span><br><span class="line"><span class="meta">    typeof(b) _b = (b);      \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_a == &amp;_b);   \</span></span><br><span class="line"><span class="meta">    _a &gt; _b ? _a : _b; &#125;)</span></span><br></pre></td></tr></table></figure></li>
<li><code>typeof(a) _a = (a)</code>定义一个a类型的变量，值等于a</li>
<li><code>(void) (&amp;_a == &amp;_b)</code>判断二者类型是否相同，<u>不同的话会出现警告</u><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typeof(<span class="keyword">int</span> *) a,b;<span class="comment">//等价于：int *a,*b;</span></span><br></pre></td></tr></table></figure>
<h2 id="零长数组（变长数组）"><a href="#零长数组（变长数组）" class="headerlink" title="零长数组（变长数组）"></a>零长数组（变长数组）</h2></li>
<li>满足需要变长度的结构体，因此有时也习惯性地称为变长数组。</li>
<li>在一个结构体的最后, 申明一个长度为0的数组, 就可以使得这个结构体是可变长的<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">thisline</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct line) + this_length);</span><br><span class="line">thisline-&gt;length = this_length;</span><br></pre></td></tr></table></figure></li>
<li>上述结构体本身的大小只有一个length的大小，不包括content</li>
<li>创建的时候人为分配空间给contents即可</li>
</ul>
<h2 id="switch-case的条件指定范围"><a href="#switch-case的条件指定范围" class="headerlink" title="switch case的条件指定范围"></a>switch case的条件指定范围</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> low ... high:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> ..<span class="number">.&#x27;</span>Z<span class="number">&#x27;</span>:</span><br></pre></td></tr></table></figure>
<ul>
<li>还可以用整形数来表示范围，但是这里需要注意在“…”两边有空格</li>
</ul>
<h2 id="struct的指定成员初始化"><a href="#struct的指定成员初始化" class="headerlink" title="struct的指定成员初始化"></a>struct的指定成员初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三维点的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3D</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含点操作的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointOperations</span> &#123;</span></span><br><span class="line">    <span class="comment">// 函数指针，用于计算两个点的距离</span></span><br><span class="line">    <span class="keyword">double</span> (*calculateDistance)(<span class="keyword">const</span> struct Point3D* p1, <span class="keyword">const</span> struct Point3D* p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数指针，用于打印点的坐标</span></span><br><span class="line">    <span class="keyword">void</span> (*printCoordinates)(<span class="keyword">const</span> struct Point3D* point);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个点的距离的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculateDistance</span><span class="params">(<span class="keyword">const</span> struct Point3D* p1, <span class="keyword">const</span> struct Point3D* p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx = p1-&gt;x - p2-&gt;x;</span><br><span class="line">    <span class="keyword">int</span> dy = p1-&gt;y - p2-&gt;y;</span><br><span class="line">    <span class="keyword">int</span> dz = p1-&gt;z - p2-&gt;z;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy + dz*dz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印点的坐标的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCoordinates</span><span class="params">(<span class="keyword">const</span> struct Point3D* point)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d, %d)\n&quot;</span>, point-&gt;x, point-&gt;y, point-&gt;z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个三维点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point3D</span> <span class="title">pointA</span> =</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化操作的结构体并初始化函数指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PointOperations</span> <span class="title">pointOps</span> =</span> &#123;</span><br><span class="line">        .calculateDistance = calculateDistance,</span><br><span class="line">        .printCoordinates = printCoordinates</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构体中的函数指针计算两个点的距离</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point3D</span> <span class="title">pointB</span> =</span> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> distance = pointOps.calculateDistance(&amp;pointA, &amp;pointB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Distance between points: %f\n&quot;</span>, distance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构体中的函数指针打印点的坐标</span></span><br><span class="line">    pointOps.printCoordinates(&amp;pointA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上文中的指定名称初始化是<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义点操作的结构体并初始化函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointOperations</span> <span class="title">pointOps</span> =</span> &#123;</span><br><span class="line">    .calculateDistance = calculateDistance,</span><br><span class="line">    .printCoordinates = printCoordinates</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这里可以手动指定需要初始化的结构体成员的名字</li>
</ul>
<h2 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_debug(fmt, ...) \</span></span><br><span class="line"><span class="meta">    dynamic_pr_debug(fmt, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>dynamic_pr_debug 是 Linux 内核中用于动态调试打印的宏，而 fmt 和 <code>__VA_ARGS__</code> 则是格式化字符串和可变参数列表。</p>
</li>
<li><p>fmt：格式化字符串，类似于 printf 中的格式化字符串，包含要打印的文本和格式说明符。</p>
</li>
<li><p><code>__VA_ARGS__</code>：表示可变参数的宏，用于将额外的参数传递给 fmt 中的格式说明符。</p>
</li>
<li><p><code>##__VA_ARGS__</code> 是一个预处理器技巧，用于处理当可变参数列表为空时的情况，确保宏在没有额外参数时也能正确展开</p>
</li>
</ul>
<h2 id="函数属性-attribute"><a href="#函数属性-attribute" class="headerlink" title="函数属性 __attribute__"></a>函数属性 <code>__attribute__</code></h2><ul>
<li><p><code>__attribute__ ((attribute-list))</code></p>
</li>
<li><p><code>attribute-list</code>的定义有很多，如<code>noreturn</code>、<code>format</code>以及<code>const</code>等。此外，还可以定义一些和处理器体系结构相关的函数属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__((noreturn)) die(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>其他属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pure           __attribute__((pure))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __aligned(x)        __attribute__((aligned(x)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __printf(a, b)      __attribute__((format(printf, a, b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __scanf(a, b)       __attribute__((format(scanf, a, b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noinline          __attribute__((noinline))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __attribute_const__   __attribute__((__const__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __maybe_unused      __attribute__((unused))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __always_unused      __attribute__((unused))</span></span><br></pre></td></tr></table></figure>
<h2 id="变量属性和类属性"><a href="#变量属性和类属性" class="headerlink" title="变量属性和类属性"></a>变量属性和类属性</h2></li>
<li><p>变量属性可以对变量或结构体成员进行属性设置。类型属性常见的属性有<code>alignment</code>、<code>packed</code>和<code>sections</code>等。</p>
</li>
<li><p><code>alignment</code>属性规定变量或者结构体成员的最小对齐格式，以字节为单位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qib_user_info</span> &#123;</span></span><br><span class="line">    __u32 spu_userversion;</span><br><span class="line">    __u64 spu_base_info;</span><br><span class="line">&#125; __aligned(<span class="number">8</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>上述例子中结构体存储会以八字节对齐</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line"> <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">2</span>] __attribute__ ((packed));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>x成员使用了packed属性，它会存储在变量a后面，所以这个结构体一共占用9字节</p>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2></li>
<li><p>内建函数以“_builtin_”作为函数名前缀。下面介绍Linux内核常用的一些内建函数</p>
</li>
<li><p><code>__builtin_constant_p(x)</code>：判断x是否在编译时就可以被确定为常量。如果x为常量，该函数返回1，否则返回0</p>
</li>
<li><p><code>__builtin_expect(exp, c)</code>：这里的意思是<code>exp==c</code>的概率很大，用来引导GCC编译器进行条件分支预测</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __swab16(x)        \</span></span><br><span class="line"><span class="meta">(__builtin_constant_p((__u16)(x)) ?  \</span></span><br><span class="line"><span class="meta">___constant_swab16(x) :      \</span></span><br><span class="line"><span class="meta">__fswab16(x))__builtin_expect(exp, c)</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>__builtin_prefetch(const void *addr, int rw, int locality)</code>：主动进行数据预取，在使用<strong>地址addr的值之前就把其值加载到cache中</strong>，<u>减少读取的延迟</u>，从而提高性能。</p>
<ul>
<li><p>该函数可以接受3个参数：</p>
<ul>
<li>第一个参数addr表示要预取数据的地址；</li>
<li>第二个参数rw表示读写属性，1表示可写，0表示只读；</li>
<li>第三个参数locality表示数据在cache中的时间局部性，其中0表示读取完addr的之后不用保留在cache中，而1～3表示时间局部性逐渐增强</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="asmlinkage"><a href="#asmlinkage" class="headerlink" title="asmlinkage"></a>asmlinkage</h2><ul>
<li>在标准C语言中，函数的形参在实际传入参数时会涉及参数存放问题</li>
<li>对于x86架构，函数参数和局部变量被一起分配到函数的局部堆栈里<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;arch/x86/include/<span class="keyword">asm</span>/linkage.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))</span></span><br></pre></td></tr></table></figure></li>
<li>告诉编译器一个声明了<code>asmlinkage</code>的函数<strong>不需要通过任何寄存器来传递参数，只通过堆栈来传递</strong></li>
<li>用法<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">my_assembly_function</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 汇编函数的实现</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>asmlinkage 用于标识 my_assembly_function 是一个汇编语言编写的函数，并且该函数使用堆栈而不是寄存器来传递参数</li>
<li>对于ARM来说，函数参数的传递有一套ATPCS标准，即通过寄存器来传递。<strong>ARM中的R0～R4寄存器存放传入参数，当参数超过5个时，多余的参数被存放在局部堆栈中</strong><ul>
<li>ARM平台没有定义asmlinkage</li>
</ul>
</li>
</ul>
<h2 id="switch-case和枚举类型配合使用"><a href="#switch-case和枚举类型配合使用" class="headerlink" title="switch case和枚举类型配合使用"></a>switch case和枚举类型配合使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(name) \</span></span><br><span class="line"><span class="meta">    case LogLevel::name: \</span></span><br><span class="line"><span class="meta">        return #name; \</span></span><br><span class="line"><span class="meta">        break;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (level1) &#123;</span><br><span class="line">    XX(DEBUG);</span><br><span class="line">    XX(INFO);</span><br><span class="line">    XX(WARN);</span><br><span class="line">    XX(ERROR);</span><br><span class="line">    XX(FATAL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UNKNOWN&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此前包含一个枚举类型的定义包括<code>DEBUG</code>等</li>
<li>这个可以将枚举类型的数字逆向映射为字符串（通过<code>#name</code>转换为字符串）</li>
</ul>
<h2 id="std-enable-shared-from-this"><a href="#std-enable-shared-from-this" class="headerlink" title="std::enable_shared_from_this"></a>std::enable_shared_from_this</h2><ul>
<li><strong>安全的</strong>获取一个对象的this指针<ul>
<li>防止重复析构等情况</li>
</ul>
</li>
<li>使用<code>shared_from_this()</code>函数返回当前函数的共享指针</li>
<li>使用例<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> std::enable_shared_from_this&lt;Widget&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Widget constructor run&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Widget</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Widget destructor run&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">GetSharedObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Widget())</span></span>;</span><br><span class="line">    std::shared_ptr&lt;Widget&gt; q = p-&gt;<span class="built_in">GetSharedObject</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; q.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="thread-local关键字"><a href="#thread-local关键字" class="headerlink" title="thread_local关键字"></a>thread_local关键字</h2><ul>
<li><code>thread_local</code> 是 C++11 标准引入的关键字，用于声明线程局部存储（Thread-local storage，TLS）变量。线程局部存储意味着每个线程都有自己独立的变量副本，这样可以避免线程间的竞争条件</li>
<li>使得每个线程都有自己独立的某个这个变量的副本而不是与其他线程共享<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> threadSpecificValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个线程都有独立的 threadSpecificValue</span></span><br><span class="line">    threadSpecificValue += <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread Specific Value: &quot;</span> &lt;&lt; threadSpecificValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个线程，并在每个线程中调用 threadFunction</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程执行完成</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/" class="post-title-link" itemprop="url">背包问题（动态规划）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-26 21:36:09" itemprop="dateCreated datePublished" datetime="2024-01-26T21:36:09+08:00">2024-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-19 23:08:42" itemprop="dateModified" datetime="2024-06-19T23:08:42+08:00">2024-06-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode-416-分割等和子集"><a href="#Leetcode-416-分割等和子集" class="headerlink" title="Leetcode 416. 分割等和子集"></a>Leetcode 416. 分割等和子集</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">背包原理教程</a></li>
<li>此题实际上就是使用数组的元素作为物品，数组元素本身的大小就是价值，讨论是否能使用数组中的元素凑出数组大小一半的值</li>
<li>使用的是01背包，倒序遍历即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = <span class="built_in">max</span>(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">// int num = nums[i];</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] = dp[j]|dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-1049-最后一块石头重量-II"><a href="#Leetcode-1049-最后一块石头重量-II" class="headerlink" title="Leetcode 1049. 最后一块石头重量 II"></a>Leetcode 1049. 最后一块石头重量 II</h2><ul>
<li>主要思路还是背包问题，只不过此时的背包容量和装的物品的价值<strong>都是石头的重量</strong></li>
<li><u>注意内存循环必须从后往前遍历，否则会导致前面被添加过的物品被连续重复添加</u></li>
<li>外层循环的意思是使用到的石头是<code>0</code>-<code>i</code>个，内层的意思是石头<u>总重不超过某个值的时候的最大总重是多少</u><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:stones)sum+=i;</span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxArr</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;stones.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wi = stones[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j&gt;=wi; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                maxArr[j] = <span class="built_in">max</span>(maxArr[j], maxArr[j-wi]+wi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - (maxArr[target]*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-474-一和零"><a href="#Leetcode-474-一和零" class="headerlink" title="Leetcode 474. 一和零"></a>Leetcode 474. 一和零</h2><ul>
<li>此题是一个递推问题，做题方式类似于背包法</li>
<li>遍历同样是外层循环指定此时能使用的字符串的最大index</li>
<li>内层循环从已经可达的位置往外递推，类似于广度优先搜索<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// int maxLen;</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; lenMap;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c0 = <span class="number">0</span>, c1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a:i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a == <span class="string">&#x27;0&#x27;</span>)++c0;</span><br><span class="line">                <span class="keyword">else</span> ++c1;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(c0, c1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        map[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c0 = arr[i].first;</span><br><span class="line">            <span class="keyword">int</span> c1 = arr[i].second;</span><br><span class="line">            <span class="comment">// int s = q.size();</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j&gt;=c0; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n; k&gt;=c1; --k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[j-c0][k-c1]&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    map[j][k] = <span class="built_in">max</span>(map[j-c0][k-c1]+<span class="number">1</span>, map[j][k]);</span><br><span class="line">                    map[m][n] = <span class="built_in">max</span>(map[m][n], map[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[m][n]&lt;<span class="number">0</span>?<span class="number">0</span>:map[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-518-零钱兑换II"><a href="#Leetcode-518-零钱兑换II" class="headerlink" title="Leetcode 518. 零钱兑换II"></a>Leetcode 518. 零钱兑换II</h2></li>
<li>此题是一个完全背包类型的题<a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">参考链接</a></li>
<li>注意循环次序的变化，0 1背包循环一般内层递推循环都是倒序的，但是这种是正序的</li>
<li>完全背包遍历背包容量的时候是正序的，但是不完全背包遍历背包容量是倒序的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(amount+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// queue&lt;int&gt; q;</span></span><br><span class="line">        <span class="comment">// q.push(0);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;coins.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coins[i]; j&lt;=amount; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j]+=arr[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-377-组合总和IV"><a href="#Leetcode-377-组合总和IV" class="headerlink" title="Leetcode 377. 组合总和IV"></a>Leetcode 377. 组合总和IV</h2></li>
<li>如果求<strong>组合数</strong>就是外层for循环遍历物品，内层for遍历背包。</li>
<li>如果求<strong>排列数</strong>就是外层for遍历背包，内层for循环遍历物品。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; <span class="title">arr</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=target; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&gt;=<span class="number">0</span>)</span><br><span class="line">                arr[j]+=arr[j-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-279-完全平方数"><a href="#Leetcode-279-完全平方数" class="headerlink" title="Leetcode 279. 完全平方数"></a>Leetcode 279. 完全平方数</h2><ul>
<li>转化为一个完全背包问题即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; minCnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        minCnt = vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        minCnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i*i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;=n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minCnt[j-i]!=INT_MAX)minCnt[j] = <span class="built_in">min</span>(minCnt[j], minCnt[j-i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCnt[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="卡码网-28-子序列中的-k-种字母"><a href="#卡码网-28-子序列中的-k-种字母" class="headerlink" title="卡码网 28. 子序列中的 k 种字母"></a>卡码网 28. 子序列中的 k 种字母</h2><ul>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1028">链接</a></li>
<li>此题是一个背包问题，主要是先统计字符串中26个字母每个包含几个</li>
<li>因为顺序无所谓，因此直接开始找字母的种类</li>
<li>假设此时字符串已经有了k种字母，凑到k+1种字母的方式就是通过添加一个新的种类的字母，但是新的种类的字母可能有多个备选项比如<code>n</code></li>
<li>那么最终的字符串中可以在这n的字母种选择小于等于n的任意个，选择方式共有<img src="/imgs/b43e2b5ad8a38f7eed236cc409d35ddf366b245f2701794b13aac3c9ffb3073d.png" alt="picture 0">  种，上述结果的求和是<code>2^n-1</code></li>
<li>因此实际上在递推背包的时候，假如当前选择的字母的个数有n个，那么具有k种字母的字符串的种类是具有k-1种字母的字符串的种类*<code>2^n-1</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; letters;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        letters[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">combs</span><span class="params">(k+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    combs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;i : letters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sec = (<span class="keyword">long</span> <span class="keyword">long</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, i.second)<span class="number">-1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j&gt;=<span class="number">1</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            combs[j]+=combs[j<span class="number">-1</span>]*sec;</span><br><span class="line">            combs[j]%=<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;combs[k]%<span class="number">1000000007</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nowcoder-HJ16-购物单"><a href="#nowcoder-HJ16-购物单" class="headerlink" title="nowcoder HJ16 购物单"></a>nowcoder HJ16 购物单</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&tqId=21239&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?page=2&tpId=37&type=37&difficulty=undefined&judgeStatus=undefined&tags=&title=">链接</a></li>
<li>此题是一个分组背包问题，也就是每一组的物品只能买一个</li>
<li>主要是在遍历每一组的不同物品尝试的时候，不能修改本身的dp数组，要遍历完某一个分组之后再修改</li>
<li>此题因为一个物品最多有2个附属物品，因此每一组最多也就是4种组合，可以直接枚举<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money, n;</span><br><span class="line">    cin&gt;&gt;money&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">items</span>(n);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            items[i].<span class="built_in">insert</span>(items[i].<span class="built_in">begin</span>(), &#123;a, b, a*b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            items[c<span class="number">-1</span>].<span class="built_in">push_back</span>(&#123;a, b, a*b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(items[i].<span class="built_in">size</span>() ==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(items[i].<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">0</span>] += items[i][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">1</span>] += items[i][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">2</span>] += items[i][<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(items[i].<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">       &#123;</span><br><span class="line">            items[i].<span class="built_in">push_back</span>(&#123;items[i][<span class="number">0</span>][<span class="number">0</span>]+items[i][<span class="number">1</span>][<span class="number">0</span>]+items[i][<span class="number">2</span>][<span class="number">0</span>], items[i][<span class="number">0</span>][<span class="number">1</span>]+items[i][<span class="number">1</span>][<span class="number">1</span>]+items[i][<span class="number">2</span>][<span class="number">1</span>], items[i][<span class="number">0</span>][<span class="number">2</span>]+items[i][<span class="number">1</span>][<span class="number">2</span>]+items[i][<span class="number">2</span>][<span class="number">2</span>]&#125;);</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">0</span>] = items[i][<span class="number">0</span>][<span class="number">0</span>]+items[i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">1</span>] = items[i][<span class="number">0</span>][<span class="number">1</span>]+items[i][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">2</span>] = items[i][<span class="number">0</span>][<span class="number">2</span>]+items[i][<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            items[i][<span class="number">2</span>][<span class="number">0</span>] = items[i][<span class="number">0</span>][<span class="number">0</span>]+items[i][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">            items[i][<span class="number">2</span>][<span class="number">1</span>] = items[i][<span class="number">0</span>][<span class="number">1</span>]+items[i][<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">            items[i][<span class="number">2</span>][<span class="number">2</span>] = items[i][<span class="number">0</span>][<span class="number">2</span>]+items[i][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(money+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dpRes = dp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = items[i].<span class="built_in">size</span>()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; dpTmp = dp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = money; k&gt;=items[i][j][<span class="number">0</span>]; --k)</span><br><span class="line">            &#123;</span><br><span class="line">                dpTmp[k] = <span class="built_in">max</span>(dpTmp[k], dpTmp[k-items[i][j][<span class="number">0</span>]]+items[i][j][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b&lt;dp.<span class="built_in">size</span>(); ++b)</span><br><span class="line">            &#123;</span><br><span class="line">                dpRes[b] = <span class="built_in">max</span>(dpTmp[b], dpRes[b]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = dpRes;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[money];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64 位输出请用 printf(&quot;%lld&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h2></li>
<li>此题不能用传统的背包理论做，因为是每个物品必须用到而不是可用可不用</li>
<li>使用了两个数组滚动进行更新，从上一次迭代能达到的位置出发，推算这一次迭代能达到的位置以及能达到的方式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> maxAbs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            maxAbs+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = nums[i];</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> p : arr)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[p.first+n]+=p.second;</span><br><span class="line">                tmp[p.first-n]+=p.second;</span><br><span class="line">            &#125;</span><br><span class="line">            arr = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr[target];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/22/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Linux进程、线程等底层原理笔记（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 20:11:48" itemprop="dateCreated datePublished" datetime="2024-01-22T20:11:48+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-18 20:23:17" itemprop="dateModified" datetime="2024-04-18T20:23:17+08:00">2024-04-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h2><ul>
<li><code>fork</code>创建进程的时候，将父进程的所有资源拷贝给子进程<ul>
<li>写时复制的</li>
<li>实际上是将内存地址设置为只读的</li>
<li>假如任何一个进程试图写入的话，会触发<code>page fault</code>导致系统给他分配新的内存，也就是复制</li>
</ul>
</li>
<li><code>vfork</code>的时候是直接将子进程的资源指向父进程的，二者是同时共有资源的，一个修改会影响另一个<h2 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h2></li>
<li>通过<code>pthread_create</code>创建线程的时候，实际上是调用系统的<code>clone</code>（类似于<code>vfork</code>）方式创建了一个<u>与父进程共享一切资源的子进程</u></li>
<li><img src="/imgs/df695c03041cf38aefbc7ecbbdedac0edeb848523d8e8e8de52c8026a22c85fe.png" alt="picture 0">  </li>
<li>本来理论上父子进程之间的资源是写时复制的，但是这里直接共享了</li>
<li>每个线程都有一个独立的PID<h3 id="线程的真假ID"><a href="#线程的真假ID" class="headerlink" title="线程的真假ID"></a>线程的真假ID</h3></li>
<li>用户空间<code>getpid()</code>获得的PID是<u>进程ID</u>，并不是线程独立的PID<ul>
<li><code>gettid()</code>获得的才是真正<strong>线程PID</strong>，也就是内核的真正PID</li>
<li><img src="/imgs/a91e7465f98780d02621e8f5b9b630367fa9ac81365bb4c16b76064c3b778a4c.png" alt="picture 1">  </li>
</ul>
</li>
</ul>
<h2 id="进程的托孤"><a href="#进程的托孤" class="headerlink" title="进程的托孤"></a>进程的托孤</h2><ul>
<li>一个拥有子进程的进程终止的时候，会向init进程或者是自己最近一级的父进程中的subreaper进程托孤，将自己的子进程交给这些进程处理<ul>
<li>subreaper需要一个进程<strong>自己声明自己是</strong>才可以<h2 id="深度睡眠和浅度睡眠"><a href="#深度睡眠和浅度睡眠" class="headerlink" title="深度睡眠和浅度睡眠"></a>深度睡眠和浅度睡眠</h2></li>
</ul>
</li>
<li>深度睡眠只能被资源唤醒<ul>
<li>甚至无法被信号杀死</li>
</ul>
</li>
<li>浅度睡眠可以被资源或者是信号（signal）唤醒</li>
<li>比如程序因为内存没加载导致page fault<ul>
<li>此时如果因为接收到信号开始执行内容，会导致程序继而触发更多的page fault</li>
<li>因此只有等到相关内存页面被分配了才可以</li>
</ul>
</li>
</ul>
<h2 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h2><ul>
<li>程序的睡眠是程序访问资源的时候发现需要等待，自己让出CPU使用权并且将状态设置为sleep</li>
<li>睡眠结束的时候需要判断自己是被什么唤醒的（如果是浅度睡眠的话）<ul>
<li>是被信号唤醒的？是什么信号</li>
<li>是被资源唤醒的？继续执行</li>
</ul>
</li>
</ul>
<h2 id="第一个进程是被谁创建出来的"><a href="#第一个进程是被谁创建出来的" class="headerlink" title="第一个进程是被谁创建出来的"></a>第一个进程是被谁创建出来的</h2><ul>
<li>1进程（也就是init）是被Linux的0进程创建出来的</li>
<li>但是Linux的0进程使用pstree看不到</li>
<li>退化为了IDLE进程<ul>
<li>所有进程停止或者睡眠之后，才会调度的进程</li>
<li>它会把将CPU设置为省电状态，只有中断可以唤醒<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2></li>
</ul>
</li>
<li>进程切换的开销不只是上下文切换，主要还包括进程切换引起的内存cache 的<code>cache miss</code></li>
<li>因为不同进程需要的内存空间不同，导致切换会极大增加miss概率</li>
</ul>
<h2 id="非实时进程的时间片分配"><a href="#非实时进程的时间片分配" class="headerlink" title="非实时进程的时间片分配"></a>非实时进程的时间片分配</h2><ul>
<li>使用<code>nice</code>值分配</li>
<li><code>nice</code>越大，优先级越低</li>
<li>优先级高的相对于优先级低的可以在唤醒的一瞬间抢占，但是之后会一起轮转</li>
<li>优先级越高的在轮转中分配到的时间片越长</li>
<li>在整个循环过程中是所有优先级的进程一起轮转的，不会高优先级阻塞低优先级运行</li>
<li>系统会针对应用是IO类型还是CPU消耗类型来调整nice值<ul>
<li>越CPU占用，nice越低<h2 id="控制实时进程和非实时进程占用的CPU比例"><a href="#控制实时进程和非实时进程占用的CPU比例" class="headerlink" title="控制实时进程和非实时进程占用的CPU比例"></a>控制实时进程和非实时进程占用的CPU比例</h2></li>
</ul>
</li>
<li><code>sched_rt_period_us</code>和<code>shced_rt_runtime_us</code></li>
<li>控制FIFO和RR最多占用的时间</li>
<li><code>sudo sh -c &#39;echo CPU核心数*1000000 &gt; /proc/sys/kernel/sched_rt_period_us&#39;</code><ul>
<li>上面那个不能超过<code>CPU核心数*1000000</code></li>
</ul>
</li>
<li><code>sudo sh -c &#39;echo 某个小于period的值 &gt; /proc/sys/kernel/sched_rt_runtime_us&#39;</code></li>
<li>不能超过<code>sched_rt_period_us</code><ul>
<li><strong>但是可能会导致系统崩溃</strong></li>
</ul>
</li>
<li><img src="/imgs/852dd435f32fd9baa80f8fd4e531104996a4aefc62f80afc69816d2f63d3c04a.png" alt="picture 2">  </li>
</ul>
<h2 id="CFS-完全公平调度"><a href="#CFS-完全公平调度" class="headerlink" title="CFS-完全公平调度"></a>CFS-完全公平调度</h2><ul>
<li>每次都调度到当前位置vruntime最小的进程</li>
<li>也就是考虑到优先级修正之后，运行时间最小的进程</li>
<li>完全公平，使得所有进程的vruntime尽可能公平分配<ul>
<li>vruntime是实际运行时间进行一些权重和系数运算得出的</li>
<li>物理runtime除以权重</li>
<li><img src="/imgs/e478ee6ad032f1596c2fb5c13bad47341d7da1c13f4987d3cee46d0360a00958.png" alt="picture 3">  </li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>System Call</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>nice()</td>
<td>Sets a process’s nice value</td>
</tr>
<tr>
<td>sched_setscheduler()</td>
<td>Sets a process’s scheduling policy</td>
</tr>
<tr>
<td>sched_getscheduler()</td>
<td>Gets a process’s scheduling pol1icy</td>
</tr>
<tr>
<td>sched_setparam()</td>
<td>Sets a process’s real-time priority</td>
</tr>
<tr>
<td>sched_getparam()</td>
<td>Gets a process’s real-time priority</td>
</tr>
<tr>
<td>sched_get_priority_max()</td>
<td>Gets the maximum real-time priority</td>
</tr>
<tr>
<td>sched_get_priority_min()</td>
<td>Gets the minimum real-time priority</td>
</tr>
<tr>
<td>sched_rr_get_interval()</td>
<td>Gets a process’s timeslice value</td>
</tr>
<tr>
<td>sched_setaffinity()</td>
<td>Sets a process’s processor affinity</td>
</tr>
<tr>
<td>sched_getaffinity()</td>
<td>Gets a process’s processor affinity</td>
</tr>
<tr>
<td>sched_yield()</td>
<td>Temporarily yields the processor</td>
</tr>
</tbody></table>
<h2 id="设置进程的CPU亲和"><a href="#设置进程的CPU亲和" class="headerlink" title="设置进程的CPU亲和"></a>设置进程的CPU亲和</h2><ul>
<li>使用<code>taskset</code>命令行工具</li>
<li>上文提到的<code>sched_setaffinity()</code></li>
<li>或者单独设置线程的亲和力<code>pthread_setaffinity_np()</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>或者创建新线程时，通过属性结构体，控制新线程的亲和性<code>pthread_attr_setaffinity_np()</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setaffinity_np</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><ul>
<li>cgroup（Control Groups）是 Linux 内核提供的一个功能，用于限制、控制和监视一个或多个进程的资源使用。cgroup 允许你将进程组织在层次结构中，并为每个组分配特定的资源限制。</li>
<li>创建<ul>
<li><code>sudo mkdir /sys/fs/cgroup/cpu/my_cgroup</code></li>
</ul>
</li>
<li>添加进程<ul>
<li><code>echo &lt;PID&gt; &gt; /sys/fs/cgroup/cpu/my_cgroup/tasks</code></li>
</ul>
</li>
<li>设置 cgroup 的资源限制<ul>
<li><code>echo 1000000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us</code></li>
</ul>
</li>
<li>查看 cgroup 信息<ul>
<li><code>cat /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us</code></li>
</ul>
</li>
<li>删除 cgroup<ul>
<li><code>sudo rmdir /sys/fs/cgroup/cpu/my_cgroup</code></li>
</ul>
</li>
</ul>
<h2 id="如何使用sudo权限将echo的输出写入到文件中"><a href="#如何使用sudo权限将echo的输出写入到文件中" class="headerlink" title="如何使用sudo权限将echo的输出写入到文件中"></a>如何使用sudo权限将echo的输出写入到文件中</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;echo string &gt; /path/to/file&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">echo &quot;Hello, world&quot; | sudo tee -a /path/to/file</span><br></pre></td></tr></table></figure>
<h2 id="Linux中进程可以抢占的部分"><a href="#Linux中进程可以抢占的部分" class="headerlink" title="Linux中进程可以抢占的部分"></a>Linux中<code>进程</code>可以抢占的部分</h2><ul>
<li>即使是在下面不可调度的部分唤醒了一个优先级再高的进程，也不允许抢占执行</li>
<li>一个核心上的进程拿到了spinlock，会直接关闭这个核心的调度器停止调度</li>
<li>一个程序的<strong>优先级改变（降低）</strong>的时候，别的优先级高的进程可以<strong>立即抢占</strong></li>
</ul>
<table>
<thead>
<tr>
<th>区间</th>
<th>可调度性</th>
</tr>
</thead>
<tbody><tr>
<td>（硬）中断（不允许中断嵌套）</td>
<td>不可调度</td>
</tr>
<tr>
<td>软中断（可以中断嵌套）</td>
<td>不可调度</td>
</tr>
<tr>
<td>进程上下文中获取到<code>spinlock</code></td>
<td>不可调度</td>
</tr>
<tr>
<td>其他进程上下文</td>
<td>可以调度</td>
</tr>
</tbody></table>
<ul>
<li>自旋锁的自旋一定发生在不同的核心之间<ul>
<li>如果同一个核心的两个进程争夺自旋锁，一个抢到之后就直接关闭了调度器，另一个进程根本上不来，不可能自旋</li>
<li>只有可能是一个核心持有锁，另一个核心自旋</li>
</ul>
</li>
</ul>
<h2 id="进程回收和僵尸进程"><a href="#进程回收和僵尸进程" class="headerlink" title="进程回收和僵尸进程"></a>进程回收和僵尸进程</h2><ul>
<li>一个进程变成僵尸状态之后，进程的资源都消失了</li>
<li>但是进程的<code>task_struct</code>还没有消失</li>
<li>等待父进程使用<code>waitpid</code>回收并且查看进程的<strong>退出码</strong>，判断子进程的死因</li>
<li>只有父进程使用wait等待的时候他的task struct才会消失</li>
<li>这个进程无法使用系统的signal杀死</li>
</ul>
<h2 id="Linux进程状态"><a href="#Linux进程状态" class="headerlink" title="Linux进程状态"></a>Linux进程状态</h2><ul>
<li><img src="/imgs/8234473b9b901abca50f411cfe93f07e7bb03b02e925e19096cfe46f38cd29fb.png" alt="picture 4">  </li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>就绪</td>
<td>等待上CPU（因为时间片结束或者被抢占等）</td>
</tr>
<tr>
<td>运行</td>
<td>执行</td>
</tr>
<tr>
<td>睡眠</td>
<td>等资源（等到了就绪）</td>
</tr>
<tr>
<td>僵尸</td>
<td>执行完但是还没有回收</td>
</tr>
<tr>
<td>停止</td>
<td>STOP或者收到了Ctrl+Z等信号，还可以继续恢复（输入fg，bg等）</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/22/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E6%B3%95%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E6%B3%95%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">回溯和递归法题目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 00:39:27" itemprop="dateCreated datePublished" datetime="2024-01-22T00:39:27+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-12 12:10:39" itemprop="dateModified" datetime="2024-06-12T12:10:39+08:00">2024-06-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LeetCode-332-重新安排行程"><a href="#LeetCode-332-重新安排行程" class="headerlink" title="LeetCode 332. 重新安排行程"></a>LeetCode 332. 重新安排行程</h2><ul>
<li>此题的大部分是按照回溯法标准套路进行<ul>
<li>也就是</li>
<li>遍历尝试DFS</li>
<li>满足条件的修改环境</li>
<li>递归</li>
<li>出现结果的话直接返回</li>
<li>没出现的话将环境复原</li>
<li>继续尝试下一种</li>
</ul>
</li>
<li>但是注意需要一个<strong>排序</strong>（因为返回字典序最小的结果）快速的从一个<code>string</code>出发到一个<code>string</code>截止并且能处理重复情况的方式<ul>
<li>使用了<code>unordered_map&lt;string, map&lt;string, int&gt;&gt;</code></li>
<li>外层map将起点映射到终点</li>
<li>内层map将终点映射到出现过的次数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// unordered_set&lt;int&gt; used;</span></span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    unordered_map&lt;string, map&lt;string, <span class="keyword">int</span>&gt;&gt; to;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:tickets)</span><br><span class="line">        &#123;</span><br><span class="line">            ++to[i[<span class="number">0</span>]][i[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="comment">// ans.resize(tickets.size());</span></span><br><span class="line">        <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets, vector&lt;string&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;tickets.size()&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = tickets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!ans.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : to[<span class="string">&quot;JFK&quot;</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i.second&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --i.second;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i.first);</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">                    <span class="keyword">if</span>(flag)<span class="keyword">return</span>;</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ++i.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == cnt+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : to[ans[ans.<span class="built_in">size</span>()<span class="number">-1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i.second--;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i.first);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i.first&lt;&lt;endl;</span></span><br><span class="line">                <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">                <span class="keyword">if</span>(flag)<span class="keyword">return</span>;</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                i.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-47-全排列II"><a href="#Leetcode-47-全排列II" class="headerlink" title="Leetcode 47. 全排列II"></a>Leetcode 47. 全排列II</h2><ul>
<li>关键是去重</li>
<li>还要强调的是去重一定要对元素进行<strong>排序</strong>，这样我们才方便通过相邻的节点来判断是否重复使用了<ul>
<li>有两种去重的方式，其中一种是当目前循环的时候如果i大于起始位置而且数组中第i个的值等于第i-1个的话，则跳过i（这种去重的方式允许不同层级的回溯具有相同的元素值，因为允许在当前迭代的第一个元素的位置进入下一层）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">参考力扣子集II</a></li>
<li>另一种方式是使用<code>used</code>数组来记录，跳过所有与上一个元素相同而且目前没有被使用的元素，也就是在这一层出现的重复元素。</li>
<li><img src="/imgs/e603911ea5befcd9846a5d3ab96f008fd5e373ac9bf6c7720c932888e2a59505.png" alt="picture 0">  </li>
<li>如果这个位置和上个位置相同，而且上个位置的数字在另外的分支里被使用过（也就是<code>used[i-1] == false</code>），那么跳过这个数字来去重</li>
<li>在这个位置中被使用过的数字的<code>used</code>是<code>true</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; path;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; seq, vector&lt;<span class="keyword">bool</span>&gt;&amp; used, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        seq.<span class="built_in">push_back</span>(nums[start]);</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (seq.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(seq);</span><br><span class="line">            seq.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">backtracking</span>(nums, seq, used, i);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        seq.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, seq, used, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-90-子集-II"><a href="#Leetcode-90-子集-II" class="headerlink" title="Leetcode 90. 子集 II"></a>Leetcode 90. 子集 II</h2><ul>
<li>此题不讲究顺序，所以可以使用先排序再相邻去重的方式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="comment">// vector&lt;bool&gt; used;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; ans, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums[start]);</span><br><span class="line">        </span><br><span class="line">        ret.<span class="built_in">push_back</span>(ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start+<span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[start] = true;</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, ans, i);</span><br><span class="line">            <span class="comment">// used[start] = false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        ret.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="comment">// used = vector&lt;bool&gt;(nums.size(), false);</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[i] = true;</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, tmp, i);</span><br><span class="line">            <span class="comment">// used[i] = false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-491-非递减子序列"><a href="#Leetcode-491-非递减子序列" class="headerlink" title="Leetcode 491. 非递减子序列"></a>Leetcode 491. 非递减子序列</h2><ul>
<li>注意此题不能手动重新排序数组</li>
<li>因此需要防止<strong>同一层中出现重复的</strong>，使用set</li>
<li>每个递归函数自己定义自己的set，只考虑自己这一层是否出现过重复的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used.<span class="built_in">count</span>(nums[i]))<span class="keyword">continue</span>;</span><br><span class="line">            used.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">            <span class="built_in">recur</span>(nums, seq, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; seq, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(seq.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(seq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        seq.<span class="built_in">push_back</span>(nums[start]);</span><br><span class="line">        <span class="keyword">if</span>(seq.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">            ret.<span class="built_in">push_back</span>(seq);</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used.<span class="built_in">count</span>(nums[i]) || nums[i]&lt;seq.<span class="built_in">back</span>())<span class="keyword">continue</span>;</span><br><span class="line">            used.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="built_in">recur</span>(nums, seq, i);</span><br><span class="line">            <span class="comment">// used.erase(i);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        seq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-40-组合总和-II"><a href="#Leetcode-40-组合总和-II" class="headerlink" title="Leetcode 40. 组合总和 II"></a>Leetcode 40. 组合总和 II</h2><ul>
<li>注意此题的去重方法，是放在<strong>循环中</strong></li>
<li>如果上一个元素与这个元素相等而且上一个元素与这个元素没出现在同一个数组之中</li>
<li>则说明在之前的某个位置，上一个元素<strong>必定在这个位置已经出现过了</strong><ul>
<li>因为没出现过，意味着上一个元素与当前的这个元素在不同的尝试中被遍历过一次了，再来一次必然会重复<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="comment">// vector&lt;bool&gt; used;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">// used = vector&lt;bool&gt;(candidates.size(), false);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;candidates.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; candidates[i<span class="number">-1</span>] == candidates[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[i] = true;</span></span><br><span class="line">            <span class="built_in">traversal</span>(candidates, target, i, ans);</span><br><span class="line">            <span class="comment">// used[i] = false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; c, <span class="keyword">int</span> target, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(c[start]);</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= c[start])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == c[start])</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(ans);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i&lt;c.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start+<span class="number">1</span> &amp;&amp; c[i] == c[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">traversal</span>(c, target-c[start], i, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-93-复原IP地址"><a href="#Leetcode-93-复原IP地址" class="headerlink" title="Leetcode 93. 复原IP地址"></a>Leetcode 93. 复原IP地址</h2></li>
</ul>
</li>
<li>注意此题的去重方式，主要是决定在哪个位置结束</li>
<li>注意，必须是前面<strong>明确声明要结束了</strong>的地址才可以作为答案之一</li>
<li><strong>否则会重复</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="comment">// ans+=s[0];</span></span><br><span class="line">        <span class="built_in">traversal</span>(s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(string&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> cnt, <span class="keyword">int</span> remain, string ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==s.<span class="built_in">size</span>()&amp;&amp;cnt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(ans.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == s.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span> || cnt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">            ans+=s[start];</span><br><span class="line">            <span class="keyword">if</span>(s[start] ==<span class="string">&#x27;0&#x27;</span>)  </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 结束本节</span></span><br><span class="line">                <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, <span class="number">3</span>, remain<span class="number">-1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 结束本节，1个数字</span></span><br><span class="line">                <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, <span class="number">3</span>, remain<span class="number">-1</span>, ans);</span><br><span class="line">                <span class="comment">// 继续本节，最少有2个数字</span></span><br><span class="line">                <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, <span class="number">1</span>, remain<span class="number">-1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span> || cnt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=s[start];</span><br><span class="line">            <span class="comment">// 如果超出限制 则提前结束</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stoi</span>(ans.<span class="built_in">substr</span>(ans.<span class="built_in">size</span>()-cnt<span class="number">-1</span>))&gt;<span class="number">255</span>)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 在只有2个数字的时候结束本节</span></span><br><span class="line">                <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, <span class="number">3</span>, remain, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续本节cnt = 2(本节有3个数字)或者cnt = 3</span></span><br><span class="line">            <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, cnt+<span class="number">1</span>, remain, ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FrankZhang"
      src="/images/avatar1.jpg">
  <p class="site-author-name" itemprop="name">FrankZhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">183</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FrankZhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">646k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">19:34</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
