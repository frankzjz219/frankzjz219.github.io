<!DOCTYPE html>


<html lang="Chinese">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Frank’s blogs</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/FLogo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/bkgPic.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Frank’s blogs</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['Linux开发和工科生折腾集锦', '算法题总结', 'C/C++/python等开发'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">Linux编程、C/C++开发、算法题、各种工科生折腾开发集锦</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Leetcode数组题目"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/06/Leetcode%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE/"
    >Leetcode数组题目</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/06/Leetcode%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE/" class="article-date">
  <time datetime="2023-12-06T07:12:07.000Z" itemprop="datePublished">2023-12-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="LeetCode-153-寻找旋转排序数组中的最小值"><a href="#LeetCode-153-寻找旋转排序数组中的最小值" class="headerlink" title="LeetCode 153. 寻找旋转排序数组中的最小值"></a>LeetCode 153. 寻找旋转排序数组中的最小值</h2><ul>
<li>我们考虑数组中的最后一个元素<code>x</code>：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于<code>x</code>；而在最小值左侧的元素，它们的值一定都严格大于<code>x</code>。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-4-寻找两个正序数组的中位数"><a href="#Leetcode-4-寻找两个正序数组的中位数" class="headerlink" title="Leetcode 4. 寻找两个正序数组的中位数"></a>Leetcode 4. 寻找两个正序数组的中位数</h2></li>
<li>此题较为复杂，建议查看<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/?envType=study-plan-v2&envId=top-100-liked">题解</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="keyword">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="keyword">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-136-只出现一次的数字"><a href="#Leetcode-136-只出现一次的数字" class="headerlink" title="Leetcode 136. 只出现一次的数字"></a>Leetcode 136. 只出现一次的数字</h2><ul>
<li>对整个数组元素挨个求异或，最后剩下的一个就是只出现一次的那个</li>
<li>因为出现过两次的会因为自己异或自己而变为0<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LeetCode-31-下一个排列"><a href="#LeetCode-31-下一个排列" class="headerlink" title="LeetCode 31. 下一个排列"></a>LeetCode 31. 下一个排列</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/">参考</a></li>
<li>从后向前 查找第一个 相邻升序 的元素对 <code>(i,j)</code>，满足 <code>A[i] &lt; A[j]</code>。此时 <code>[j,end)</code> 必然是降序</li>
<li>在 <code>[j,end)</code> 从后向前 查找第一个满足 <code>A[i] &lt; A[k]</code> 的 <code>k</code>。<code>A[i]</code>、<code>A[k]</code> 分别就是上文所说的「小数」、「大数」</li>
<li>将 <code>A[i]</code> 与 <code>A[k]</code> 交换</li>
<li>可以断定这时 <code>[j,end)</code> 必然是降序，逆置 <code>[j,end)</code>，使其升序</li>
<li>如果在步骤 1 找不到符合的相邻元素对，说明当前 <code>[begin,end)</code> 为一个降序顺序，则直接跳到步骤 4</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=nums.<span class="built_in">size</span>(),i=l<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=l<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//找出nums[i]后面大于nums[i]的最小数的下标</span></span><br><span class="line">            <span class="keyword">while</span>(nums[j]&lt;=nums[i])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>());<span class="comment">//交换完后对nums[i]后面的数字进行从小到大排列</span></span><br><span class="line">            <span class="comment">//因为此时nums.begin()+i+1到nums.end()一定是降序排列,所以只需reverse就是从小到大排列了</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//说明是最大排列,下一个应该是最小排列</span></span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode-452-用最少数量的箭引爆气球"><a href="#Leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="Leetcode 452. 用最少数量的箭引爆气球"></a>Leetcode 452. 用最少数量的箭引爆气球</h2><ul>
<li>按照区间的<strong>右端点排序</strong>，取右端点的值，直到目前的区间的右端点的值小于下一个区间的左端点的值的时候就说明没有重叠部分了，需要增加新的区间<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; u, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> pos = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; balloon: points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (balloon[<span class="number">0</span>] &gt; pos) &#123;</span><br><span class="line">                pos = balloon[<span class="number">1</span>];</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Leetcode图相关遍历"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/05/Leetcode%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%81%8D%E5%8E%86/"
    >Leetcode图相关遍历</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/05/Leetcode%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%81%8D%E5%8E%86/" class="article-date">
  <time datetime="2023-12-05T08:25:50.000Z" itemprop="datePublished">2023-12-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="图的拓扑排序"><a href="#图的拓扑排序" class="headerlink" title="图的拓扑排序"></a>图的拓扑排序</h2><h3 id="广度优先搜索（Leetcode-207-课程表）"><a href="#广度优先搜索（Leetcode-207-课程表）" class="headerlink" title="广度优先搜索（Leetcode 207.课程表）"></a>广度优先搜索（Leetcode 207.课程表）</h3><ul>
<li>用一个数组记录每个节点的进入边的数量</li>
<li>开始的时候将所有入度为0的点加入队列</li>
<li>依次从队列中弹出点，将从这个点出发指向的所有点的入度-1，然后将跟这个点相关的路径全部删除<ul>
<li>假如此时遇到点的入度是0的话，将这个点加入队列</li>
</ul>
</li>
<li>将队列中弹出的点加入输出序列中</li>
<li>假如最后图上的<strong>所有点都在输出序列中</strong>，说明无环，否则有环<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vMap</span>(numCourses);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inCnt</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prerequisites.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vMap[prerequisites[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            ++inCnt[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inCnt[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:vMap[temp])</span><br><span class="line">            &#123;</span><br><span class="line">                --inCnt[i];</span><br><span class="line">                <span class="keyword">if</span>(inCnt[i] == <span class="number">0</span>)q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            vMap[temp] = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&lt;numCourses)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul>
<li>遍历所有节点，先标记自己被遍历过了</li>
<li>每个节点递归的遍历<strong>自己所有边</strong>指向的没有被打上遍历过的标签的节点</li>
<li>回溯的时候（也就是之后的节点都遍历结束之后）将自己添加到拓扑顺序的栈中</li>
<li>依次弹出栈中元素，得到顺序<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vertices;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span>(<span class="keyword">int</span> V) : <span class="built_in">vertices</span>(V), <span class="built_in">adjList</span>(V) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjList[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topologicalSortUtil</span><span class="params">(<span class="keyword">int</span> v, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited, stack&lt;<span class="keyword">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : adjList[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                <span class="built_in">topologicalSortUtil</span>(neighbor, visited, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(vertices, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">topologicalSortUtil</span>(i, visited, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Topological Sort: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!result.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; result.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            result.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">topologicalSort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-127-单词接龙"><a href="#Leetcode-127-单词接龙" class="headerlink" title="Leetcode 127. 单词接龙"></a>Leetcode 127. 单词接龙</h2><ul>
<li>此题是讲字母相邻的单词组织成一张图</li>
<li>实际上是求图上两个点的最近距离</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/solutions/473600/dan-ci-jie-long-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150">题解</a></li>
<li>广度优先搜索法<ul>
<li>每循环一次，找一个没有接触过的位置，将其距离更新为接触过的位置+1，然后也放入队列遍历</li>
<li>注意，只考虑之前没有加入过的点，防止环的影响<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; wordId;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; edge;</span><br><span class="line">    <span class="keyword">int</span> nodeNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordId.<span class="built_in">count</span>(word)) &#123;</span><br><span class="line">            wordId[word] = nodeNum++;</span><br><span class="line">            edge.<span class="built_in">emplace_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addWord</span>(word);</span><br><span class="line">        <span class="keyword">int</span> id1 = wordId[word];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; it : word) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = it;</span><br><span class="line">            it = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="built_in">addWord</span>(word);</span><br><span class="line">            <span class="keyword">int</span> id2 = wordId[word];</span><br><span class="line">            edge[id1].<span class="built_in">push_back</span>(id2);</span><br><span class="line">            edge[id2].<span class="built_in">push_back</span>(id1);</span><br><span class="line">            it = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; word : wordList) &#123;</span><br><span class="line">            <span class="built_in">addEdge</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addEdge</span>(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (!wordId.<span class="built_in">count</span>(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(nodeNum, INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> beginId = wordId[beginWord], endId = wordId[endWord];</span><br><span class="line">        dis[beginId] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(beginId);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (x == endId) &#123;</span><br><span class="line">                <span class="keyword">return</span> dis[endId] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; it : edge[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[it] == INT_MAX) &#123;</span><br><span class="line">                    dis[it] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-C和Cpp语言语法注意事项小结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/04/C%E5%92%8CCpp%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%B0%8F%E7%BB%93/"
    >C和Cpp语言语法注意事项小结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/04/C%E5%92%8CCpp%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%B0%8F%E7%BB%93/" class="article-date">
  <time datetime="2023-12-04T09:59:56.000Z" itemprop="datePublished">2023-12-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="STL相关"><a href="#STL相关" class="headerlink" title="STL相关"></a>STL相关</h2><ul>
<li>注意<code>vector&lt;&gt;.size()</code>返回的是无符号整数，<code>unsigned</code>与<strong>同样大小类型的有符号整数相加的时候会将这个有符号整数类型转换为无符号的，导致表示的意思出现区别</strong></li>
</ul>
<h3 id="initializer-list-lt-gt"><a href="#initializer-list-lt-gt" class="headerlink" title="initializer_list&lt;&gt;"></a>initializer_list&lt;&gt;</h3><ul>
<li><p>用于不定参数个数的函数的传参</p>
</li>
<li><p>只能传递同一个类型的参数</p>
</li>
<li><p>复制的时候是浅拷贝</p>
<h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p>函数|功能<br>|—|—|<br>find(begin, end, val)|在begin和end（不包括）之间找val，找不到返回end，找到返回位置迭代器，是<strong>线性查找</strong><br>stable_sort(begin, end, compare)|是稳定排序算法，会保证相等元素的顺序</p>
</li>
<li><p>其他</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::sort</code></td>
<td>对给定范围的元素进行排序。</td>
</tr>
<tr>
<td><code>std::reverse</code></td>
<td>反转给定范围的元素。</td>
</tr>
<tr>
<td><code>std::rotate</code></td>
<td>将给定范围的元素循环右移指定位置。</td>
</tr>
<tr>
<td><code>std::find</code></td>
<td>在给定范围内查找指定值，返回第一个匹配元素的迭代器。</td>
</tr>
<tr>
<td><code>std::binary_search</code></td>
<td>在有序范围内执行二分查找，返回是否找到指定值的布尔值。</td>
</tr>
<tr>
<td><code>std::count</code></td>
<td>计算给定范围内等于指定值的元素个数。</td>
</tr>
<tr>
<td><code>std::accumulate</code></td>
<td>对给定范围内的元素进行累积（求和）操作。</td>
</tr>
<tr>
<td><code>std::max_element</code></td>
<td>返回给定范围内的最大元素的迭代器。</td>
</tr>
<tr>
<td><code>std::min_element</code></td>
<td>返回给定范围内的最小元素的迭代器。</td>
</tr>
<tr>
<td><code>std::copy</code></td>
<td>将一个范围的元素复制到另一个范围。</td>
</tr>
<tr>
<td><code>std::fill</code></td>
<td>将给定范围的元素都设置为指定的值。</td>
</tr>
<tr>
<td><code>std::unique</code></td>
<td>移除给定范围内的重复元素，返回指向新范围结尾的迭代器。</td>
</tr>
<tr>
<td><code>std::next_permutation</code></td>
<td>将给定范围的元素重新排列为下一个字典序排列。</td>
</tr>
<tr>
<td><code>std::prev_permutation</code></td>
<td>将给定范围的元素重新排列为前一个字典序排列。</td>
</tr>
<tr>
<td><code>std::shuffle</code></td>
<td>将给定范围内的元素随机重排。</td>
</tr>
<tr>
<td><code>std::transform</code></td>
<td>对给定范围内的元素执行指定操作，结果存储在另一个范围。</td>
</tr>
<tr>
<td><code>std::merge</code></td>
<td>将两个有序范围合并成一个有序范围。</td>
</tr>
<tr>
<td><code>std::partition</code></td>
<td>根据指定条件对给定范围进行分区，将满足条件的元素放在前面。</td>
</tr>
<tr>
<td><code>std::nth_element</code></td>
<td>对给定范围的元素进行局部排序，使得第n个元素是排好序的。</td>
</tr>
</tbody></table>
<h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><ul>
<li>用于包装函数改变其参数列表<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span> (callable, arg_list);</span><br></pre></td></tr></table></figure></li>
<li>将可调用对象和参数绑定成一个新的可调用对象，可以延迟调用或者传递给其他函数使用。</li>
<li>将多元（参数个数大于1）的可调用对象转换成一元或者少元的可调用对象，即只绑定部分参数，剩下的参数在调用时传入。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将print函数和一个参数绑定成一个新的可调用对象，另一个参数用占位符表示</span></span><br><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(print, placeholders::_1, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">f2</span>(<span class="number">1</span>); <span class="comment">// 输出 1 2</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">3</span>); <span class="comment">// 输出 3 2</span></span><br></pre></td></tr></table></figure></li>
<li>注意bind后的函数传参是按照placeholder<strong>从小到大</strong>传参的，<strong>可以人为颠倒顺序</strong></li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li>将拷贝的参数转换为引用</li>
<li><code>ref(val)</code><h3 id="hash哈希函数"><a href="#hash哈希函数" class="headerlink" title="hash哈希函数"></a>hash哈希函数</h3></li>
<li><code>hash&lt;key_type&gt;()</code>函数为内置类型，指针，string和智能指针提供了哈希函数</li>
</ul>
<h3 id="智能指针shared-ptr和unique-ptr"><a href="#智能指针shared-ptr和unique-ptr" class="headerlink" title="智能指针shared_ptr和unique_ptr"></a>智能指针<code>shared_ptr</code>和<code>unique_ptr</code></h3><ul>
<li><code>shared_ptr</code>允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>独占所指向的对象<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4></li>
<li>对指针可以直接做条件判断，<code>true</code>就是非空，否则是空</li>
<li>最好<strong>不要</strong>用将<u>自己申请的动态内存转化为智能指针</u>的方式创建智能指针，可能会泄露</li>
<li><code>p.get()</code>返回指针指向的对象<ul>
<li>注意，如果智能指针被释放，那么使用get返回的指针指向的对象也会被释放</li>
</ul>
</li>
<li><code>shared_ptr</code>比较是否相等时候，比较的是<strong>指向的对象是否相等</strong>，因此可以用来在STL中find()等等</li>
<li><code>shared_ptr</code>基本用法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 shared_ptr，并分配一个整数</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; sharedInt = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 shared_ptr</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *sharedInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; sharedInt.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建另一个 shared_ptr，共享相同的整数</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; anotherSharedInt = sharedInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数增加</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; sharedInt.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>另一种初始化</li>
<li><code>shared_ptr&lt;int&gt; p(new int(1024));</code>可以用动态对象初始化指针</li>
<li>但是必须显式的调用，不能隐式类型转换</li>
<li>不要使用<code>shared_ptr</code>的<code>get</code>方法为另一个智能指针赋值，会导致内存管理混乱</li>
<li><code>unique_ptr</code>基本用法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 unique_ptr，并分配一个整数</span></span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; uniqueInt = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 unique_ptr</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *uniqueInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr 不能被拷贝，这会导致编译错误</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; anotherUniqueInt = uniqueInt; // 错误！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以用<code>release</code>或者<code>reset</code>转移指针的所有权<ul>
<li>reset会<strong>释放本身指向的内存</strong>，将目标转移到函数传入的新地址上</li>
<li>release会返回自己指向的内存地址，同时放弃对这个位置的控制权（不会释放内存）</li>
</ul>
</li>
<li><code>unique_ptr</code>只有在即将被销毁（比如函数返回）或者是临时对象的时候可以被拷贝，接手自己的内存区域<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3></li>
<li>可以绑定到<code>shared_ptr</code>但是不影响引用计数</li>
<li><code>lock</code>方法用于获取对应的shared_ptr，<strong>不存在则是空的指针对象</strong></li>
<li><code>expired</code>可以看当前是不是还有shared_ptr在指向空间<h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3></li>
<li>与vector类似，但是其中数据在拷贝的时候是公用的，不是像vector是复制的</li>
<li>管理机制与共享指针类似，最后一个被释放之后存储的数据才会删除</li>
</ul>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><ul>
<li>多种不同类型的组合</li>
<li>注意<code>make_tuple</code>可以不显式的声明类型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function">std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">float</span>, std::string&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(myTuple) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Second element: &quot;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(myTuple) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Third element: &quot;</span> &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(myTuple) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 解包为多个变量</span></span><br><span class="line"><span class="keyword">int</span> intValue;</span><br><span class="line"><span class="keyword">double</span> doubleValue;</span><br><span class="line">std::string stringValue;</span><br><span class="line">std::<span class="built_in">tie</span>(intValue, doubleValue, stringValue) = myTuple;</span><br><span class="line"><span class="comment">// 使用 std::tuple_size 获取 tuple 大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Tuple size: &quot;</span> &lt;&lt; std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><ul>
<li>用于位运算的类<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个有 8 位的 bitset，初始值为 0</span></span><br><span class="line">std::bitset&lt;8&gt; myBitset1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用整数值初始化 bitset</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">myBitset2</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 使用二进制表示为 00101010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用字符串初始化 bitset</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">myBitset3</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 访问位</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Bit at position 3: &quot;</span> &lt;&lt; myBitset[<span class="number">3</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改位</span></span><br><span class="line">myBitset.<span class="built_in">set</span>(<span class="number">1</span>, <span class="literal">true</span>);  <span class="comment">// 将第 1 位设置为 1</span></span><br><span class="line"><span class="comment">// set不给参数的话会默认为1</span></span><br><span class="line"><span class="comment">// reset会把指定的位设置为0</span></span><br><span class="line">myBitset.<span class="built_in">flip</span>(<span class="number">4</span>);       <span class="comment">// 反转第 4 位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位与</span></span><br><span class="line">std::bitset&lt;8&gt; resultAnd = bitset1 &amp; bitset2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位或</span></span><br><span class="line">std::bitset&lt;8&gt; resultOr = bitset1 | bitset2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位异或</span></span><br><span class="line">std::bitset&lt;8&gt; resultXor = bitset1 ^ bitset2;</span><br><span class="line"><span class="comment">// 获取 bitset 的大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of myBitset: &quot;</span> &lt;&lt; myBitset.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否所有位都是 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;All zeros? &quot;</span> &lt;&lt; myBitset.<span class="built_in">none</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有任意位是 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Any ones? &quot;</span> &lt;&lt; myBitset.<span class="built_in">any</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否所有位都是 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;All ones? &quot;</span> &lt;&lt; myBitset.<span class="built_in">all</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (parameters) -&gt; &lt;<span class="keyword">return</span> type&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回类型可以省略</li>
<li>捕获的作用是比如函数作为谓词的时候，<strong>只能</strong>传递两个互相比较的参数，此时<strong>需要外部的参数</strong>就只能用捕获传入。<ul>
<li>全局变量不需要捕获也能使用</li>
<li>可以捕获引用<code>[&amp;var]</code>即可</li>
<li>支持隐式捕获，也就是编译器自己推断捕获什么不捕获什么</li>
<li><code>[=, other vals]</code>等号表示值捕获方式，可以与显式捕获混合使用</li>
<li><code>[&amp;, other vals]</code>引用符号表示引用捕获方式</li>
<li>不同种类的捕获可以互相混用</li>
<li>通过值捕获的变量一般不允许修改，除非在函数体之前加一个<code>mutable</code>关键字</li>
</ul>
</li>
<li>lambda是函数类型，不是函数指针</li>
</ul>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li>包装器</li>
<li>可以将任何可以调用的对象存入，能使用<code>()</code>的就可以，包装为一个函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Multiply</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::function 包装普通函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; addFunction = Add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add Function Result: &quot;</span> &lt;&lt; <span class="built_in">addFunction</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::function 包装函数对象</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; multiplyFunction = <span class="built_in">Multiply</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply Function Result: &quot;</span> &lt;&lt; <span class="built_in">multiplyFunction</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; lambdaFunction = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lambda Function Result: &quot;</span> &lt;&lt; <span class="built_in">lambdaFunction</span>(<span class="number">8</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><ul>
<li>倒序排序<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>()); <span class="comment">// 倒序</span></span><br></pre></td></tr></table></figure>
<h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3></li>
<li>连续输入使用</li>
<li>不初始化的话就是尾后迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;</span><br><span class="line"><span class="comment">// 创建一个表示istream尾后位置的istream_iterator</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof; </span><br><span class="line"><span class="comment">// 创建一个int类型的vector，并用in_iter和eof初始化</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入一个元素并且赋值</span></span><br><span class="line">in_iter++;</span><br><span class="line"><span class="keyword">int</span> y = *in_iter;</span><br></pre></td></tr></table></figure></li>
<li>输出流迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个输出流迭代器，绑定到cout，数据类型为int，分隔符为&quot;,&quot;</span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_it</span><span class="params">(cout, <span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 向输出流迭代器写入一个数据</span></span><br><span class="line">*out_it = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个vector容器，存储一些int数据</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用copy算法，将vector中的数据复制到输出流迭代器中</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_it);</span><br></pre></td></tr></table></figure></li>
<li>向输出流迭代器<strong>写入数据</strong>就是输出</li>
<li>初始化的时候加的是每个数据之后的分隔符</li>
<li><code>*</code>, <code>++</code>等运算符对他没什么意义<h2 id="语法相关"><a href="#语法相关" class="headerlink" title="语法相关"></a>语法相关</h2></li>
<li>使用三目运算符<code>?:</code>的时候最好外加括号，否则会因为计算顺序的原因报错<h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3></li>
<li><code>new</code>和<code>delete</code>是运算符一个分配动态对象一个删除动态对象</li>
</ul>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><ul>
<li>作用是对一个区间内的变量每个都执行指定的操作（函数）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，用于在 for_each 中作为操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSquare</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x * x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个向量</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 for_each 遍历向量并应用操作</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), PrintSquare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：1 4 9 16 25</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>不要返回局部对象的引用类型，否则会因为局部对象生命周期结束而失效</li>
<li>返回指向某个数组的指针的函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> i))[<span class="number">10</span>];<span class="comment">// 看的时候从里往外看，先返回的是指针，指针指向的是int[10]</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="function">arr* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span></span><br></pre></td></tr></table></figure></li>
<li>也可以直接在返回值的位置使用decltype标出类型</li>
</ul>
<h3 id="Cpp函数重载"><a href="#Cpp函数重载" class="headerlink" title="Cpp函数重载"></a>Cpp函数重载</h3><ul>
<li>函数重载只有在同一个级别的作用域才行<ul>
<li>假如在某个函数内部声明了一个与外部函数同名的函数，会导致外部同名函数被屏蔽</li>
</ul>
</li>
<li>假如有一组参数传入导致系统无法区分具体调用哪个的话会导致编译出错</li>
<li>类型转换的分类</li>
</ul>
<table>
<thead>
<tr>
<th>等级</th>
<th>转换</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>精确匹配</td>
</tr>
<tr>
<td>2</td>
<td>const转换实现匹配</td>
</tr>
<tr>
<td>3</td>
<td>类型提升实现匹配</td>
</tr>
<tr>
<td>4</td>
<td>算数类型转换实现匹配</td>
</tr>
<tr>
<td>5</td>
<td>类类型转换实现匹配</td>
</tr>
</tbody></table>
<h3 id="Cpp函数内联"><a href="#Cpp函数内联" class="headerlink" title="Cpp函数内联"></a>Cpp函数内联</h3><ul>
<li>编译器可以选择忽略内联函数请求，也可以自动优化内联函数</li>
</ul>
<h3 id="是否是开发状态"><a href="#是否是开发状态" class="headerlink" title="是否是开发状态"></a>是否是开发状态</h3><ul>
<li>定义<code>NDEBUG</code></li>
<li>如果定义了就不能使用assert等debug用的工具</li>
<li>也可以自己用<code>#ifndef NDEBUG</code>来控制自己写的代码哪些用在调试阶段<h3 id="调试输出"><a href="#调试输出" class="headerlink" title="调试输出"></a>调试输出</h3></li>
<li>可以用<code>__func__</code>打印<strong>当前函数的名字</strong></li>
<li><code>__FILE__</code>文件名</li>
<li><code>__LINE__</code>行号</li>
<li><code>__TIME__</code>编译时间</li>
<li><code>__DATE__</code>编译日期<h4 id="backtrace和backtrace-symbols函数"><a href="#backtrace和backtrace-symbols函数" class="headerlink" title="backtrace和backtrace_symbols函数"></a><code>backtrace</code>和<code>backtrace_symbols</code>函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span> **buffer, <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><code>backtrace</code>函数是一个用于获取调用栈信息的函数，通常在调试或错误处理中使用。它在标准的C库中，头文件是<code>#include &lt;execinfo.h&gt;</code></li>
<li>使用<code>backtrace_symbols</code>函数将<code>backtrace</code>信息转换成字符串</li>
<li><code>char **bt_strings = backtrace_symbols(bt_buffer, bt_size);</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_frames = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">void</span> *addrlist[max_frames + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> addrlen = <span class="built_in">backtrace</span>(addrlist, <span class="built_in"><span class="keyword">sizeof</span></span>(addrlist) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addrlen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;No stack trace available.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> **symbolList = <span class="built_in">backtrace_symbols</span>(addrlist, addrlen);</span><br><span class="line">    <span class="keyword">if</span> (symbolList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;backtrace_symbols&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack trace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addrlen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, symbolList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(symbolList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printStackTrace</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>backtrace函数在编译时需要开启调试信息。如果使用gcc编译，可以添加<code>-g</code></li>
<li>传入的需要是一个<strong>指针数组</strong>或者是使用<code>addrlist = (void **)malloc((sizeof(void *) * addrlen));</code>分配好内存的空间<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3></li>
<li>给函数指针赋值的时候加不加取地址符号都一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">return</span> type&gt; (*func name)(&lt;para&gt; parameters);</span><br></pre></td></tr></table></figure></li>
<li><strong>不同种类的函数指针之间无法转换，即使形参列表能转换</strong>，也就是说必须是<em>返回类型</em>和<em>形参列表</em>与自身完全一样的函数才可以赋值给函数指针</li>
<li>但是<strong>调用</strong>的时候可以发生类型转换</li>
<li>返回的时候不能返回函数，因为函数不能拷贝，只能返回函数指针<h4 id="如何返回函数指针"><a href="#如何返回函数指针" class="headerlink" title="如何返回函数指针"></a>如何返回函数指针</h4></li>
<li><code>int (*f1(int))(int, int);</code>返回的是一个<code>int(*)(int, int)</code>类型的函数指针</li>
<li>或者写<code>auto f(int) -&gt; int(*)(int, int)</code></li>
</ul>
<h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><ul>
<li><code>int*a = new int[10];</code>是未初始化的</li>
<li><code>int*a = new int[10]();</code>是已经值初始化为0的</li>
<li><code>int* a = new int[3]&#123;0, 1, 2&#125;;</code>是显式初始化列表的</li>
<li>创建长度为0的动态数组可以，但<strong>不能解引用</strong></li>
<li>释放的时候必须用<code>delete [] ptr</code></li>
</ul>
<h3 id="allocator类申请内存"><a href="#allocator类申请内存" class="headerlink" title="allocator类申请内存"></a>allocator类申请内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::allocator 分配一块内存来存储 int 类型的元素</span></span><br><span class="line">    std::allocator&lt;<span class="keyword">int</span>&gt; allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存以存储一个 int</span></span><br><span class="line">    <span class="keyword">int</span>* ptr = allocator.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在分配的内存上构造 int 对象</span></span><br><span class="line">    allocator.<span class="built_in">construct</span>(ptr, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁对象并释放内存</span></span><br><span class="line">    allocator.<span class="built_in">destroy</span>(ptr);</span><br><span class="line">    allocator.<span class="built_in">deallocate</span>(ptr, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>alloccate</code>仅仅是分配内存</li>
<li><code>construct</code>才构造对象</li>
<li>删除的时候先<code>destroy</code></li>
<li>然后再解除内存占用<code>deallocate</code></li>
<li>使用<code>allocator</code>构造内存的时候可以像使用指针一样对指针做加减，只要不超出构造的范围即可<h4 id="一次初始化多个元素"><a href="#一次初始化多个元素" class="headerlink" title="一次初始化多个元素"></a>一次初始化多个元素</h4></li>
<li>`std::uninitialized_fill(intPtr, intPtr + 3, 1);<ul>
<li>注意，<code>uninitialized_fill</code>的第二个参数类似于尾后迭代器，不会真的被赋值</li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><ul>
<li><p>常量成员函数<code>&lt;return type&gt; func() const &#123;&#125;</code></p>
<ul>
<li>不修改类对象的函数</li>
<li>对这个类的const实例的时候会调用const的成员函数</li>
<li>但是假如某个成员有<code>mutable</code>关键字，那么也可以修改<h3 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h3></li>
</ul>
</li>
<li><p><code>public</code>和<code>private</code>可以反复出现多次</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3></li>
<li><p>类内声明</p>
</li>
<li><p><code>friend &lt;return type&gt; func();</code></p>
</li>
<li><p>即使这个类被内嵌在一个子类中，也可以访问相应部分的成员</p>
<h3 id="不同类别的继承"><a href="#不同类别的继承" class="headerlink" title="不同类别的继承"></a>不同类别的继承</h3></li>
<li><p>private继承会把所有从基类继承的成员都作为private对象</p>
</li>
<li><p>protected会把所有的作为protected</p>
</li>
<li><p>public则不改变权限</p>
</li>
<li><p>可以手动在public、protected或者private后面使用<code>using 基类名:: 基类成员</code>手动变更访问权限</p>
</li>
<li><p>继承的时候子类的同名成员会覆盖基类的，无论是变量还是成员函数</p>
<h3 id="作用域运算符"><a href="#作用域运算符" class="headerlink" title="作用域运算符::"></a>作用域运算符<code>::</code></h3></li>
<li><p>访问全局作用域中的变量直接用<code>::&lt;variable&gt;</code>即可</p>
</li>
<li><p>访问类的就用<code>&lt;class name&gt;::&lt;var&gt;</code></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3></li>
<li><p>子类在构造的时候必须在初始化列表中显式的调用基类的构造函数构造基类的部分</p>
</li>
<li><p>派生类构造函数只能通过初始化列表或构造函数的成员初始化列表来调用基类构造函数，而在函数体中是无法再次调用的</p>
<h3 id="类成员初始化"><a href="#类成员初始化" class="headerlink" title="类成员初始化"></a>类成员初始化</h3></li>
<li><p>无论初始化列表里怎么写，类成员的初始化顺序是<strong>按照他们在类中定义的顺序的</strong></p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3></li>
<li><p>类的多个构造函数中一个构造函数借用类的其他功能强大的构造函数构造对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>(string s):<span class="built_in">data</span>(s)&#123;&#125;</span><br><span class="line">    <span class="built_in">test</span>():<span class="built_in">test</span>(<span class="string">&quot;Hello World&quot;</span>)&#123;&#125; <span class="comment">// 这里是委托带参数的构造函数test(string s)构造对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用默认构造函数（无参数）的时候不能加括号，否则编译器会认为你想声明一个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">className <span class="title">obj</span><span class="params">()</span></span>;<span class="comment">// 看起来就是声明一个叫obj的函数</span></span><br></pre></td></tr></table></figure>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3></li>
<li><p><code>className(const className&amp; cName)&#123;&#125;;</code></p>
</li>
<li><p>第一个参数必须是自身的引用</p>
</li>
<li><p>其他参数必须有默认值</p>
</li>
<li><p>注意形如<code>&lt;className&gt; val = valOld;</code>的是拷贝初始化</p>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3></li>
<li><p>移动语义的目的是在<strong>避免不必要的数据复制</strong>的同时，更高效地管理资源。</p>
</li>
<li><p>在 C++11 引入右值引用之前，对象的拷贝构造函数是唯一的构造函数，用于复制对象。然而，对于临时对象或即将销毁的对象，进行深拷贝可能是不必要的开销。移动构造函数通过使用右值引用，允许在不复制底层资源的情况下将资源从一个对象“移动”到另一个对象。</p>
</li>
<li><p>必须是<code>noexcept</code>标明的</p>
</li>
<li><p>传入的参数是一个右值引用</p>
</li>
<li><p>有不具备移动构造功能的成员，自身也不能移动构造</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">data</span>(other.data), <span class="built_in">length</span>(other.length) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 移动构造函数中，将原对象的资源指针置为空，避免资源被析构</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">        : <span class="built_in">data</span>(<span class="built_in">strdup</span>(str)), <span class="built_in">length</span>(<span class="built_in">strlen</span>(str)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* data;</span><br><span class="line">    std::<span class="keyword">size_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个对象</span></span><br><span class="line">    <span class="function">MyString <span class="title">source</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用移动构造函数，将资源从 source 移动到 target</span></span><br><span class="line">    MyString target = std::<span class="built_in">move</span>(source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Source String: &quot;</span> &lt;&lt; (source.<span class="built_in">GetData</span>() ? source.<span class="built_in">GetData</span>() : <span class="string">&quot;nullptr&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Target String: &quot;</span> &lt;&lt; (target.<span class="built_in">GetData</span>() ? target.<span class="built_in">GetData</span>() : <span class="string">&quot;nullptr&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3></li>
<li><p>可以是成员函数也可以直接是函数</p>
</li>
<li><p>如果运算符是某个类的成员函数那么左侧的操作数<strong>必须是这个类的对象</strong></p>
</li>
<li><p>重载输入输出运算符的时候必须不是成员函数</p>
</li>
<li><p>下标运算符必须是成员函数</p>
</li>
<li><p>赋值运算符必须是成员函数</p>
<h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4></li>
<li><p><code>className&amp; operator++();</code>前置</p>
</li>
<li><p><code>className&amp; operator(int); </code>后置，参数无用，用于与前置区分</p>
</li>
<li><p>一般是成员函数</p>
</li>
</ul>
<h4 id="重载-gt-运算符"><a href="#重载-gt-运算符" class="headerlink" title="重载-&gt;运算符"></a>重载<code>-&gt;</code>运算符</h4><ul>
<li>返回值必须是指针（<strong>可以是某个成员函数类型的指针</strong>）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying MyClass&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 -&gt; 运算符</span></span><br><span class="line">    MyClass* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass myObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载的 -&gt; 运算符</span></span><br><span class="line">    myObject-&gt;<span class="built_in">Display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="等号运算符"><a href="#等号运算符" class="headerlink" title="等号运算符"></a>等号运算符</h3><ul>
<li><code>className&amp; operator=(const className&amp;);</code></li>
<li>控制等号的行为</li>
<li><code>return *this;</code>即可</li>
<li>注意处理等号左右是同一个变量的情况</li>
</ul>
<h3 id="要求系统合成一个默认的构造-析构函数"><a href="#要求系统合成一个默认的构造-析构函数" class="headerlink" title="要求系统合成一个默认的构造/析构函数"></a>要求系统合成一个默认的构造/析构函数</h3><ul>
<li><code>ClassName() = default;</code></li>
<li><code>=default;</code><h3 id="禁止一个构造-复制函数被调用"><a href="#禁止一个构造-复制函数被调用" class="headerlink" title="禁止一个构造/复制函数被调用"></a>禁止一个构造/复制函数被调用</h3></li>
<li><code>ClassName &amp;operator=(const ClassName&amp;) = delete;</code></li>
<li><code>=delete;</code></li>
<li>可以对于任何函数使用</li>
<li>删除析构函数的类型，不能定义该类型的变量或者释放该类型动态对象的指针</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>如果类具有只接受一个参数的构造函数，那么编译器可以将<strong>这个参数类型的对象</strong>自动转换为这个类的对象<ul>
<li>给构造函数增加一个<code>explicit</code>参数可以禁止这种转换</li>
<li>但是static_cast可以调用<code>explicit</code>的构造函数</li>
</ul>
</li>
</ul>
<h3 id="重载类型转换运算符"><a href="#重载类型转换运算符" class="headerlink" title="重载类型转换运算符"></a>重载类型转换运算符</h3><ul>
<li>类型转换运算符通常不显式声明返回类型，因为它们没有返回类型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;</span><br><span class="line">    <span class="keyword">float</span> inches;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> ft, <span class="keyword">float</span> in) : <span class="built_in">feet</span>(ft), <span class="built_in">inches</span>(in) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换运算符，将 Distance 转换为 float</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(feet) + inches / <span class="number">12.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Distance <span class="title">d</span><span class="params">(<span class="number">5</span>, <span class="number">9.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类型转换运算符将 Distance 转换为 float</span></span><br><span class="line">    <span class="keyword">float</span> totalInches = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(d);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total Inches: &quot;</span> &lt;&lt; totalInches &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意防止类型转换运算符与某些具有隐式类型转换功能的构造函数出现二义性</li>
<li>只要有多个用户自定义的类型转换都能达到目的，编译器就认为出线了二义性</li>
</ul>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><ul>
<li><code>override</code>的主要作用是在子类中表明某个<strong>函数是覆盖基类的虚函数的</strong>，方便检查是否真的覆盖了</li>
</ul>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><ul>
<li>使用一个基类的指针调用一个虚函数</li>
<li>根据不同的子类对虚函数的继承，产生不同的结果  </li>
<li>使用基类的指针调用子类的时候，必须基类也有这个函数才行</li>
<li>使用智能指针也能实现这些功能</li>
</ul>
<h3 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h3><ul>
<li>使用基类的指针（或引用）<strong>不能</strong>直接访问子类中定义了但是基类中没定义的成员函数和变量<ul>
<li>需要使用类型转换才能访问</li>
</ul>
</li>
<li>但是可以访问子类中重载了的基类的虚函数</li>
<li>虚函数继承的时候<u><strong>必须函数头完全一致才行，这样才能实现多态</strong></u><ul>
<li>不一样的话会直接覆盖基类的虚函数，不会产生多态，用基类的指针的时候还是会调用基类的函数</li>
</ul>
</li>
<li>可以使用类名和<strong>作用域运算符</strong>手动指定通过指针调用的是哪个函数，从而防止运行时才知道是哪个</li>
<li>基类的构造函数中无法访问子类重载的虚函数，因为这个虚函数表是之后才被构建出来的<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4></li>
<li>基类的析构函数最好写成虚函数，方便多态调用的时候析构掉整个的，否则析构基类的动态对象的时候会只析构基类的部分导致内存泄漏</li>
<li>具有手动析构函数的类，编译器一般<strong>不会</strong>自动合成移动构造函数、拷贝构造函数、等号运算符重载等，需要的话最好手动指出<ul>
<li><u>否则会因此导致继承他的子类因为父类没有这些函数而无法复制构造</u><h4 id="基类的拷贝构造函数和移动构造函数"><a href="#基类的拷贝构造函数和移动构造函数" class="headerlink" title="基类的拷贝构造函数和移动构造函数"></a>基类的拷贝构造函数和移动构造函数</h4></li>
</ul>
</li>
<li>必须显式的子类的相应函数中的初始化列表中调用基类的拷贝构造函数或者移动构造函数<ul>
<li><img src="/imgs/44be057dc9bca19ac215614aa2ab6479eb8204fa537f43cb20a96756074c76f2.png" alt="picture 0">  </li>
</ul>
</li>
</ul>
<h4 id="基类和派生类的-赋值运算符"><a href="#基类和派生类的-赋值运算符" class="headerlink" title="基类和派生类的=赋值运算符"></a>基类和派生类的<code>=</code>赋值运算符</h4><ul>
<li>需要在派生类的<code>=</code>赋值运算符函数体中手动调用基类的赋值运算符</li>
</ul>
<h4 id="构造函数虚函数的情况"><a href="#构造函数虚函数的情况" class="headerlink" title="构造函数虚函数的情况"></a>构造函数虚函数的情况</h4><ul>
<li>在派生类的构造函数初始化列表中调用基类的构造函数的时候最好手动通过<code>类名::</code>的形式指定需要调用的函数，防止因为多态导致调用了继承的构造函数</li>
</ul>
<h4 id="智能指针的情况"><a href="#智能指针的情况" class="headerlink" title="智能指针的情况"></a>智能指针的情况</h4><ul>
<li>涉及智能指针的情况也可以实现多态</li>
<li><code>make_shared</code>或者其他构造一个子类对象即可</li>
</ul>
<h3 id="抽象类和纯虚函数"><a href="#抽象类和纯虚函数" class="headerlink" title="抽象类和纯虚函数"></a>抽象类和纯虚函数</h3><ul>
<li>在一个成员函数后面加上<code>=0;</code>即可实现</li>
<li>类不能被实例化</li>
<li>纯虚函数的定义必须在外部</li>
</ul>
<h3 id="集成的时候的构造函数"><a href="#集成的时候的构造函数" class="headerlink" title="集成的时候的构造函数"></a>集成的时候的构造函数</h3><ul>
<li>基类的数据成员必须调用基类的构造函数构造（在初始化列表直接调用）</li>
<li>然后再按声明的顺序构造自身的对象</li>
</ul>
<h3 id="不能被继承的类"><a href="#不能被继承的类" class="headerlink" title="不能被继承的类"></a>不能被继承的类</h3><ul>
<li>类声明之后加一个<code>final</code></li>
</ul>
<h3 id="private和protected"><a href="#private和protected" class="headerlink" title="private和protected"></a><code>private</code>和<code>protected</code></h3><ul>
<li><code>protected</code>是继承的类能拿到但是别的类拿不到</li>
<li><code>private</code>继承的类也拿不到</li>
<li>派生类的友元对基类的保护对象访问没有任何特权，无法访问protected</li>
</ul>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><ul>
<li>所有成员public</li>
<li>没有构造函数</li>
<li>类内没给初始值</li>
<li>没有基类和虚函数</li>
<li><strong>可以用花括号直接初始化，类似于struct</strong><h3 id="字面值类"><a href="#字面值类" class="headerlink" title="字面值类"></a>字面值类</h3></li>
<li>数据成员必须都是字面值类型</li>
<li>至少有一个常量表达式的构造函数</li>
<li>析构函数必须是默认的</li>
<li>内置类型必须是常量表达式，类调用自己的常量构造函数</li>
<li><code>constexpr</code>的构造函数的函数体必须是空的</li>
<li>此时可以在构造的时候加一个<code>constexpr</code><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3></li>
<li><code>static</code></li>
<li>对象的内存不包含静态对象</li>
<li>static函数不含有this指针，<strong>不能处理非static成员</strong></li>
<li>可以使用类作用域直接调用，也可以用对象的<code>.</code>调用</li>
<li>static关键字只出现在类内声明的场合，定义的时候不出现</li>
<li>初始化<ul>
<li>只有是constexpr的情况下可以在类内声明，但是无法在外部使用</li>
<li><code>int &lt;class name&gt;:: var = blabla;</code></li>
</ul>
</li>
<li>可以在一个类还没被初始化完的时候就声明它的静态对象</li>
<li>类的（不一定是静态）成员函数操作静态成员的时候可以直接操作，<strong>不需要加作用域运算符</strong></li>
</ul>
<h3 id="IO流对象"><a href="#IO流对象" class="headerlink" title="IO流对象"></a>IO流对象</h3><ul>
<li><code>iostream</code>, <code>fstream</code>, <code>sstream</code> </li>
<li>不能修改，赋值</li>
<li>输出<code>endl</code>是刷新缓冲区附带一个回车，输出<code>flush</code>则只刷新缓冲区，输出<code>ends</code>刷新缓冲区的同时附带一个空格</li>
<li>输入和输出流可以绑定，多个输入可以绑定到一个输出<ul>
<li>用<code>.tie(&lt;some stream&gt;)</code>函数</li>
<li>输入与输出绑定的时候，调用输入流的时候自动刷新输出缓冲区</li>
</ul>
</li>
<li><code>fstream</code>可以用<code>open</code>或者<code>close</code>打开或者关闭文件</li>
<li>析构的时候会自动close文件<h4 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h4>open函数flag|功能<br>|—|—|<br>in|读<br>out|写<br>app|追加(每次操作都从末尾开始)<br>ate|打开的时候定位到结尾<br>trunc|如果存在，丢弃内容<br>binary|二进制</li>
<li>只有app和in方式可以保留原来的内容</li>
<li>不指定的话是<code>out</code>和<code>trunc</code><h3 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a>sstream</h3></li>
<li>自身就是个string</li>
<li>可以初始化也可以不初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将一个整数转换为string</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">123</span>;</span><br><span class="line">    stringstream ss1;</span><br><span class="line">    ss1 &lt;&lt; n; <span class="comment">// 向stringstream写入整数</span></span><br><span class="line">    string s1 = ss1.<span class="built_in">str</span>(); <span class="comment">// 获取stringstream内部的string</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl; <span class="comment">// 输出s1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个string分割为单词</span></span><br><span class="line">    string s2 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss2</span><span class="params">(s2)</span></span>; <span class="comment">// 用string初始化stringstream</span></span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (ss2 &gt;&gt; word) <span class="comment">// 从stringstream读取单词</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;word = &quot;</span> &lt;&lt; word &lt;&lt; endl; <span class="comment">// 输出单词</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="std-istringstream"><a href="#std-istringstream" class="headerlink" title="std::istringstream"></a>std::istringstream</h3><ul>
<li>一个字符串输入流，允许你从字符串中读取数据，就像从标准输入流中读取数据一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string inputString = <span class="string">&quot;123 4.56 Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 istringstream 对象，并将字符串传入</span></span><br><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(inputString)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intValue;</span><br><span class="line">    <span class="keyword">float</span> floatValue;</span><br><span class="line">    std::string stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符串流中读取数据</span></span><br><span class="line">    iss &gt;&gt; intValue &gt;&gt; floatValue &gt;&gt; stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出读取到的数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; intValue &lt;&lt; <span class="string">&quot;, Float: &quot;</span> &lt;&lt; floatValue &lt;&lt; <span class="string">&quot;, String: &quot;</span> &lt;&lt; stringValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-ostringstream"><a href="#std-ostringstream" class="headerlink" title="std::ostringstream"></a>std::ostringstream</h3></li>
<li>一个字符串输出流，允许你将数据写入字符串，就像写入标准输出流一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intValue = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line">    std::string stringValue = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ostringstream 对象</span></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据写入字符串流</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; intValue &lt;&lt; <span class="string">&quot;, Float: &quot;</span> &lt;&lt; floatValue &lt;&lt; <span class="string">&quot;, String: &quot;</span> &lt;&lt; stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串</span></span><br><span class="line">    std::string resultString = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出写入的字符串</span></span><br><span class="line">    std::cout &lt;&lt; resultString &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="iostream格式化"><a href="#iostream格式化" class="headerlink" title="iostream格式化"></a>iostream格式化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 进制</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Default: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; std::oct &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Decimal: &quot;</span> &lt;&lt; std::dec &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//填充字符</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Default fill: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Fill with &#x27;*&#x27;: &quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//对齐</span></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Default alignment: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Left alignment: &quot;</span> &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Right alignment: &quot;</span> &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Internal alignment: &quot;</span> &lt;&lt; std::internal &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; -num &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 精度</span></span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.141592653589793</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Default precision: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Precision 4: &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 设置宽度</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Width 10: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="iostream其他用法"><a href="#iostream其他用法" class="headerlink" title="iostream其他用法"></a>iostream其他用法</h2><ul>
<li><code>cin.get</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cin.<span class="built_in">get</span>();</span><br><span class="line">istream&amp; cin.<span class="built_in">get</span>(<span class="keyword">char</span>&amp; var);</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">( <span class="keyword">char</span>* s, streamsize n )</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">( <span class="keyword">char</span>* s,  streamsize  n, <span class="keyword">char</span> delim )</span>。</span></span><br></pre></td></tr></table></figure></li>
<li><code>cin.getline</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>* s, streamsize count)</span></span>; <span class="comment">//默认以换行符结束</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>* s, streamsize count, <span class="keyword">char</span> delim)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><code>gets</code></li>
<li>gets是C中的库函数，在<code>&lt;stdio.h&gt;</code>申明，从标准输入设备读字符串，可以无限读取</li>
<li>不会判断上限，以回车结束或者EOF时停止读取<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> array[<span class="number">20</span>]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">gets</span>(array);</span><br><span class="line">    cout&lt;&lt;array&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2></li>
<li>声明模板类型</li>
<li><code>template&lt;typename T&gt;</code>或者<code>template&lt;typename T, class U&gt;</code></li>
<li><code>class</code>和<code>typename</code>相同，都可以， <strong>但每个类型钱都必须有这二者之一</strong></li>
</ul>
<h3 id="声明未定大小的数组"><a href="#声明未定大小的数组" class="headerlink" title="声明未定大小的数组"></a>声明未定大小的数组</h3><ul>
<li><code>template&lt;unsigned N, unsigned M&gt;</code>其中N和M是未定的大小，比如用于<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="类模板和类模板的成员函数"><a href="#类模板和类模板的成员函数" class="headerlink" title="类模板和类模板的成员函数"></a>类模板和类模板的成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleTemplate</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SimpleTemplate</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 函数</span></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在类外定义类的成员函数注意也要写模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数的声明</span></span><br><span class="line">    <span class="built_in">MyClass</span>(T value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyClass&lt;T&gt;::<span class="built_in">MyClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MyClass&lt;T&gt;::<span class="built_in">display</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个模板类的成员函数在<strong>用到</strong>的时候才被实例化</li>
<li>在一个类模板的作用域内，不必在类名之后带<code>&lt;T&gt;</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">retType className&lt;T&gt;::<span class="built_in">func</span>(val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里使用类的时候直接用className就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板的友元函数"><a href="#类模板的友元函数" class="headerlink" title="类模板的友元函数"></a>类模板的友元函数</h3></li>
<li>只有实例化为同一种类型才成立的友元<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元类模板的特例化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 友元函数模板的特例化</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">FriendFunction</span><span class="params">(<span class="keyword">const</span> MyClass&lt;T&gt;&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>可以通过在<code>friend</code>函数前面独立增加一个<code>template &lt;typename X&gt;</code>来打破友元必须与类实例化为相同的类型才能成为友元的要求，从而使得所有情况下友元都成立<h3 id="模板类型别名"><a href="#模板类型别名" class="headerlink" title="模板类型别名"></a>模板类型别名</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">// 相当于`pair&lt;string, string&gt;`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模板类的静态成员"><a href="#模板类的静态成员" class="headerlink" title="模板类的静态成员"></a>模板类的静态成员</h3><ul>
<li>不同实例化的模板类不共享静态数据成员，只有相同实例化的共享<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化静态数据成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">retType ClassName&lt;T&gt;:: val - <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="模板默认参数"><a href="#模板默认参数" class="headerlink" title="模板默认参数"></a>模板默认参数</h3></li>
<li><code>template &lt;typename T = int&gt;</code></li>
<li>希望使用默认模板参数的时候使用<code>&lt;&gt;</code>即可但是<strong>不能省略</strong></li>
</ul>
<h3 id="模板参数推导"><a href="#模板参数推导" class="headerlink" title="模板参数推导"></a>模板参数推导</h3><ul>
<li>编译器会默认进行模板参数推导，比如调用模板函数的时候，编译器会根据调用的方式自动推导函数模板实例化成哪种函数</li>
<li>用给好类型的函数指针指向模板函数的时候，编译器也会根据<strong>要赋值的函数指针的类型</strong>推断模板函数的实例化方式</li>
</ul>
<h3 id="需要置顶尾置返回类型的场合"><a href="#需要置顶尾置返回类型的场合" class="headerlink" title="需要置顶尾置返回类型的场合"></a>需要置顶尾置返回类型的场合</h3><ul>
<li>需要使用模板参数结合<code>decltype</code>推断返回类型的场合<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模板函数的重载"><a href="#模板函数的重载" class="headerlink" title="模板函数的重载"></a>模板函数的重载</h3><ul>
<li>用别的模板函数重载<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数接受一个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Template Function with one template parameter: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载模板函数，接受两个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Template Function with two template parameters: &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; u &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用非模板函数重载<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Template Function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Non-Template Function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匹配的原则是谁更特殊就匹配谁，非模板版本优先。谁的范围更窄，先匹配谁</li>
</ul>
<h3 id="可变参数类型的类模板"><a href="#可变参数类型的类模板" class="headerlink" title="可变参数类型的类模板"></a>可变参数类型的类模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板递归终止条件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of recursion&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变模板参数的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; first &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printValues</span>(args...);  <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printValues</span>(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Args...</code> 表示一个参数包，可以接受零个或多个类型。在递归调用中，<code>args...</code> 用于<strong>展开参数包</strong>，使得每个参数都能够被单独处理<ul>
<li>就是每次递归调用的时候都把第一个赋值给fisrt，后面的还在<code>args...</code>内部</li>
</ul>
</li>
<li>使用<code>sizeof...</code>计算参数数量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变模板参数的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">countArgs</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>...(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of arguments: &quot;</span> &lt;&lt; <span class="built_in">countArgs</span>(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板函数特例化"><a href="#模板函数特例化" class="headerlink" title="模板函数特例化"></a>模板函数特例化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generic Template Function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化 - 针对int类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> myFunction&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized Template Function for int: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>就是专门为<code>T</code>是某种特定的类型而设定的版本</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Division by zero!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写了<code>noexcept</code>的函数抛出异常不会被<code>catch</code>，会导致程序崩溃<ul>
<li><code>noexept(false)</code>表示可能抛出异常</li>
<li>反之认为不可能抛出异常</li>
</ul>
</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string errorMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> std::string&amp; message) : <span class="built_in">errorMessage</span>(message) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMessage.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="keyword">int</span> globalVar = <span class="number">42</span>;  <span class="comment">// 命名空间中的全局变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from MyNamespace!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Inside MyClass&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以不连续，<code>namespace name&#123;&#125;</code>可以在文件中反复出现多次</li>
<li>别名<code>namespace A = B;</code></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-使用使用Flask，Gunicorn和Nginx部署一个云端ubuntu上的服务器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/21/%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8Flask%EF%BC%8CGunicorn%E5%92%8CNginx%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E4%BA%91%E7%AB%AFubuntu%E4%B8%8A%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"
    >使用使用Flask，Gunicorn和Nginx部署一个云端ubuntu上的服务器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/21/%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8Flask%EF%BC%8CGunicorn%E5%92%8CNginx%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E4%BA%91%E7%AB%AFubuntu%E4%B8%8A%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time datetime="2023-11-21T14:26:50.000Z" itemprop="datePublished">2023-11-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前期下载配置"><a href="#前期下载配置" class="headerlink" title="前期下载配置"></a>前期下载配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新软件包列表</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装Flask</span></span><br><span class="line">sudo pip3 install flask</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装Gunicorn</span></span><br><span class="line">sudo pip3 install gunicorn</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装Nginx</span></span><br><span class="line">sudo apt-get install nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="创建一个Flask-app"><a href="#创建一个Flask-app" class="headerlink" title="创建一个Flask app"></a>创建一个Flask app</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="comment"># 导入Flask模块</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Flask应用实例</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义根路由和视图函数</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是主模块，运行Flask应用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建gunicorn-conf-py"><a href="#创建gunicorn-conf-py" class="headerlink" title="创建gunicorn.conf.py"></a>创建<code>gunicorn.conf.py</code></h2><ul>
<li>注意要在当期目录下创建<code>./logs</code>文件夹<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gunicorn.conf.py</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志的输出路径</span></span><br><span class="line">log_path = os.path.join(os.path.dirname(__file__), <span class="string">&#x27;logs&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(log_path):</span><br><span class="line">    os.mkdir(log_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志的格式</span></span><br><span class="line">log_format = <span class="string">&#x27;%(asctime)s %(levelname)s %(process)d %(message)s&#x27;</span></span><br><span class="line">date_format = <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志的级别</span></span><br><span class="line">log_level = <span class="string">&#x27;info&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志的文件名</span></span><br><span class="line">access_log_file = os.path.join(log_path, <span class="string">&#x27;access.log&#x27;</span>)</span><br><span class="line">error_log_file = os.path.join(log_path, <span class="string">&#x27;error.log&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置日志的配置项</span></span><br><span class="line">accesslog = access_log_file</span><br><span class="line">errorlog = error_log_file</span><br><span class="line">loglevel = log_level</span><br><span class="line"><span class="built_in">format</span> = log_format</span><br><span class="line">datefmt = date_format</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置绑定的IP和端口号</span></span><br><span class="line">bind = <span class="string">&#x27;0.0.0.0:5000&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用上面的配置文件启动gunicorn"><a href="#使用上面的配置文件启动gunicorn" class="headerlink" title="使用上面的配置文件启动gunicorn"></a>使用上面的配置文件启动gunicorn</h2></li>
<li><code>gunicorn -c gunicorn.conf.py &lt;py主文件名&gt;:app</code><h2 id="创建nginx的配置文件"><a href="#创建nginx的配置文件" class="headerlink" title="创建nginx的配置文件"></a>创建nginx的配置文件</h2></li>
<li><code>/etc/nginx/sites-available/flask.conf</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义一个名为flask的server块</span></span><br><span class="line">server &#123;</span><br><span class="line">    # 监听80端口</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    # 定义服务器名称，可以是域名或者IP地址</span><br><span class="line">    server_name 52.184.77.113;</span><br><span class="line"></span><br><span class="line">    # 定义根路由的处理方式</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 转发请求到Gunicorn服务器，注意IP和端口要与Gunicorn绑定的一致</span><br><span class="line">        proxy_pass http://0.0.0.0:5000;</span><br><span class="line"></span><br><span class="line">        # 设置一些代理相关的头部信息</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建软连接<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建符号链接</span></span><br><span class="line">sudo ln -s /etc/nginx/sites-available/flask.conf /etc/nginx/sites-enabled/</span><br></pre></td></tr></table></figure></li>
<li>重启nginx服务<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启Nginx服务</span></span><br><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure></li>
<li>如果服务器需要配置外网端口访问的话在相应的平台配置即可</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flask/" rel="tag">flask</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html/" rel="tag">html</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaScript/" rel="tag">javaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-leetcode非数据结构类型题目题解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/18/leetcode%E9%9D%9E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E9%A2%98%E8%A7%A3/"
    >leetcode非数据结构类型题目题解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/18/leetcode%E9%9D%9E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E9%A2%98%E7%9B%AE%E9%A2%98%E8%A7%A3/" class="article-date">
  <time datetime="2023-11-18T09:40:55.000Z" itemprop="datePublished">2023-11-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="leetcode-318-最大单词长度乘积"><a href="#leetcode-318-最大单词长度乘积" class="headerlink" title="leetcode 318. 最大单词长度乘积"></a>leetcode 318. 最大单词长度乘积</h2><ul>
<li>此题主要是将26个字母映射为26个位，用位运算的形式寻找是否存在重复字母<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">flags</span><span class="params">(words.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;words.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j = words[i].<span class="built_in">begin</span>(); j!=words[i].<span class="built_in">end</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                flags[i] |= <span class="number">1</span>&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(*j-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;words.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;words.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((flags[i]&amp;flags[j]) == <span class="number">0</span>)</span><br><span class="line">                maxVal = <span class="built_in">max</span>(maxVal, <span class="built_in"><span class="keyword">int</span></span>(words[i].<span class="built_in">size</span>()*words[j].<span class="built_in">size</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="leetcode-11-接最多水的容器"><a href="#leetcode-11-接最多水的容器" class="headerlink" title="leetcode 11.接最多水的容器"></a>leetcode 11.接最多水的容器</h2><ul>
<li>双指针法，左边一个右边一个，先左边在最左边，右边在最右边</li>
<li>然后两个指针靠近，选择下一个高度较高的往里挪</li>
<li>每一步的时候都计算承载量，取每一步的最大值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> tempVal = <span class="built_in">min</span>(height[left], height[right])*(right-left);</span><br><span class="line">        <span class="keyword">while</span>(left!=right)</span><br><span class="line">        &#123;</span><br><span class="line">            tempVal = <span class="built_in">min</span>(height[left], height[right])*(right-left);</span><br><span class="line">            maxVal = maxVal&gt;tempVal?maxVal: tempVal;</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;=height[right])left++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="leetcode-42-接雨水"><a href="#leetcode-42-接雨水" class="headerlink" title="leetcode 42.接雨水"></a>leetcode 42.接雨水</h2><ul>
<li>先用数组表示出每个位置左边最高的墙和右边最高的墙，然后每个位置从两个墙选一个最小值与自己的差值（小于0的话取0）加到总和里即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, templ = <span class="number">0</span>, rightMax = <span class="number">0</span>, tempr = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftMap</span><span class="params">(height.size(), <span class="number">0</span>)</span>, <span class="title">rightMap</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;height.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[i]);</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, height[height.<span class="built_in">size</span>()-i<span class="number">-1</span>]);</span><br><span class="line">            leftMap[i] = leftMax;</span><br><span class="line">            rightMap[height.<span class="built_in">size</span>()<span class="number">-1</span>-i] = rightMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sumW = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;height.<span class="built_in">size</span>()<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sumW+=<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(leftMap[i<span class="number">-1</span>], rightMap[i+<span class="number">1</span>]) - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumW;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-560-和为k的子数组"><a href="#Leetcode-560-和为k的子数组" class="headerlink" title="Leetcode 560.和为k的子数组"></a>Leetcode 560.和为k的子数组</h2><ul>
<li>循环一次，每次寻找每个位置的前缀和</li>
<li>然后寻找字典中是否存在<code>pre-k</code></li>
<li>假如存在的话，意味着从<code>pre-k</code>的结束位置开始，到当前的位置结束的一段数组的和是k<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x:nums) &#123;</span><br><span class="line">            pre += x; <span class="comment">// 这一步是前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                count += mp[pre - k]; <span class="comment">// 可行的计数加上这个计数</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++; <span class="comment">// 添加上当前计算的前缀和到字典</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="leetcode-239-滑动窗口最大值"><a href="#leetcode-239-滑动窗口最大值" class="headerlink" title="leetcode 239.滑动窗口最大值"></a>leetcode 239.滑动窗口最大值</h2><ul>
<li>由于我们需要求出的是滑动窗口的最大值，一开始先把一个长度为k的滑动窗口的每个值加入队列</li>
<li>在答案数组里加入优先级队列的头部元素</li>
<li>然后开始移动滑动窗口，先把下一个元素加入队列，然后开始从队列弹出内容</li>
<li>假如此时队列的头部是窗口的第一个index之前的位置（也就是<code>&lt;=i-k</code>）</li>
<li>将其弹出直到遇到当前窗口的头部（<code>i-k+1</code>）在优先级队列的头部，那么此时这个元素一定是窗口中的最大值（不管还有没有滑动窗口值卡九年的元素，此时这个元素都是剩余的所有元素（包括窗口中的所有元素）中的最大值</li>
<li>把此时优先级队列的头部元素加入答案数组（这是此时滑动窗口的最大元素）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans = &#123;q.<span class="built_in">top</span>().first&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">top</span>().second &lt;= i - k) &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用单调队列的方式"><a href="#使用单调队列的方式" class="headerlink" title="使用单调队列的方式"></a>使用单调队列的方式</h3></li>
<li>遇到队列末尾元素小于等于当前需要插入的元素的时候一直弹出</li>
<li>插入当前元素</li>
<li>保持队列是递减的</li>
<li>将队列头部目前不在滑动窗口内，应该弹出的元素全部弹出</li>
<li>队头元素加入返回值序列中（但不弹出）</li>
<li>因为队列的长度不会超过整个滑动窗口的长度，所以此时滑动窗口中小于当前元素的都被弹出，因此队头元素就是滑动窗口中的最大值（因为<strong>递减</strong>）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans = &#123;nums[q.<span class="built_in">front</span>()]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[q.<span class="built_in">back</span>()]) &#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">while</span> (q.<span class="built_in">front</span>() &lt;= i - k) &#123;</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="leetcode-48-旋转图像"><a href="#leetcode-48-旋转图像" class="headerlink" title="leetcode 48. 旋转图像"></a>leetcode 48. 旋转图像</h2><ul>
<li>使用临时变量储存，将矩阵旋转中的四个位置变量依次交换<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                <span class="comment">// 存一个变量然后旋转</span></span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-leetcode树相关题解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/14/leetcode%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E8%A7%A3/"
    >leetcode树相关题解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/14/leetcode%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E8%A7%A3/" class="article-date">
  <time datetime="2023-11-14T14:06:30.000Z" itemprop="datePublished">2023-11-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="leetcode-95-不同的二叉搜索树"><a href="#leetcode-95-不同的二叉搜索树" class="headerlink" title="leetcode 95. 不同的二叉搜索树"></a>leetcode 95. 不同的二叉搜索树</h2><ul>
<li>使用分治递归的方式求解<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;TreeNode*&gt; allTrees;</span><br><span class="line">        <span class="comment">// 枚举可行根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// 获得所有可行的左子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; leftTrees = <span class="built_in">generateTrees</span>(start, i - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得所有可行的右子树集合</span></span><br><span class="line">            vector&lt;TreeNode*&gt; rightTrees = <span class="built_in">generateTrees</span>(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : leftTrees) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : rightTrees) &#123;</span><br><span class="line">                    TreeNode* currTree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">                    currTree-&gt;left = left;</span><br><span class="line">                    currTree-&gt;right = right;</span><br><span class="line">                    allTrees.<span class="built_in">emplace_back</span>(currTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">generateTrees</span>(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode-331-验证二叉树的前序序列化"><a href="#leetcode-331-验证二叉树的前序序列化" class="headerlink" title="leetcode 331.验证二叉树的前序序列化"></a>leetcode 331.验证二叉树的前序序列化</h2></li>
<li>此题采用使用栈模拟递归的方式实现验证，初始时刻先把一个根节点push到栈中，每次先在字符串里寻找结尾或者是逗号，假如找到了说明当前元素结束了，那么回看上一个位置的当前元素（因为现在不是在字符串结尾就是在逗号上），假如是<code>#</code>就说明上一个位置没有元素，那么直接弹出栈中的一个元素（认为是NULL节点），假如不是说明上一个位置是个节点，那么栈中弹出该元素的同时压入两个元素（该元素的左右孩子）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(string preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder.<span class="built_in">size</span>()&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;preorder.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;preorder.<span class="built_in">size</span>()&amp;&amp;preorder[index]!=<span class="string">&#x27;,&#x27;</span>)index++;</span><br><span class="line">            <span class="keyword">char</span> temp = preorder[index<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2></li>
<li>使用递归方式，左侧的左孩子和右侧的右孩子，与左侧的右孩子和右侧的左孩子是否相等，实现递归<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)<span class="keyword">return</span> <span class="built_in">comp</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&amp;&amp;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val != right-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left||right)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!left &amp;&amp; !right)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">comp</span>(left-&gt;left, right-&gt;right)&amp;&amp;<span class="built_in">comp</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode-114-二叉树展开为链表"><a href="#leetcode-114-二叉树展开为链表" class="headerlink" title="leetcode 114.二叉树展开为链表"></a>leetcode 114.二叉树展开为链表</h2></li>
<li>将左子树插入到右子树的地方</li>
<li>将原来的右子树接到左子树的最右边节点</li>
<li>考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null</li>
<li>实际上就是在遍历的过程中先遍历自己，然后左子树，与前序相同，然后左子树<strong>完全结束</strong>之后才到右子树<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root||(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>))<span class="keyword">return</span>;</span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        <span class="keyword">while</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* tRight = temp-&gt;right;</span><br><span class="line">            </span><br><span class="line">            TreeNode* tempL = temp-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(tempL)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(tempL-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    tempL = tempL-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                tempL-&gt;right = temp-&gt;right;</span><br><span class="line">                temp-&gt;right = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;&#125;</span><br><span class="line">            temp-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            temp = temp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-669-修剪二叉搜索树"><a href="#Leetcode-669-修剪二叉搜索树" class="headerlink" title="Leetcode 669.修剪二叉搜索树"></a>Leetcode 669.修剪二叉搜索树</h2><ul>
<li>如果当前节点太小，则递归返回自己的右侧子树</li>
<li>如果太大则返回左侧的子树</li>
<li>如果满足，则递归修剪自己的左右子树<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">            root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-给Linux内核增加实时补丁并安装"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/20/%E7%BB%99Linux%E5%86%85%E6%A0%B8%E5%A2%9E%E5%8A%A0%E5%AE%9E%E6%97%B6%E8%A1%A5%E4%B8%81%E5%B9%B6%E5%AE%89%E8%A3%85/"
    >给Linux内核增加实时补丁并安装</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/20/%E7%BB%99Linux%E5%86%85%E6%A0%B8%E5%A2%9E%E5%8A%A0%E5%AE%9E%E6%97%B6%E8%A1%A5%E4%B8%81%E5%B9%B6%E5%AE%89%E8%A3%85/" class="article-date">
  <time datetime="2023-10-20T05:18:56.000Z" itemprop="datePublished">2023-10-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="为何要安装实时补丁"><a href="#为何要安装实时补丁" class="headerlink" title="为何要安装实时补丁"></a>为何要安装实时补丁</h2><ul>
<li>Linux系统从原理上说并不是一个实时系统，因为Linux系统有很多状态是不可被抢占的，比如持有自旋锁的状态等等，在其他博客中有所涉及，这会导致Linux系统定时不准等一系列问题，对实时控制十分不利</li>
<li>增加实时补丁不能完全使得Linux系统变为实时系统，但是可以使得Linux系统不可抢占的部分大为减少，增强实时性<h2 id="安装实时补丁"><a href="#安装实时补丁" class="headerlink" title="安装实时补丁"></a>安装实时补丁</h2></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44786250/article/details/125736966">参考</a><h3 id="对单个文件打补丁"><a href="#对单个文件打补丁" class="headerlink" title="对单个文件打补丁"></a>对单个文件打补丁</h3></li>
<li>在内核源码根目录下</li>
<li><code>patch -p1 &lt; 补丁文件.patch</code><h3 id="修改内核启动顺序"><a href="#修改内核启动顺序" class="headerlink" title="修改内核启动顺序"></a>修改内核启动顺序</h3></li>
<li>编辑<code>/etc/default/grub</code>文件</li>
<li>GRUB_TIMEOUT=10  %超时时间，单位s</li>
<li>GRUB_DEFAULT=”1&gt;2”  %1代表默认启动内核，2代表所启动内核位于列表中第2个（序号从0开始）</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul>
<li><img src="/imgs/77624abe0dcccbff9f91659a256034ba71294da78a837f76211681bf0f79806b.png" alt="picture 0">  </li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="启动Ubuntu的时候bad-shim-signature"><a href="#启动Ubuntu的时候bad-shim-signature" class="headerlink" title="启动Ubuntu的时候bad shim signature"></a>启动Ubuntu的时候bad shim signature</h3><ul>
<li><p>因为BIOS里开启了安全启动，进入BIOS关闭<strong>secure boot</strong>即可</p>
<h3 id="遇到类似于memtest86-needs-a-16bit等等问题"><a href="#遇到类似于memtest86-needs-a-16bit等等问题" class="headerlink" title="遇到类似于memtest86+ needs a 16bit等等问题"></a>遇到类似于memtest86+ needs a 16bit等等问题</h3></li>
<li><p>在<code>/etc/default/grub</code>文件中添加一行<code>GRUB_DISABLE_OS_PROBER=false</code>，但是<strong>未能解决问题</strong></p>
</li>
<li><p>但是只要在开机的时候按下<code>Esc</code>到Ubuntu高级设置，找到需要的内核启动即可</p>
<h2 id="更换内核之后因为Linux下头文件与内核版本不符导致不能安装本机编译的模块"><a href="#更换内核之后因为Linux下头文件与内核版本不符导致不能安装本机编译的模块" class="headerlink" title="更换内核之后因为Linux下头文件与内核版本不符导致不能安装本机编译的模块"></a>更换内核之后因为Linux下头文件与内核版本不符导致不能安装本机编译的模块</h2><h3 id="以下方法未解决问题"><a href="#以下方法未解决问题" class="headerlink" title="以下方法未解决问题"></a>以下方法未解决问题</h3></li>
<li><p><code>insmod</code>报错为<code>insmod: ERROR: could not insert module ***.ko: Invalid module format</code></p>
</li>
<li><p><code>dmesg</code>查看到报错为<code>disagrees about version of symbol module_layout</code></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wukongmingjing/article/details/81901927">可能的解决方法</a></p>
<ul>
<li><p>(不要执行这一步)编译内核的时候删去模块版本检查<code>module versioning support</code>，在<code>Enable loadable module support</code>下</p>
</li>
<li><p>然后重新安装内核，重新编译模块安装，安装失败使用<code>sudo dmesg</code>查看内核log，得到<code>version magic &#39;6.2.0-rt3 SMP preempt mod_unload modversions &#39; should be &#39;6.2.0-rt3 SMP preempt_rt mod_unload &#39;</code></p>
</li>
<li><p>重新安装内核之后修改内核<code>/usr/src</code>下的内核源码</p>
</li>
<li><p><code>/usr/src/linux-headers-系统内核名称/include/generated</code>下的<code>utsrelease.h</code>中的选项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTS_RELEASE <span class="meta-string">&quot;6.2.0-rt3&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTS_UBUNTU_RELEASE_ABI 35</span></span><br></pre></td></tr></table></figure></li>
<li><p>第一个修改为需要的内核名称即可</p>
</li>
<li><p>然后修改<code>/usr/src/linux-headers-&lt;内核名称&gt;/include/config/kernel.release</code>文件，内容修改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;需要的内核名称&gt; <span class="comment">// 比如 6.2.0-rt3</span></span><br></pre></td></tr></table></figure></li>
<li><p>然后修改真正产生<code>version magic</code>字符串的文件<code>/usr/src/linux-headers-&lt;内核名称&gt;/include/linux/vermagic.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LINUX_VERMAGIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LINUX_VERMAGIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INCLUDE_VERMAGIC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;This header can be included from kernel/module.c or *.mod.c only&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;generated/utsrelease.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/vermagic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Simply sanity version stamp for modules. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_VERMAGIC_SMP <span class="meta-string">&quot;SMP &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_VERMAGIC_SMP <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifdef CONFIG_PREEMPT_BUILD</span></span><br><span class="line"><span class="comment">#define MODULE_VERMAGIC_PREEMPT &quot;preempt &quot;</span></span><br><span class="line"><span class="comment">#elif defined(CONFIG_PREEMPT_RT)</span></span><br><span class="line"><span class="comment">#define MODULE_VERMAGIC_PREEMPT &quot;preempt_rt &quot;</span></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line"><span class="comment">#define MODULE_VERMAGIC_PREEMPT &quot;&quot;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 修改此处</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_VERMAGIC_PREEMPT <span class="meta-string">&quot;preempt_rt &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODULE_UNLOAD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_VERMAGIC_MODULE_UNLOAD <span class="meta-string">&quot;mod_unload &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_VERMAGIC_MODULE_UNLOAD <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MODVERSIONS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_VERMAGIC_MODVERSIONS <span class="meta-string">&quot;modversions &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_VERMAGIC_MODVERSIONS <span class="meta-string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RANDSTRUCT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;generated/randstruct_hash.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_RANDSTRUCT <span class="meta-string">&quot;RANDSTRUCT_&quot;</span> RANDSTRUCT_HASHED_SEED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_RANDSTRUCT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 修改下面的部分拼出自己想要的version magic</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERMAGIC_STRING                \</span></span><br><span class="line"><span class="meta">        UTS_RELEASE <span class="meta-string">&quot; &quot;</span>                \</span></span><br><span class="line"><span class="meta">        MODULE_VERMAGIC_SMP            \</span></span><br><span class="line"><span class="meta">         MODULE_VERMAGIC_PREEMPT       \</span></span><br><span class="line"><span class="meta">        MODULE_VERMAGIC_MODULE_UNLOAD  \</span></span><br><span class="line"><span class="meta">        <span class="comment">// MODULE_VERMAGIC_MODVERSIONS \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        MODULE_ARCH_VERMAGIC           \</span></span></span><br><span class="line"><span class="comment"><span class="meta">        MODULE_RANDSTRUCT</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _LINUX_VERMAGIC_H */</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>找到<code>VERMAGIC_STRING</code>中的对应项，自己修改为需要的值或者顺序，注释掉不需要的即可</p>
</li>
<li><p>然后得到与前面要求的相同的<code>version magic</code>字符串，即可<code>insmod</code>了</p>
<h4 id="找不到符号Unknown-symbol-mutex-init-err-2"><a href="#找不到符号Unknown-symbol-mutex-init-err-2" class="headerlink" title="找不到符号Unknown symbol __mutex_init (err -2)"></a>找不到符号<code>Unknown symbol __mutex_init (err -2)</code></h4></li>
</ul>
</li>
<li><p>insmod报错<code>insmod: ERROR: could not insert module ***.ko: Unknown symbol in module</code></p>
</li>
<li><p><strong>未能解决</strong></p>
<h3 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h3></li>
<li><p>在编译内核模块的时候，将内核模块目录下的<code>Makefile</code>文件中的<code>KDIR</code><strong>修改为自己编译当前内核源码的目录，不要用<code>/usr/src</code>下的源码</strong>，然后照常make即可<code>insmod</code></p>
</li>
<li><p><strong>不要</strong>在<code>make menuconfig</code>中关闭<code>module versioning support</code>选项，否则会因为<code>version magic</code>字符串不一致导致很多<u>预编译好的其他模组不能安装</u></p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E6%A0%B8/" rel="tag">内核</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-使用Cython加速python程序计算"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/18/%E4%BD%BF%E7%94%A8Cython%E5%8A%A0%E9%80%9Fpython%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97/"
    >使用Cython加速python程序计算</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/18/%E4%BD%BF%E7%94%A8Cython%E5%8A%A0%E9%80%9Fpython%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97/" class="article-date">
  <time datetime="2023-10-18T10:55:52.000Z" itemprop="datePublished">2023-10-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cython.readthedocs.io/en/latest/">cython</a><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/traditional/p/13285339.html">参考（详细）</a></li>
<li>定义一个<code>.pyx</code>文件<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># try111.pyx</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello_to_c</span>(<span class="params">m</span>):</span></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="built_in">sum</span>+=i</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="comment"># print(t2-t1)</span></span><br><span class="line">    <span class="keyword">return</span> t2-t1</span><br></pre></td></tr></table></figure></li>
<li>创建<code>setup.py</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setup.py</span></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&#x27;Hello world app&#x27;</span>,</span><br><span class="line">    ext_modules=cythonize(<span class="string">&quot;try111.pyx&quot;</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>使用cython<strong>编译</strong>文件为一个<code>.so</code>模块</li>
<li><code>python3 setup.py build_ext --inplace</code></li>
<li>直接调用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> try111 <span class="keyword">import</span> say_hello_to_c</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello_to_py</span>(<span class="params">m</span>):</span></span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="built_in">sum</span>+=i</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="comment"># print(t2-t1)</span></span><br><span class="line">    <span class="keyword">return</span> t2-t1</span><br><span class="line"></span><br><span class="line">t1s = []</span><br><span class="line">t2s = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">100</span>)):</span><br><span class="line">    t1s.append(say_hello_to_c(<span class="number">10000000</span>))</span><br><span class="line">    t2s.append(say_hello_to_py(<span class="number">10000000</span>))</span><br><span class="line"></span><br><span class="line">plt.plot(t1s, label=<span class="string">&quot;cython&quot;</span>)</span><br><span class="line">plt.plot(t2s, label=<span class="string">&quot;python&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.ylabel(<span class="string">&quot;time elapsed: s&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;count of try&quot;</span>)</span><br><span class="line">avg1 = <span class="built_in">sum</span>(t1s)/<span class="built_in">len</span>(t1s)</span><br><span class="line">avg2 = <span class="built_in">sum</span>(t2s)/<span class="built_in">len</span>(t2s)</span><br><span class="line">plt.title(<span class="string">&quot;Cython average time: %03f, pythonaverage time: %03f&quot;</span>% (avg1, avg2))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
<li><img src="/imgs/ac34bc5371e0a7c44304670157611ef0717929dd11f3237001517566579a2bf6.png" alt="picture 0">  <ul>
<li>可见cython有一定的速度优势<h3 id="编译单个文件"><a href="#编译单个文件" class="headerlink" title="编译单个文件"></a>编译单个文件</h3></li>
</ul>
</li>
<li>使用<code>cythonize</code>直接编译</li>
<li>使用方法<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">options:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -X NAME=VALUE,..., --directive NAME=VALUE,...</span><br><span class="line">                        <span class="built_in">set</span> a compiler directive</span><br><span class="line">  -E NAME=VALUE,..., --compile-time-env NAME=VALUE,...</span><br><span class="line">                        <span class="built_in">set</span> a compile time environment variable</span><br><span class="line">  -s NAME=VALUE, --option NAME=VALUE</span><br><span class="line">                        <span class="built_in">set</span> a cythonize option</span><br><span class="line">  -2                    use Python 2 syntax mode by default</span><br><span class="line">  -3                    use Python 3 syntax mode by default</span><br><span class="line">  --3str                use Python 3 syntax mode by default</span><br><span class="line">  -+, --cplus           Compile as C++ rather than C</span><br><span class="line">  -a, --annotate        Produce a colorized HTML version of the <span class="built_in">source</span>.</span><br><span class="line">  --annotate-fullc      Produce a colorized HTML version of the <span class="built_in">source</span> <span class="built_in">which</span> includes entire generated C/C++-code.</span><br><span class="line">  -x PATTERN, --exclude PATTERN</span><br><span class="line">                        exclude certain file patterns from the compilation</span><br><span class="line">  -b, --build           build extension modules using distutils/setuptools</span><br><span class="line">  -i, --inplace         build extension modules <span class="keyword">in</span> place using distutils/setuptools (implies -b)</span><br><span class="line">  -j N, --parallel N    run builds <span class="keyword">in</span> N parallel <span class="built_in">jobs</span> (default: 18)</span><br><span class="line">  -f, --force           force recompilation</span><br><span class="line">  -q, --quiet           be less verbose during compilation</span><br><span class="line">  --lenient             increase Python compatibility by ignoring some compile time errors</span><br><span class="line">  -k, --keep-going      compile as much as possible, ignore compilation failures</span><br><span class="line">  --no-docstrings       strip docstrings</span><br><span class="line">  -M, --depfile         produce depfiles <span class="keyword">for</span> the sources</span><br></pre></td></tr></table></figure></li>
<li>编译C++文件的时候需要加上<code>--cplus</code></li>
<li>比如<code>cythonize -i &lt;pyx文件名&gt; -j &lt;并行的线程数量&gt;</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tryCpp.pyx</span></span><br><span class="line"><span class="comment"># distutils: language = c++</span></span><br><span class="line"><span class="keyword">from</span> libcpp.vector cimport vector</span><br><span class="line"><span class="keyword">from</span> libcpp.<span class="built_in">map</span> cimport <span class="built_in">map</span></span><br><span class="line"><span class="keyword">from</span> libcpp.string cimport string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vectorCalc</span>(<span class="params"><span class="built_in">int</span> num</span>):</span></span><br><span class="line">    cdef <span class="built_in">int</span> cnt, i, j</span><br><span class="line">    cdef vector[<span class="built_in">int</span>] p</span><br><span class="line">    cdef <span class="built_in">map</span></span><br><span class="line"></span><br><span class="line">    p.reserve(num)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num*<span class="number">5</span>):</span><br><span class="line">        p.push_back(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num*<span class="number">5</span>):</span><br><span class="line">        p.pop_back()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">useMap</span>(<span class="params"><span class="built_in">int</span> cnt</span>):</span></span><br><span class="line">    cdef <span class="built_in">int</span> i, j</span><br><span class="line">    cdef <span class="built_in">map</span>[<span class="built_in">int</span>, string] testMap</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">        testMap[i] = &lt;string&gt;(<span class="string">b&quot;This is %d&quot;</span> % i)</span><br><span class="line">    <span class="keyword">return</span> testMap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是另一种方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">useMap</span>(<span class="params"><span class="built_in">int</span> cnt</span>):</span></span><br><span class="line">    cdef <span class="built_in">int</span> i, j</span><br><span class="line">    cdef <span class="built_in">map</span>[<span class="built_in">int</span>, string] testMap</span><br><span class="line">    cdef pair[<span class="built_in">int</span>, string] p</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">        <span class="comment"># testMap[i] = &lt;string&gt;(b&quot;This is %d&quot; % i)</span></span><br><span class="line">        p = (i, &lt;string&gt;(<span class="string">b&quot;This is %d&quot;</span> % i))</span><br><span class="line">        testMap.insert(p)</span><br><span class="line">    <span class="keyword">return</span> testMap</span><br></pre></td></tr></table></figure></li>
<li><code># distutils: language = c++</code>的意思是告诉cython这个文件需要做成Cpp文件</li>
<li>从上述代码可以看出，可以在cython中使用cpp标准库中的文件<h3 id="在cython中使用C-中编写的类"><a href="#在cython中使用C-中编写的类" class="headerlink" title="在cython中使用C++中编写的类"></a>在cython中使用C++中编写的类</h3></li>
<li><a target="_blank" rel="noopener" href="https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html#standard-library">教程</a></li>
<li>编写头文件和Cpp文件<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tryCLass.h</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> TRYCLASS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TRYCLASS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> try111</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">tryClass</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">tryClass</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="built_in">tryClass</span>();</span><br><span class="line"></span><br><span class="line">        ~<span class="built_in">tryClass</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tryCLass.cpp</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;tryClass.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">try111::tryClass::<span class="built_in">tryClass</span>(<span class="keyword">int</span> m, <span class="keyword">int</span> n):<span class="built_in">i</span>(m),<span class="built_in">j</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;try Class created, i:&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;j:&quot;</span>&lt;&lt;j&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try111::tryClass::<span class="built_in">tryClass</span>():<span class="built_in">i</span>(<span class="number">1</span>),<span class="built_in">j</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;try Class created&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try111::tryClass::~<span class="built_in">tryClass</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;try Class destroyed, i:&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;j:&quot;</span>&lt;&lt;j&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在<code>.pxd</code>文件中声明这个文件<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tryClass.pxd</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;tryClass.cpp&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;tryClass.h&quot;</span> namespace <span class="string">&quot;try111&quot;</span>:</span><br><span class="line">    cdef cppclass tryClass:</span><br><span class="line">        tryClass(<span class="built_in">int</span> i, <span class="built_in">int</span> j) <span class="keyword">except</span> +</span><br><span class="line">        tryClass() <span class="keyword">except</span> +</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在<code>.pyx</code>文件中引用这个文件中的类</li>
<li><code>.pyx</code>的第一行要添加<code># distutils: language = c++</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tryImp.pyx</span></span><br><span class="line"><span class="comment"># distutils: language = c++</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tryCLass cimport tryClass</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tryObj</span>():</span></span><br><span class="line">    heapObj = new tryClass(<span class="number">99</span>, <span class="number">98</span>)</span><br><span class="line">    cdef tryClass ttt = tryClass(<span class="number">97</span>, <span class="number">96</span>)</span><br><span class="line">    <span class="keyword">del</span> heapObj</span><br></pre></td></tr></table></figure></li>
<li>编译<code>cythonize -i -f tryImp.pyx -j8</code></li>
<li>在python文件中调用<code>.pyx</code>文件中的函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">from</span> tryImp <span class="keyword">import</span> *</span><br><span class="line">tryObj()</span><br></pre></td></tr></table></figure>
<h3 id="cython中使用C-开发的函数"><a href="#cython中使用C-开发的函数" class="headerlink" title="cython中使用C++开发的函数"></a>cython中使用C++开发的函数</h3></li>
<li>类似的，直接在cpp文件中定义一个函数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func.cpp</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;func:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>.pxd</code>文件包装<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># impFunc.pxd</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;func.cpp&quot;</span>:</span><br><span class="line">    void func(<span class="built_in">int</span> cnt)</span><br></pre></td></tr></table></figure></li>
<li>在<code>.pyx</code>中调用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#useFunc.pyx</span></span><br><span class="line"><span class="comment"># distutils: language = c++</span></span><br><span class="line"><span class="keyword">from</span> impFunc cimport func</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">useFunc</span>(<span class="params"><span class="built_in">int</span> i</span>):</span></span><br><span class="line">    func(i)</span><br></pre></td></tr></table></figure></li>
<li>编译<code>cythonize -i -f useFunc.pyx -j8</code></li>
<li>在python文件中使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> useFunc <span class="keyword">import</span> useFunc</span><br><span class="line">useFunc(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
<li>执行结果<ul>
<li><img src="/imgs/43fc6fe5a770a3ea885661862de05d62e6f47d9ebdc2d39e9c439434390c1b57.png" alt="picture 8">  <h3 id="cython中使用C-运算符重载和泛型"><a href="#cython中使用C-运算符重载和泛型" class="headerlink" title="cython中使用C++运算符重载和泛型"></a>cython中使用C++运算符重载和泛型</h3></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html#overloading-operators">参考</a></li>
<li>使用重载运算符和类模板<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// opReload.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OPERSTOR_RELOAD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPERATOR_RELOAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OPRELOAD</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">opReload</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T inner;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">opReload</span>();</span><br><span class="line">    <span class="built_in">opReload</span>(<span class="keyword">const</span> T&amp; arg);</span><br><span class="line">    <span class="built_in">opReload</span>(<span class="keyword">const</span> opReload&lt;T&gt;&amp; o);</span><br><span class="line">    opReload <span class="keyword">operator</span>+(<span class="keyword">const</span> opReload&lt;T&gt;&amp; o1);</span><br><span class="line">    opReload <span class="keyword">operator</span>-(<span class="keyword">const</span> opReload&lt;T&gt;&amp; o1);</span><br><span class="line">    <span class="function">T <span class="title">getInner</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">opReload</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T opReload&lt;T&gt;::<span class="built_in">getInner</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">opReload&lt;T&gt;::<span class="built_in">opReload</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">opReload&lt;T&gt; ::<span class="built_in">opReload</span>(<span class="keyword">const</span> opReload&lt;T&gt;&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;inner = arg.inner;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;copying...&quot;</span>&lt;&lt;arg.inner&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">opReload&lt;T&gt;::<span class="built_in">opReload</span>(<span class="keyword">const</span> T&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;op created: &quot;</span>&lt;&lt;arg&lt;&lt;std::endl;</span><br><span class="line">    inner = arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">opReload&lt;T&gt;::~<span class="built_in">opReload</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;op destroyed: &quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;inner&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">opReload&lt;T&gt; opReload&lt;T&gt;:: <span class="keyword">operator</span>+(<span class="keyword">const</span> opReload&lt;T&gt;&amp; o1)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Adding...&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;inner+o1.inner&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> opReload&lt;T&gt;(<span class="keyword">this</span>-&gt;inner+o1.inner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">opReload&lt;T&gt; opReload&lt;T&gt;:: <span class="keyword">operator</span>-(<span class="keyword">const</span> opReload&lt;T&gt;&amp; o1)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Minusing...&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;inner-o1.inner&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> opReload&lt;T&gt;(<span class="keyword">this</span>-&gt;inner-o1.inner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># opReload.pxd</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;opReload.h&quot;</span> namespace <span class="string">&quot;OPRELOAD&quot;</span>:</span><br><span class="line">    cdef cppclass opReload[T]:</span><br><span class="line">        opReload() <span class="keyword">except</span> +</span><br><span class="line">        opReload(const T&amp; arg) <span class="keyword">except</span> +</span><br><span class="line">        opReload(const opReload[T]&amp; o) <span class="keyword">except</span> +</span><br><span class="line">        opReload[T] operator+(opReload[T]&amp;)</span><br><span class="line">        opReload[T] operator-(opReload[T]&amp;)</span><br><span class="line">        T getInner()</span><br></pre></td></tr></table></figure></li>
<li>上面引入的时候需要传入模板类的参数<code>opReload[T]&amp;</code></li>
<li>可以使用复制构造函数，使用方法是<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">oo = opReload[double](op1)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># distutils: language = c++</span></span><br><span class="line"><span class="keyword">from</span> opReload cimport opReload</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">useClass</span>():</span></span><br><span class="line">    cdef double o1 = <span class="number">1.5</span></span><br><span class="line">    cdef double o2 = <span class="number">2.5</span></span><br><span class="line">    cdef opReload[double] op1 = opReload[double](o1)</span><br><span class="line">    cdef opReload[double] op2 = opReload[double](o2)</span><br><span class="line"></span><br><span class="line">    cdef opReload[double] o, o_, oo</span><br><span class="line">    oo = opReload[double](op1)</span><br><span class="line">    o = op1+op2</span><br><span class="line">    o_ = op1-op2</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o.getInner(), o_.getInner()</span><br></pre></td></tr></table></figure></li>
<li>调用输出（main中只调用了pyx中的函数）<ul>
<li><img src="/imgs/cfc20733ae8050783fd590438597bd445ca0cf54b12195fedfab5c37094b1d38.png" alt="picture 9"></li>
</ul>
</li>
<li>创建栈上的对象的时候，对象必须至少有一个无参数的构造函数，否则无法创建  <h3 id="在栈上和堆上分配变量"><a href="#在栈上和堆上分配变量" class="headerlink" title="在栈上和堆上分配变量"></a>在栈上和堆上分配变量</h3></li>
<li>从<code>libc.stdlib</code>引入<code>malloc</code>和<code>free</code></li>
<li>分配堆上对象<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cdef vector[char]* v = new vector[char](<span class="number">10</span>)</span><br><span class="line">cdef char* strOnHeap = &lt;char*&gt;malloc(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li>
<li>注意此处分配的动态<code>vector</code>对象需要使用<code>v[0]</code>·解引用（类似于<code>*v</code>）才能使用，否则会出错类似于<code>terminate called after throwing an instance of &#39;std::bad_alloc&#39;</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># distutils: language = c++</span></span><br><span class="line"><span class="keyword">from</span> libc.stdlib cimport malloc, free</span><br><span class="line"><span class="keyword">from</span> libcpp.vector cimport vector</span><br><span class="line"><span class="keyword">from</span> libc.stdio cimport printf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocAndFree</span>():</span></span><br><span class="line">    cdef char* strOnHeap = &lt;char*&gt;malloc(<span class="number">10</span>)</span><br><span class="line">    printf(<span class="string">&quot;Alloced\n&quot;</span>)</span><br><span class="line">    cdef vector[char]* v = new vector[char](<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    cdef <span class="built_in">int</span> m</span><br><span class="line">    cdef char* strLit = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strLit)):</span><br><span class="line">        strOnHeap[m] = strLit[m]</span><br><span class="line">    </span><br><span class="line">    cdef <span class="built_in">int</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        v[<span class="number">0</span>][i] = &lt;char&gt;(<span class="built_in">int</span>(<span class="string">&#x27;0&#x27;</span>.encode(<span class="string">&quot;ascii&quot;</span>))+i)</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">&quot;%s\n&quot;</span>, strOnHeap)</span><br><span class="line">    <span class="comment"># printf(&quot;Alloced\n&quot;)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        printf(<span class="string">&quot;%d&quot;</span>, v[<span class="number">0</span>][i])</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> v</span><br><span class="line">    free(strOnHeap)</span><br></pre></td></tr></table></figure></li>
<li>释放<code>malloc</code>内存空间直接<code>free</code>即可</li>
<li>释放申请的动态变量使用<code>del</code><h3 id="使用编译好的C-C-动态库-so（Linux下）"><a href="#使用编译好的C-C-动态库-so（Linux下）" class="headerlink" title="使用编译好的C/C++动态库.so（Linux下）"></a>使用编译好的C/C++动态库.so（Linux下）</h3></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/traditional/p/13285339.html">参考</a></li>
<li>c 源文件<code>calc.c</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;calc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcFunc</span><span class="params">(<span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;max;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r|&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j&lt;max; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>c头文件<code>calc.h</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> CALC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CALC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcFunc</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>.pyx文件（注意导入的C库函数不可以被直接引用，需要在.pyx中包装一次）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># useCalc.pyx</span></span><br><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;calc.h&quot;</span>:</span><br><span class="line">    void calcFunc(<span class="built_in">int</span> i)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">useFunc</span>(<span class="params"><span class="built_in">int</span> i</span>):</span></span><br><span class="line">    calcFunc(i)</span><br></pre></td></tr></table></figure></li>
<li><code>gcc</code>生成动态链接库</li>
<li><code>gcc -shared -o lib&lt;输出文件&gt;.so 源文件.c -fPIC</code><ul>
<li><code>-fPIC</code>是生成位置无关代码的意思</li>
<li>注意必须遵守命名规范</li>
</ul>
</li>
<li>给出头<code>.h</code>文件方便调用</li>
<li>但是直接使用命令行工具cythonize编译将会无法找到符号，报错<code>undefined symbol: calcFunc</code></li>
<li>需要创建<code>setup.py</code>指导编译和链接<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">ext_modules = [</span><br><span class="line">    Extension(</span><br><span class="line">        <span class="string">&quot;useCalc&quot;</span>,  <span class="comment"># the module name exposed to python</span></span><br><span class="line">        [<span class="string">&quot;useCalc.pyx&quot;</span>],  <span class="comment"># the Cython source file</span></span><br><span class="line">        libraries=[<span class="string">&quot;calc&quot;</span>],  <span class="comment"># the name of library to link with</span></span><br><span class="line">        library_dirs=[<span class="string">&quot;/home/frank/study/cython/use_So&quot;</span>],  <span class="comment"># the path to your library</span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">&quot;useCalc&quot;</span>,</span><br><span class="line">    ext_modules=cythonize(ext_modules, language_level=<span class="number">3</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li>执行<code>python3 setup.py build_ext --inplace</code></li>
<li>仍然报错<code>libcalc.so: cannot open shared object file: No such file or directory</code></li>
<li>使用<code>ldd</code>命令查看cython编译出的<code>.so</code>文件，看到<ul>
<li><img src="/imgs/d49db8317b38865063fc451d1863fc4426509294bd3f89984a4591f8f690a0d5.png" alt="picture 10">  </li>
<li>此时可见<code>libcalc.so</code>是<code>not found</code></li>
<li>将库文件的目录添加到<code>/etc/ld.so.conf</code>，使用<code>vim</code>编辑</li>
<li><img src="/imgs/955c917f8662d9fdf93eb5714341b9c311b042672da5728094796072165e66c7.png" alt="picture 12">  <ul>
<li>自己添加的目录前面不加<code>include</code></li>
</ul>
</li>
</ul>
</li>
<li><code>sudo /sbin/ldconfig</code>使添加生效<h4 id="另：使用C语言如何调用动态链接库"><a href="#另：使用C语言如何调用动态链接库" class="headerlink" title="另：使用C语言如何调用动态链接库"></a>另：使用C语言如何调用动态链接库</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;calc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    calcFunc(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>引入头文件直接使用</li>
<li>编译的时候需要添加搜索路径<code>-L</code>和添加自身库<code>-l</code></li>
<li><code>gcc -o main main.c -L. -lmylib</code><ul>
<li><code>-L.</code>的意思是在当前目录下查找</li>
</ul>
</li>
<li>同样需要在<code>/etc/ld.so.conf</code>中添加并且执行<code>sudo /sbin/ldconfig</code>生效</li>
</ul>
<h3 id="提高代码执行速度"><a href="#提高代码执行速度" class="headerlink" title="提高代码执行速度"></a>提高代码执行速度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello_to_c</span>(<span class="params"><span class="built_in">int</span> m</span>):</span></span><br><span class="line">    cdef double t1 = time.time()</span><br><span class="line">    cdef long <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    cdef <span class="built_in">int</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="built_in">sum</span>+=i</span><br><span class="line">    cdef double t2 = time.time()</span><br><span class="line">    <span class="comment"># print(t2-t1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>, t2-t1</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src="/imgs/0ab7640f35d15174084b37c7a0e1d12bd0fccebc55582a8730827d6591fc5c2b.png" alt="picture 4">  </p>
</li>
<li><p>可以看出<strong>增加了类型声明</strong>，会使得函数性能有很大的提高</p>
</li>
<li><p>给<code>sum</code>添加了<code>volatile</code>关键字<code>cdef volatile long sum = 0</code>，没有很大的变化</p>
</li>
<li><p>如果将变量变为全局变量，则</p>
</li>
<li><p><img src="/imgs/a2232f7f204bdc754b369d58bf58dd2d21fea4d41bdb77d2d4724cabf41d2c4d.png" alt="picture 5">  </p>
</li>
<li><p>还是并无明显区别，判断不是编译器优化导致的不同，快了124.46倍</p>
</li>
<li><p>更换需要外部空间的计算，也是C程序快非常多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arraySum</span>(<span class="params"><span class="built_in">int</span> m</span>):</span></span><br><span class="line">    cdef <span class="built_in">int</span> a[<span class="number">1000000</span>]</span><br><span class="line">    cdef long <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    cdef <span class="built_in">int</span> i = <span class="number">0</span></span><br><span class="line">    cdef <span class="built_in">int</span> j = <span class="number">0</span></span><br><span class="line">    cdef double t1 = time.time()</span><br><span class="line">    cdef double t2</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        a[i] = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="built_in">sum</span>+=a[j]</span><br><span class="line">    t2 = time.time()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>, t2-t1</span><br></pre></td></tr></table></figure></li>
<li><p>比较时间</p>
</li>
<li><p><img src="/imgs/8dc7e5fda4cb21da9aa39b6e66c5b7aff6156b77b92d45d8dbaf5dc9db8788d8.png" alt="picture 6">  </p>
<ul>
<li>无论是在程序内部还是外部测量，可见二者时间没有明显的差异，都比python程序快非常多，基本上快了50倍左右</li>
</ul>
</li>
</ul>
<h2 id="其他加速python程序的方法"><a href="#其他加速python程序的方法" class="headerlink" title="其他加速python程序的方法"></a>其他加速python程序的方法</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/347185566">参考知乎</a><h3 id="可以给函数加缓存lru-cache"><a href="#可以给函数加缓存lru-cache" class="headerlink" title="可以给函数加缓存lru_cache"></a>可以给函数加缓存<code>lru_cache</code></h3></li>
<li>函数前加一个<code>@lru_cache()</code></li>
<li><img src="/imgs/e0b2da1abf14f2206680f772c1ad31cdffb7323c5b4c60f087a2b9d919e7ba5c.png" alt="picture 7">  </li>
</ul>
<h3 id="pypy解释器"><a href="#pypy解释器" class="headerlink" title="pypy解释器"></a>pypy解释器</h3><ul>
<li><code>pypy3 &lt;代码路径&gt;</code></li>
<li>速度可以提高多倍</li>
</ul>
<h3 id="使用numba作为python的解释器"><a href="#使用numba作为python的解释器" class="headerlink" title="使用numba作为python的解释器"></a>使用numba作为python的解释器</h3><ul>
<li>如果代码中有很多numpy数组或者循环，使用numba会提高效率</li>
<li>使用装饰器<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numba <span class="keyword">import</span> jit</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">100</span>).reshape(<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@jit(<span class="params">nopython=<span class="literal">True</span></span>) </span><span class="comment"># Set &quot;nopython&quot; mode for best performance, equivalent to @njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_fast</span>(<span class="params">a</span>):</span> <span class="comment"># Function is compiled to machine code when called the first time</span></span><br><span class="line">    trace = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a.shape[<span class="number">0</span>]):   <span class="comment"># Numba likes loops</span></span><br><span class="line">        trace += np.tanh(a[i, i]) <span class="comment"># Numba likes NumPy functions</span></span><br><span class="line">    <span class="keyword">return</span> a + trace              <span class="comment"># Numba likes NumPy broadcasting</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(go_fast(x))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/152343123">参考2</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cython/" rel="tag">cython</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Linux实时线程和进程调度"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/10/Linux%E5%AE%9E%E6%97%B6%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"
    >Linux实时线程和进程调度</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/10/Linux%E5%AE%9E%E6%97%B6%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/" class="article-date">
  <time datetime="2023-10-10T02:48:43.000Z" itemprop="datePublished">2023-10-10</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="实时线程"><a href="#实时线程" class="headerlink" title="实时线程"></a>实时线程</h2><ul>
<li>在Linux中，实时线程是一种特殊类型的线程，它们的调度策略和优先级可以被设置为<strong>实时的</strong>。这意味着，<u>相比于普通的线程，实时线程有更高的优先级</u>，而且它们的执行<strong>不会被低优先级的线程打断</strong>。<h3 id="实时线程的调度策略"><a href="#实时线程的调度策略" class="headerlink" title="实时线程的调度策略"></a>实时线程的调度策略</h3></li>
<li><code>SCHED_FIFO</code><strong>先入先出</strong>策略<ul>
<li>线程会一直运行，直到它自己放弃CPU时间，或者有更高优先级的线程需要运行</li>
</ul>
</li>
<li><code>SCHED_RR</code>时间片轮转调度方案<ul>
<li>类似于SCHED_FIFO，但是每个线程会有一个固定的时间片来运行。当一个线程的时间片用完时，它会被放到同优先级线程的队列尾部<h3 id="C语言设置线程优先级的方法"><a href="#C语言设置线程优先级的方法" class="headerlink" title="C语言设置线程优先级的方法"></a>C语言设置线程优先级的方法</h3></li>
</ul>
</li>
<li>使用<code>pthread</code>多线程库<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是线程的代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程属性</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程为分离状态，这样当线程结束时会自动释放所有资源</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的调度策略为实时调度策略SCHED_FIFO</span></span><br><span class="line">    pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程的优先级为最高</span></span><br><span class="line">    param.sched_priority = sched_get_priority_max(SCHED_FIFO);</span><br><span class="line">    pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;thread, &amp;attr, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁线程属性对象</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>请注意，只有具有适当权限的用户（<strong>通常是root用户</strong>）才能创建实时线程。此外，过度使用实时线程可能会导致系统响应变慢，甚至完全无响应, 也可能导致系统直接崩溃。请谨慎使用。<h3 id="time命令"><a href="#time命令" class="headerlink" title="time命令"></a>time命令</h3></li>
<li>使用<code>time</code>命令运行程序的时候，Ctrl+C可以计算程序在系统空间（sys）总时间（包括多个CPU核心）、用户空间（user）（包括多个CPU核心）总时间以及人类视角（real）运行了多长时间</li>
<li><img src="/imgs/25e8453983943c5738259427ffafb96927d6435b643d6e48c2bf3ee66bc2eff6.png" alt="picture 8">  </li>
</ul>
<h2 id="实时进程"><a href="#实时进程" class="headerlink" title="实时进程"></a>实时进程</h2><ul>
<li>实时进程和实施线程类似，因为Linux在进行CPU调度的时候线程和进程是平等的</li>
<li>调度方式也是有<code>SCHED_FIFO</code>和<code>SCHED_RR</code>两种方式</li>
<li>设置一个进程为实时进程<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chrt -f -a -p 99 pid</span><br></pre></td></tr></table></figure></li>
<li>其中<code>pid</code>是需要控制的线程的进程id（Linux中每个线程都有单独的进程ID，inux中每个线程都有单独的进程ID。在Linux中，线程其实是通过轻量级进程（LWP）实现的，因此<strong>Linux中每个线程都是一个进程</strong>，都拥有一个PID。换句话说，操作系统原理中的线程，对应的其实是Linux中的进程）</li>
<li><code>-a</code>是进程的所有线程，可以不用这个选项，针对每个线程单独设置</li>
<li>在C程序中设置一个进程的调度方式<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line">    <span class="keyword">int</span> policy = SCHED_FIFO;  <span class="comment">// 这里可以改为你想要的调度策略</span></span><br><span class="line"></span><br><span class="line">    param.sched_priority = sched_get_priority_max(policy);</span><br><span class="line">    <span class="keyword">if</span> (sched_setscheduler(<span class="number">0</span>, policy, &amp;param) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sched_setscheduler&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是进程的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在shell脚本中设置进程的调度方式<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chrt -f 99 pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> -f是FIFO调度方式</span></span><br><span class="line">sudo chrt -m</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上面这句命令可以显示所有可用的调度策略和优先级</span></span><br></pre></td></tr></table></figure>
<h2 id="进程和CPU的关系"><a href="#进程和CPU的关系" class="headerlink" title="进程和CPU的关系"></a>进程和CPU的关系</h2></li>
<li>将一个进程<strong>绑定到一个特定的CPU</strong><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskset -cp &lt;cpuID&gt; pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">taskset -cp &lt;cpu-list&gt; pid</span><br><span class="line"><span class="meta">#</span><span class="bash">其中cpu-list是数字化的cpu列表，从1开始。多个不连续的cpu可用逗号连接，连续的可用短现连接，比如1,2,5-11等</span></span><br></pre></td></tr></table></figure></li>
<li>pid是需要改变的进程的ID，cpuID是需要绑定的CPU核心id</li>
<li>或者使用掩码的方式设置</li>
<li><img src="/imgs/0cfa0cc9aca9dff9463ac3fba1b77e33b5665391b94f2619d1de822e3bffe170.png" alt="picture 10">  </li>
<li><code>taskset -a -p &lt;掩码&gt; &lt;pid&gt;</code></li>
<li>在C程序中将进程绑定到某个特定的CPU<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> cpuset;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpuset); <span class="comment">// 初始化CPU集合，将cpuset置为空</span></span><br><span class="line">    CPU_SET(<span class="number">2</span>, &amp;cpuset); <span class="comment">// 将本进程绑定到CPU2上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进程的CPU亲和性</span></span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(cpuset), &amp;cpuset) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Set CPU affinity failed, error: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线程绑定到某个CPU</li>
<li><img src="/imgs/1ce1b4c75e20f9482db83cc3d39e3a3bf047e26402a4a02a4055f9cf245bcda1.png" alt="picture 9">  </li>
<li>Linux中线程可以在<strong>不同CPU核心之间来回移动</strong></li>
<li>中断也可以设置CPU亲和性</li>
<li><img src="/imgs/03d15d76a02662434d9b644221a6ac7595a4fb4eae20f7aeca23f736e252ac41.png" alt="picture 11">  </li>
<li><img src="/imgs/35da23818b21302c1fc698e039136553e68132522f0a0c7028363502f2833ae3.png" alt="picture 12">  <ul>
<li>上述补丁的意义是将软中断负载均衡到每个核心<h3 id="进程群"><a href="#进程群" class="headerlink" title="进程群"></a>进程群</h3></li>
</ul>
</li>
<li><img src="/imgs/f782a4c045a95c3e4365f2f93ad2916a2198af3e6f24b8e88f0b5b8e458381ec.png" alt="picture 13">  </li>
<li>设置进程群的CPU使用比率，先调度进程群，再调度其中的进程</li>
<li>现决定一个进程群内部所有进程能用的所有CPU时间，再考虑分配给谁<h4 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h4></li>
<li>进入<code>/sys/fs/cgroup/cpu/</code>下创建目录dir</li>
<li><img src="/imgs/7898a3b15778e0c7dee719faad1c26e8aaba7dca33cf1640144f0778088d39e6.png" alt="picture 14">  </li>
<li>进入创建的目录查看<code>cpu.shares</code>权重</li>
<li>添加某个进程到进程组<ul>
<li>将进程的pid添加到<code>cgroup.procs</code>文件中</li>
</ul>
</li>
<li><code>cpu.cfs_period_us</code>和<code>cpu.cfs_quota_us</code>是一个进程组中的<code>cfs</code>进程在一个<code>period</code>范围内能运行最多<code>quota</code>微秒</li>
<li>quota可以大于period，因为是多核的，可以设置为period*核心数</li>
</ul>
<h2 id="硬实时"><a href="#硬实时" class="headerlink" title="硬实时"></a>硬实时</h2><ul>
<li>从创建一个任务到他开始被调度，<strong>不会超过一个截止期限</strong></li>
<li>Linux是一个软实时的系统，因此可能会超过这个时间</li>
<li>Linux无法实现硬实时</li>
<li><img src="/imgs/8f26b7f5a54a75857d69e1a46eb2a59e279d3055747f756438e50bb3df84b6c8.png" alt="picture 15">  <ul>
<li>Linux下假如你休眠10ms，因为Linux的调度抖动，可能会导致进程就绪之后无法被调度，因此两次调度会间隔大于10ms，会随着系统负载变大而延迟变大，具有不确定性<h3 id="Linux不可调度区域"><a href="#Linux不可调度区域" class="headerlink" title="Linux不可调度区域"></a>Linux不可调度区域</h3></li>
</ul>
</li>
<li><img src="/imgs/7630501f02899c084a7aa457b2e87602d66bc044ac3df2b080783619a6035bda.png" alt="picture 16">  <ul>
<li>打上硬实时补丁之后可以进一步减小不可调度的范围，将系统变为硬实时的</li>
</ul>
</li>
<li><img src="/imgs/734ab76e71cd209c5093076f5ab83c6b02c7436c08fc6eee5129b3268a8f67a6.png" alt="picture 17">  <ul>
<li>中断，软中断和自旋锁执行时都不能被调度，不能被抢占</li>
<li>一个CPU拿到spin lock的时候，这个核心就不能被调度了</li>
<li>软中断中可以嵌套中断，硬中断不行</li>
<li>如果需要抢占的任务发生在上述三种情况中，则只能在上述三种状态执行结束的瞬间立即抢占</li>
</ul>
</li>
<li><img src="/imgs/35e248271e574e99ab1f8e2014bec3b82ead40d3c781c076a90d9bdbf49383b5.png" alt="picture 18">  <ul>
<li>因为当一个进程占有不可打断的任务的时候，中断无法抢占他导致中断被延迟处理，不满足实时性，延迟的长度是橙色箭头<h3 id="实时补丁"><a href="#实时补丁" class="headerlink" title="实时补丁"></a>实时补丁</h3></li>
</ul>
</li>
<li><img src="/imgs/1bccc755a6bcbbc6dd504edbce907725eec3277907078ce77435e412588352e6.png" alt="picture 19">  </li>
<li>preempt_rt补丁</li>
<li>第四个选项就是完全硬实时补丁的选项<h4 id="自旋锁和互斥锁的区别"><a href="#自旋锁和互斥锁的区别" class="headerlink" title="自旋锁和互斥锁的区别"></a>自旋锁和互斥锁的区别</h4></li>
<li>自旋锁是CPU一个核心拿到锁，开始处理，另一个核心拿不到则原地自旋</li>
<li>互斥锁是一个进程拿到锁开始执行，另一个线程没拿到，则睡眠直到上一个进程释放锁唤醒<h4 id="优先级继承"><a href="#优先级继承" class="headerlink" title="优先级继承"></a>优先级继承</h4></li>
<li>在低优先级的进程持有高优先级的进程试图获取的锁的时候，临时提高这个低优先级进程的优先级到跟高优先级进程一样，使得他能够在调度上获得优势从而赶快执行完，释放锁给高优先级进程使用，防止高优先级进程因为争抢锁等待低优先级进程<h2 id="Linux的进程调度策略"><a href="#Linux的进程调度策略" class="headerlink" title="Linux的进程调度策略"></a>Linux的进程调度策略</h2></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/541695664">进程调度参考1</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/550569525">进程调度参考2</a><h3 id="进程调度的基础知识"><a href="#进程调度的基础知识" class="headerlink" title="进程调度的基础知识"></a>进程调度的基础知识</h3></li>
<li>进程调度本身所需要的时间很短，基本就是更改一些寄存器等等，但是因为这个原因导致的上下文变化引起的CPU内部高速<strong>缓存的不命中</strong>可能在更大程度上导致程序执行时间受到影响</li>
<li>调度的基本单位是<strong>线程</strong></li>
<li><img src="/imgs/b1de16a877ef1fa3d2f3ef0f582de0ace62efe8b94cfccfcd5bda55e3c395054.png" alt="picture 0">  <ul>
<li>Linux内核的抢占设置</li>
<li>服务器一般讲究的是吞吐量而不是响应速度，但是桌面电脑和手机必须讲究响应速度否则导致卡顿</li>
<li>第一个的话操作系统几乎没有抢占调度</li>
<li>内核不能被抢占</li>
<li>第三个内核也可以被抢占</li>
</ul>
</li>
<li>进程的特性<ul>
<li>CPU消耗型和IO消耗型</li>
<li>IO消耗型任务得到CPU要求的较为<strong>及时</strong>，因为不及时的话会导致IO速度下降，用户体验下降，但是CPU<strong>性能对其影响不大</strong><h3 id="早期调度器设计"><a href="#早期调度器设计" class="headerlink" title="早期调度器设计"></a>早期调度器设计</h3></li>
</ul>
</li>
<li><img src="/imgs/6466a27a813f7ac6570e339fa50e595246888c1b4faf2e413d5b34b3186e0fbb.png" alt="picture 2">  </li>
<li>内核优先级0-139，内核数字越小优先级越高</li>
<li>0-99算是实时线程，99-139是非实时线程，<strong>0-99之间的数字越大优先级越高</strong>，内核实际计算的时候是<u>99-用户设置的优先级</u></li>
<li>调度看的就是从高优先级到低优先级，谁先有进程就绪就调度谁</li>
<li>优先级高的进程可以抢占优先级低的进程</li>
<li><img src="/imgs/1b51495c4a2e463b8be8db7f8ec302a929e37c4c36d7809e3ffd5763fddbb0b5.png" alt="picture 3">  </li>
<li>以上是优先级再0-99期间的进程的调度策略，二者的区别是FIFO同等优先级是<strong>先进先出</strong>，RR是<strong>时间片轮转方式</strong>（同等优先级）</li>
<li><u>所有前面的进程都跑完了，<strong>才会跑100-139的进程</strong></u></li>
<li>普通进程的优先级是<code>nice</code>，也就是-20-19，值越大优先级越低</li>
<li>普通进程优先级高不会形成对低优先级的绝对优势</li>
<li>前面<strong>不会堵着</strong>后面</li>
<li><img src="/imgs/6ef88985eeca2da2eed21858d7725f50a80216dc31949964cbb977c125b8dd3e.png" alt="picture 4">  <ul>
<li><strong>RT的门限</strong>：上面一条设置的是实时进程在一个sched_rt_period中能运行的最多时间是sched_rt_runtime</li>
<li>因此，在一些情况下猛然将一个进程从普通进程转换为实时进程可能导致<strong>进程运行速度下降</strong>，因为实时进程的运行时间比率是有限的，但是<strong>普通进程没有这个限制</strong></li>
<li>但是可能会导致<strong>系统运行明显卡顿</strong>，因为实时进程的优先级太高了，比很多系统进程优先级都高</li>
<li>RT类型的进程应该尽可能的小<h3 id="CFS调度算法（也就是所谓的OTHER调度算法）"><a href="#CFS调度算法（也就是所谓的OTHER调度算法）" class="headerlink" title="CFS调度算法（也就是所谓的OTHER调度算法）"></a>CFS调度算法（也就是所谓的OTHER调度算法）</h3></li>
</ul>
</li>
<li>针对<strong>非实时进程</strong>的调度算法，<strong>实时进程的优先级是大于这些进程的</strong></li>
<li>追求的是每个进程的vruntime接近</li>
<li><strong>线程才有nice，线程是调度单位</strong>，进程资源分配单位（不包括CPU）</li>
<li>默认的线程的nice是0</li>
<li>无法设置进程是IO消耗还是CPU消耗</li>
<li><img src="/imgs/5f2fffda16e9a46bb031d3e073895e3fb251b4ea245f6c751cde068ddcea59c1.png" alt="picture 5">  </li>
<li>CFS能在真实硬件上模拟出一种“公平的、精确的任务多处理CPU”</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/372441187">参考</a></li>
<li>vruntime += 实际运行时间(time process run) * 1024 / 进程权重(load weight of this process)<ul>
<li><img src="/imgs/60deded430df972428f4b32678ec2a4f32bef2fc89a4e69d60575fc08e19acf9.png" alt="picture 6">  </li>
</ul>
</li>
<li>调度的是<strong>虚拟运行时间最短的进程</strong>（利用红黑树排序）</li>
<li>vruntime并不是无限小的，有一个最小值来限定。假如新进程的vruntime初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了</li>
<li>每个CPU的运行队列cfs_rq都维护一个min_vruntime字段，记录该运行队列中所有进程的vruntime最小值，新进程的初始vruntime值就以它所在运行队列的min_vruntime为基础来设置，与老进程保持在合理的差距范围内</li>
<li>唤醒抢占<ul>
<li>休眠进程在<strong>唤醒时会获得vruntime的补偿</strong>，它在醒来的时候有能力<strong>抢占CPU</strong>是大概率事件，这也是CFS调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠<h3 id="调度API"><a href="#调度API" class="headerlink" title="调度API"></a>调度API</h3></li>
</ul>
</li>
<li><img src="/imgs/a63520a86097fd5338f11cf3a9f79afd7e95ee1fdadd703e7c1126e17c072798.png" alt="picture 7">  </li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Jetson不能用网线连接电脑网络的解决方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/09/18/Jetson%E4%B8%8D%E8%83%BD%E7%94%A8%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"
    >Jetson不能用网线连接电脑网络的解决方法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/09/18/Jetson%E4%B8%8D%E8%83%BD%E7%94%A8%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2023-09-18T02:37:20.000Z" itemprop="datePublished">2023-09-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ul>
<li>有时候使用网线将Jetson插到电脑上之后并不能有效的链接jetson和电脑</li>
<li>此时是因为jetson的网络接口不能上网导致的</li>
<li>需要在网络设置中修改jetson对应的以太网接口的设置</li>
<li><img src="/imgs/f560574cd753800eaebac407879a908f7c87fd151da78f60359658a2a5da0423.png" alt="picture 0">  <ul>
<li>打开自己电脑访问网络的渠道（比如WLAN）</li>
<li>设置属性</li>
<li>打开共享</li>
<li>将其与jetson连接的网络端口共享即可</li>
</ul>
</li>
<li>可能还需要重启jetson的网络配置<code>sudo service network-manager restart</code></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2024
        <i class="ri-heart-fill heart_icon"></i> FrankZhang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.png" alt="Frank’s blogs"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>