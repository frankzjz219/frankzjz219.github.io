<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/rPi.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/rPi.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/rPi.png">
  <link rel="mask-icon" href="/images/rPi.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"frankzjz219.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Frank&#39;s blogs">
<meta property="og:url" content="https://frankzjz219.github.io/page/9/index.html">
<meta property="og:site_name" content="Frank&#39;s blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FrankZhang">
<meta property="article:tag" content="C, C++, Leetcode, Linux, 嵌入式, Ununtu, 驱动">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://frankzjz219.github.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Frank's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Frank's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">永远好奇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/frankzjz219" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/29/%E5%B0%8F%E7%A9%BA%E9%97%B4%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/%E5%B0%8F%E7%A9%BA%E9%97%B4%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1/" class="post-title-link" itemprop="url">小空间词频统计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-29 12:56:52" itemprop="dateCreated datePublished" datetime="2022-08-29T12:56:52+08:00">2022-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="大数据问题的一般思路"><a href="#大数据问题的一般思路" class="headerlink" title="大数据问题的一般思路"></a>大数据问题的一般思路</h2><ul>
<li><img src="/imgs/de52034f9740d556c3569a224bb4bc6ba1d9926fdec348c89cfb28b7d82fd640.png" alt="图 9">  <h2 id="利用位数组"><a href="#利用位数组" class="headerlink" title="利用位数组"></a>利用位数组</h2></li>
<li>利用基础类型（比如int）制作一个bit数组</li>
<li>比如一个int是32位，那么10个int就是320位的位数组</li>
<li>利用<u>每个位的1和0</u>计数数字的存在与否<h2 id="小空间词频统计"><a href="#小空间词频统计" class="headerlink" title="小空间词频统计"></a>小空间词频统计</h2></li>
<li>假如用一个小空间计算40亿个数字中<code>unsigned int</code>中的<u>哪个不包括在内</u><ul>
<li>先申请允许内存大小的数组，检查系统内存能够允许的数组长度，找<u>最近的长度为2的整数幂次</u>的数组长度作为长度</li>
<li>然后按照数组的长度均分<code>unsigned int</code>范围得到小的范围长度</li>
<li>遍历整个数组，每个元素除以小范围的长度，结果向下取整得到自己属于哪个小范围</li>
<li>将词频数组对应的index位置（上一步计算的结果）<code>+1</code></li>
<li>循环一遍之后，词频数组中肯定有某个位置的词频达不到理论上的小范围长度</li>
<li>将整个统计范围的长度从整个<code>unsigned int</code>范围调整到上一个词频达不到满的小范围</li>
<li><u>重复上述步骤</u>遍历整个数据，丢弃所有不在范围内的数字，其他数字按照第二次划分的小范围分类，统计结束之后再看哪个位置的词频达不到此时的小范围</li>
</ul>
</li>
<li>统计巨量URL的访问次数<ul>
<li>使用哈希函数将URL转换，然后分流到一定数量（按照服务器的内存资源决定）的小文件中，每个小文件使用一个利用<u>URL被访问次数</u>组织的大根堆</li>
<li>将每个大根堆的堆顶组织成大根堆得到总堆</li>
<li>结果就是依次将内容从总堆中弹出，弹出之后找到这个元素原来所在的大根堆，同样将这个元素弹出，然后弹出后的大根堆的头部放入总大根堆中。</li>
</ul>
</li>
<li>利用位数组统计出现了两次的数字<ul>
<li>用<strong>两位</strong>表示一个数字是否出现过</li>
<li><code>00</code>没出现过，<code>01</code>出现一次，<code>10</code>出现两次，<code>11</code>出现大于2次</li>
</ul>
</li>
<li>利用小空间找<strong>中位数</strong><ul>
<li>同样利用小范围词频统计（第一种）操作</li>
<li>统计到找出中位数在哪个小分区里</li>
<li>然后对这个对应的小分区再等分找到具体的中位数的位置<h2 id="小空间给大数组"><a href="#小空间给大数组" class="headerlink" title="小空间给大数组"></a>小空间给大数组</h2></li>
</ul>
</li>
<li>方法一<ul>
<li>小空间使用小根堆</li>
<li>小根堆存储的内容是&lt;数字，出现次数&gt;的元组，有小根堆中存在的数字的时候，相应的出现次数+1</li>
<li>小根堆不能直接用一条记录的空间计算，<u>需要考虑一些额外的开销</u>，实际可用的空间可能是总空间/16或者其他数值</li>
<li>堆的大小用最接近的2的整数次幂次</li>
<li>然后按照被排序的内容/堆的大小得到被排序内容按大小分的小段</li>
<li>第一次处理落在最小部分段内的数据，第二次处理第二小部分段内的数据…</li>
<li>都处理完即可得到所有排序</li>
</ul>
</li>
<li>方法二<ul>
<li>使用一个大根堆存储此时数组中最小的几种数字</li>
<li>假如此时一个新的数字小于此时大根堆中最大的数字，那么可以加入</li>
<li>假如这个数字比大根堆中最大的数字还大，那么说明这个数字不属于整个数组中最小的k个数字之一，直接忽略（k为堆的大小）</li>
<li>假如此时大根堆的数字超出数字限制，那么将最大的数字弹出然后将新的数字压入</li>
<li>然后将大根堆内的所有数字逆序排出并清空堆，然后给堆设置最小值，等于上次弹出之前堆中最大的数字，以后只考虑大于这个数字的数</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/29/Morris%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/Morris%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">Morris遍历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-29 10:50:15" itemprop="dateCreated datePublished" datetime="2022-08-29T10:50:15+08:00">2022-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Morris遍历细节"><a href="#Morris遍历细节" class="headerlink" title="Morris遍历细节"></a>Morris遍历细节</h2><ul>
<li><img src="/imgs/da93ce774972f0e9d9f5fed4f9038f8fe80708e3395fa90c87058ef38ced2d57.png" alt="图 8">  </li>
<li>传统遍历方法的空间复杂度是O(树的高度)</li>
<li>利用底层叶节点的空指针节省空间</li>
<li>假如不允许修改题目给出的树就没法使用Morris遍历</li>
<li>Morris遍历对于所有有左子树的节点都能到达两次</li>
<li>一个节点指针来到他的右子树之后就不会再次返回这个节点了<ul>
<li>判断第几次到达一个节点？</li>
<li>根据左子树上最右节点的右指针指向谁，假如指向自己，那就是第二次到达<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morris</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;<span class="comment">// z有左孩子否则直接退回大循环</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123; <span class="comment">// 找左树上的最右节点，右孩子不能等于当前节点</span></span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;<span class="comment">// 第一次来到cur</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;<span class="comment">//向左子树发展</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;<span class="comment">// 第二次来到cur</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;<span class="comment">// 向右树移动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>时间复杂度: O(N)<h2 id="Morris遍历改为先序遍历："><a href="#Morris遍历改为先序遍历：" class="headerlink" title="Morris遍历改为先序遍历："></a>Morris遍历改为先序遍历：</h2></li>
<li>如果一个节点<strong>只能到达一次</strong>，直接打印内容</li>
<li>如果可以到达<strong>两次</strong>，第一次打印<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;<span class="comment">// 有左子树</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;<span class="comment">// 第一次来到这个节点</span></span><br><span class="line">                System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 第二次来，不打印</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 没有左子树</span></span><br><span class="line">            System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2></li>
<li>只经过一次的节点：直接输出</li>
<li>两次的节点：第二次经过的时候打印<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;<span class="comment">// 第一次经过会跳过打印</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跟原本代码唯一的区别就是此处加一个打印</span></span><br><span class="line">        System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Morris后序遍历"><a href="#Morris后序遍历" class="headerlink" title="Morris后序遍历"></a>Morris后序遍历</h2></li>
<li>将打印的时机安排在一个能回到自己两次的节点第二次被经过的时候</li>
<li>第二次回到自己的时候<u>逆序打印自己左树的右边界</u></li>
<li>整个过程结束之后<u>逆序打印整棵树的右边界</u><h3 id="逆序遍历如何实现"><a href="#逆序遍历如何实现" class="headerlink" title="逆序遍历如何实现"></a>逆序遍历如何实现</h3></li>
<li>借用单链表逆序遍历的操作</li>
<li>指针逆序之后，打印然后再调整回去<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                printEdge(cur.left);<span class="comment">// 第二次经过的时候逆序打印左树的右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    printEdge(head);<span class="comment">// 整个结束之后逆序打印整棵树的右边界</span></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node head)</span> </span>&#123;<span class="comment">// 打印然后再逆序回去</span></span><br><span class="line">    Node tail = reverseEdge(head);</span><br><span class="line">    Node cur = tail;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseEdge(tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseEdge</span><span class="params">(Node from)</span> </span>&#123;<span class="comment">// 单链表的逆序操作</span></span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (from != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = from.right;</span><br><span class="line">        from.right = pre;</span><br><span class="line">        pre = from;</span><br><span class="line">        from = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/28/%E5%8D%95%E8%B0%83%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/28/%E5%8D%95%E8%B0%83%E6%A0%88/" class="post-title-link" itemprop="url">单调栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-28 21:32:21" itemprop="dateCreated datePublished" datetime="2022-08-28T21:32:21+08:00">2022-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>了解数组中的一个数，左边最近的比这个数大的数，和右边最近的比这个数大的数在哪</li>
<li>在一维数组中对每一个数找到<strong>第一个比自己小的元素</strong>。这类“<strong>在一维数组中找第一个满足某种条件的数</strong>”的场景就是典型的单调栈应用场景<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="无重复数字"><a href="#无重复数字" class="headerlink" title="无重复数字"></a>无重复数字</h3></li>
<li>求某个数字附近最近的比他大的数字：<ul>
<li>使用一个栈，这个栈从下到上是由大到小的顺序</li>
<li>新加入的数字符合单调性？直接加入</li>
<li>不符合单调性？弹出栈顶的数字，此时记录，对于被弹出的这个数字而言：<ul>
<li>左边最近的比他大的数字就是弹出这个数字之后的栈顶元素</li>
<li>右边最近的比他大的数字就是正要进栈的数字</li>
<li>直到符合单调性为止</li>
</ul>
</li>
<li>最后结束的时候栈中还有数据怎么办？<ul>
<li>栈中剩余的所有数据的右边最近比他大的数字都是无</li>
<li>左边最近的比他大的数字都是他在栈中的下一个元素</li>
<li>栈底的最后一个元素左右都是无<h3 id="有重复数字"><a href="#有重复数字" class="headerlink" title="有重复数字"></a>有重复数字</h3></li>
</ul>
</li>
</ul>
</li>
<li>栈中放的内容都是链表，每个位置链表结点存放index</li>
<li>弹出的时候，右边最近比他大的数字是当前等待进栈的数字，左边最近的比他大的数字是栈中下面紧邻位置链表的最后一个位置</li>
<li>同样数字进栈的时候，将同样的数字对应的index串联在进栈位置链表的下一个位置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getNearLessNoRepeat(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 只存位置！</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 当遍历到i位置的数，arr[i]</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek()] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            res[j][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">            res[j][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        res[j][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">        res[j][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getNearLess(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">    Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123; <span class="comment">// i -&gt; arr[i] 进栈</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="number">0</span>)] &gt; arr[i]) &#123;</span><br><span class="line">            List&lt;Integer&gt; popIs = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Integer popi : popIs) &#123;</span><br><span class="line">                res[popi][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">                res[popi][<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; arr[stack.peek().get(<span class="number">0</span>)] == arr[i]) &#123;</span><br><span class="line">            stack.peek().add(Integer.valueOf(i));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(i);</span><br><span class="line">            stack.push(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; popIs = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> leftLessIndex = stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer popi : popIs) &#123;</span><br><span class="line">            res[popi][<span class="number">0</span>] = leftLessIndex;</span><br><span class="line">            res[popi][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-739-每日温度"><a href="#Leetcode-739-每日温度" class="headerlink" title="Leetcode 739.每日温度"></a>Leetcode 739.每日温度</h2><ul>
<li><p>单调栈解法</p>
</li>
<li><p>可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
</li>
<li><p>正向遍历温度列表。对于温度列表中的每个元素<code> temperatures[i]</code>，如果栈为空，则直接将 <code>i</code> 进栈，如果栈不为空，则比较栈顶元素 <code>prevIndex</code> 对应的温度 <code>temperatures[prevIndex]</code> 和当前温度 <code>temperatures[i]</code>，如果 <code>temperatures[i]</code> &gt; <code>temperatures[prevIndex]</code>，则将 <code>prevIndex</code> 移除，并将 <code>prevIndex</code> 对应的等待天数设为 <code>i - prevIndex</code>，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> previousIndex = s.<span class="built_in">top</span>();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-155-最小栈"><a href="#Leetcode-155-最小栈" class="headerlink" title="Leetcode 155.最小栈"></a>Leetcode 155.最小栈</h2><ul>
<li><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中</p>
</li>
<li><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出</p>
</li>
<li><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; x_stack;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; min_stack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_stack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">push</span>(x);</span><br><span class="line">        min_stack.<span class="built_in">push</span>(<span class="built_in">min</span>(min_stack.<span class="built_in">top</span>(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">pop</span>();</span><br><span class="line">        min_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode-84-柱状图中最大的矩形"><a href="#Leetcode-84-柱状图中最大的矩形" class="headerlink" title="Leetcode 84. 柱状图中最大的矩形"></a>Leetcode 84. 柱状图中最大的矩形</h2><ul>
<li>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 <code>h</code>。换句话说，我们需要找到左右两侧最近的高度小于 <code>h</code> 的柱子，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于 <code>h</code>，并且就是 <code>i</code> 能够扩展到的最远范围。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; mono_stack; <span class="comment">// 找左侧比较小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (mono_stack.<span class="built_in">empty</span>() ? <span class="number">-1</span> : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mono_stack = stack&lt;<span class="keyword">int</span>&gt;();<span class="comment">// 找右侧比较小的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mono_stack.<span class="built_in">empty</span>() &amp;&amp; heights[mono_stack.<span class="built_in">top</span>()] &gt;= heights[i]) &#123;</span><br><span class="line">                mono_stack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            right[i] = (mono_stack.<span class="built_in">empty</span>() ? n : mono_stack.<span class="built_in">top</span>());</span><br><span class="line">            mono_stack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;<span class="comment">// 根据左侧和右侧比较小的元素的位置计算出不小于当前竖条宽度的面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/28/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">滑动窗口问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-28 19:26:32" itemprop="dateCreated datePublished" datetime="2022-08-28T19:26:32+08:00">2022-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="leetcode-76-最小覆盖字串"><a href="#leetcode-76-最小覆盖字串" class="headerlink" title="leetcode 76.最小覆盖字串"></a>leetcode 76.最小覆盖字串</h2><ul>
<li>begin从0开始，end从-1开始</li>
<li>注意<code>vector&lt;&gt;.size()</code>返回的是无符号整数</li>
<li>不能直接与int比较大小，尤其是存在负数的情况</li>
<li>假如窗口的下一个元素是目标字符串中的</li>
<li>先把下一个加入窗口</li>
<li>假如此时需要的字符数量超过了目标字符串的数量</li>
<li>试图前移开头，删除元素直到没有窗口中没有多余的字母为止</li>
<li>注意， <strong>假如此时窗口中的该字符数量已经超过了需要的该字符数量</strong>，那就不能再增加已经cover的字符计数了，否则会导致错误<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; um, uTarget;</span><br><span class="line">        <span class="keyword">int</span> covered = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;t.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            um[t[i]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!uTarget.<span class="built_in">count</span>(t[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                uTarget[t[i]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++uTarget[t[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> minBegin = <span class="number">0</span>, minEnd = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;end&lt;&lt;&quot;|&quot;&lt;&lt;n-1&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">while</span>(end&lt;(n<span class="number">-1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&#x27;@&#x27;&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(um.<span class="built_in">count</span>(s[end+<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(um[s[end+<span class="number">1</span>]]&gt;=uTarget[s[end+<span class="number">1</span>]])</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ++covered;</span></span><br><span class="line">                    ++um[s[++end]];</span><br><span class="line">                    <span class="keyword">while</span>(begin&lt;end&amp;&amp;((!um.<span class="built_in">count</span>(s[begin]))||(um[s[begin]]&gt;uTarget[s[begin]])))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// cout&lt;&lt;&#x27;!&#x27;;</span></span><br><span class="line">                        <span class="keyword">if</span>(um.<span class="built_in">count</span>(s[begin]))</span><br><span class="line">                        &#123;</span><br><span class="line">                            --um[s[begin]];</span><br><span class="line">                            <span class="comment">// --covered;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        ++begin;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ++covered;</span><br><span class="line">                    ++um[s[++end]];</span><br><span class="line">                    <span class="keyword">while</span>((begin&lt;end)&amp;&amp;((um.<span class="built_in">count</span>(s[begin]) == <span class="number">0</span>)||(um[s[begin]]&gt;uTarget[s[begin]])))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// cout&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(um.<span class="built_in">count</span>(s[begin]))</span><br><span class="line">                        &#123;</span><br><span class="line">                            --um[s[begin]];</span><br><span class="line">                            <span class="comment">// --covered;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        ++begin;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++end;</span><br><span class="line">            <span class="keyword">if</span>(covered&gt;=t.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(end-begin+<span class="number">1</span>&lt;=minLen)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;&quot;@&quot;&lt;&lt;endl;</span></span><br><span class="line">                    minBegin = begin;</span><br><span class="line">                    minEnd = end;</span><br><span class="line">                    minLen = end-begin+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;s.substr(begin, end-begin+1)&lt;&lt;(end-begin+1)&lt;&lt;&#x27;|&#x27;&lt;&lt;covered&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(covered&gt;=t.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s.<span class="built_in">substr</span>(minBegin, minLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode-3-无重复字符的最长子串"><a href="#leetcode-3-无重复字符的最长子串" class="headerlink" title="leetcode 3.无重复字符的最长子串"></a>leetcode 3.无重复字符的最长子串</h2></li>
<li>使用滑动窗口，假如前面没有重复字符的话就把滑动窗口的后边缘往前移，假如有的话就把前边缘往前移到不重复为止<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;=<span class="number">1</span>)<span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startInd = <span class="number">0</span>, endInd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(m.<span class="built_in">count</span>(s[endInd+<span class="number">1</span>]) == <span class="number">0</span>||m[s[endInd+<span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++endInd;</span><br><span class="line">                m[s[endInd]] = <span class="number">1</span>;</span><br><span class="line">                maxLen = maxLen&gt;=(endInd - startInd+<span class="number">1</span>)?maxLen:(endInd - startInd+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(endInd == s.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> maxLen;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(m.<span class="built_in">count</span>(s[endInd+<span class="number">1</span>])&gt;<span class="number">0</span>&amp;&amp;m[s[endInd+<span class="number">1</span>]]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(m.<span class="built_in">count</span>(s[startInd]))</span><br><span class="line">                &#123;</span><br><span class="line">                    m[s[startInd]]-=<span class="number">1</span>;</span><br><span class="line">                    ++startInd;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><ul>
<li>一种两端都可以进出的数据结构<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2></li>
<li>保持双端队列的头部位置是窗口中最大的数字</li>
<li>窗口的运动是随意的，不是固定窗口大小的</li>
<li>将滑动窗口的右边界向右扩展的时候</li>
<li>双端队列中存储的是双端队列中数字的index，但是使用的是index对应的数字<ul>
<li>假如此时右边界新进入的数字比此时双端队列的末尾数字大的话就弹出此时双端队列末尾的数字，直到双端队列末尾的数字<strong>大于</strong>右边界新进入的数字（或者双端队列为空）。严格保证双端队列的单调性。</li>
<li>假如此时窗口的左边界向右移动导致窗口内有数字被移出窗口，那么此时将被移出窗口的数字与双端队列头部的数字（也就是此时窗口的最大值）比较，假如二者相同（是同一个index对应的数字），则弹出双端队列头部的数字，否则不管。</li>
<li>双端队列的信息实际上是<strong>假如此时滑动窗口的右边界不动，但是左边界前移，那么随着前移窗口中的最大值会是谁</strong></li>
<li> 实际上是用<u>下标大的大数字</u>替换<u>下标小的小数字</u><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2></li>
</ul>
</li>
<li><u>平均</u>每个时刻都是O(1)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMaxWindow(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> w) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || w &lt; <span class="number">1</span> || arr.length &lt; w) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// qmax 窗口最大值的更新结构</span></span><br><span class="line">    <span class="comment">// 放下标</span></span><br><span class="line">    LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> R = <span class="number">0</span>; R &lt; arr.length; R++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[qmax.peekLast()] &lt;= arr[R]) &#123;</span><br><span class="line">            qmax.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        qmax.addLast(R);</span><br><span class="line">        <span class="keyword">if</span> (qmax.peekFirst() == R - w) &#123;</span><br><span class="line">            qmax.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (R &gt;= w - <span class="number">1</span>) &#123;</span><br><span class="line">            res[index++] = arr[qmax.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode-220-存在重复元素III"><a href="#leetcode-220-存在重复元素III" class="headerlink" title="leetcode 220. 存在重复元素III"></a>leetcode 220. 存在重复元素III</h2></li>
<li>注意需要维护的是一个滑动窗口中的所有元素的排列，要能<strong>迅速找到最小值和最大值，同时可以任意删除任何一个元素</strong>，使用cpp的<strong>有序集合</strong><code>set</code>实现<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = rec.<span class="built_in">lower_bound</span>(<span class="built_in">max</span>(nums[i], INT_MIN + t) - t);</span><br><span class="line">            <span class="keyword">if</span> (iter != rec.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= <span class="built_in">min</span>(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                rec.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>注意有序集合查找最小值和最大值的方法是<code>lower_bound</code>函数</li>
<li><code>set::lower_bound()</code> 是 C++ STL 中的一个内置函数，用于在集合中查找一个元素。它返回一个迭代器，指向集合中<strong>第一个大于等于指定值的元素</strong>。如果指定值大于集合中的最大值，则返回指向集合末尾的迭代器。该函数的时间复杂度为 O(logn)，其中 n 是集合的大小。</li>
</ul>
<h2 id="leetcode-209-长度最小的子数组"><a href="#leetcode-209-长度最小的子数组" class="headerlink" title="leetcode 209. 长度最小的子数组"></a>leetcode 209. 长度最小的子数组</h2><ul>
<li>此题因为必须是连续数组，而且是求和，因此考虑使用滑动窗口的方法解决<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = INT_MAX;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;start&lt;&lt;&#x27; &#x27;&lt;&lt;end&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(sum&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(end == nums.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">                ++end;</span><br><span class="line">                sum+=nums[end];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(end-start+<span class="number">1</span>&lt;minLen)</span><br><span class="line">                &#123;</span><br><span class="line">                    minLen = end - start+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum-=nums[start];</span><br><span class="line">                ++start;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(end&lt;nums.<span class="built_in">size</span>() &amp;&amp; end&gt;=start);</span><br><span class="line">        <span class="keyword">return</span> minLen == INT_MAX?<span class="number">0</span>:minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/28/manacher%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/28/manacher%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">manacher算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-28 10:50:13" itemprop="dateCreated datePublished" datetime="2022-08-28T10:50:13+08:00">2022-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ul>
<li>字符串的最长回文字串的问题（必须是连续的串）<h2 id="获得长度为奇数和偶数的字符串"><a href="#获得长度为奇数和偶数的字符串" class="headerlink" title="获得长度为奇数和偶数的字符串"></a>获得长度为奇数和偶数的字符串</h2></li>
<li>奇数的话直接取每个字符向两边找扩展即可</li>
<li>针对偶数可以在每两个字符之间<strong>加入一个虚拟的字符</strong>，向左右两边扩展得到偶数长度的回文字符串</li>
<li><img src="/imgs/87935e4d8a92e959ccda8401cf31306762c0fe8418854a1eef92f8d09ee30dba.png" alt="图 2">  </li>
<li>将处理得到的字符串的长度直接/2就可以得到实际的回文串的长度</li>
<li>虚拟的字符可以是任意字符，即使是原串之中出现过的字符也可以</li>
<li>时间复杂度是<code>O(N^2)</code><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2></li>
<li>时间复杂度是<code>O(N)</code></li>
<li>概念<ul>
<li>回文直径和半径</li>
<li><img src="/imgs/18ab4a39c4e691caf0301e6d309f1ff2c97f2fb100da73a20f5b55752ccd9afe.png" alt="图 3">  </li>
<li>回文直径7半径4</li>
<li>生成一个<code>回文半径数组</code></li>
<li>之前扩展的所有位置中所到达过的回文最右边界，初始值是-1</li>
<li>取得最远边界的时候的中心点的位置，与上一条同时更新</li>
</ul>
</li>
<li>方法：<ul>
<li>假如此时index没在最右回文右边界之内，直接向两边暴力计算即可</li>
<li>假如在最右边界之内：<ul>
<li>中心点一定在index的左侧</li>
<li><img src="/imgs/694a11a5b4ed6114a4bfcf85d8d329c4db097e451e269ac5dec433e70d29ecab.png" alt="图 4">  </li>
<li>C是此时的最右回文串的中心位置，L是左边界，R是右边界</li>
<li>i’是i关于C的对称点，根据i’的回文状况分类：<ul>
<li>假如i’的回文在L和R范围内（用回文半径数组得到）<ul>
<li>i位置和i’位置的回文半径相同</li>
</ul>
</li>
<li>假如i’的区域有一部分已经到L和R的外侧了<ul>
<li><img src="/imgs/8e9b9549693606dccff649bf276d88d81e1451e3599734737c1a69b5dcd84765.png" alt="图 5">  </li>
<li>此时i的答案是<strong>i到R的长度</strong></li>
</ul>
</li>
<li>假如i’的左边界正好在L上<ul>
<li><img src="/imgs/1e139074cc661226468bd6ddeddfc033b6f3ef39f085d9807868ff5839718773.png" alt="图 6">  </li>
<li>首先i’自身的回文半径<strong>一定是回文</strong>，从R外的第一个字符开始继续验证即可</li>
</ul>
</li>
</ul>
</li>
<li><img src="/imgs/d89728ae0ac3bc388471df7088a5aeafcae7c8c3bab4533dd11e7dce4d1e2e7d.png" alt="图 7">  <h2 id="manacher代码"><a href="#manacher代码" class="headerlink" title="manacher代码"></a>manacher代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">manacher</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &quot;12132&quot; -&gt; &quot;#1#2#1#3#2#&quot;</span></span><br><span class="line">    <span class="keyword">char</span>[] str = manacherString(s);</span><br><span class="line">    <span class="comment">// 回文半径的大小</span></span><br><span class="line">    <span class="keyword">int</span>[] pArr = <span class="keyword">new</span> <span class="keyword">int</span>[str.length];</span><br><span class="line">    <span class="keyword">int</span> C = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 讲述中：R代表最右的扩成功的位置</span></span><br><span class="line">    <span class="comment">// coding：最右的扩成功位置的，再下一个位置</span></span><br><span class="line">    <span class="keyword">int</span> R = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123; <span class="comment">// 0 1 2</span></span><br><span class="line">        <span class="comment">// R第一个违规的位置，i&gt;= R</span></span><br><span class="line">        <span class="comment">// i位置扩出来的答案，i位置扩的区域，至少是多大。</span></span><br><span class="line">        pArr[i] = R &gt; i ? Math.min(pArr[<span class="number">2</span> * C - i], R - i) : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + pArr[i] &lt; str.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i + pArr[i]] == str[i - pArr[i]])</span><br><span class="line">                pArr[i]++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + pArr[i] &gt; R) &#123;</span><br><span class="line">            R = i + pArr[i];</span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, pArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] manacherString(String str) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] charArr = str.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != res.length; i++) &#123;</span><br><span class="line">        res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">&#x27;#&#x27;</span> : charArr[index++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = manacherString(s);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> R = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; str.length &amp;&amp; str[L] == str[R]) &#123;</span><br><span class="line">            L--;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, R - L - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/27/%E8%81%94%E6%83%B3y7000%E7%AD%89%E5%90%8C%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91CPU%E8%A2%AB%E9%99%8D%E9%A2%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/27/%E8%81%94%E6%83%B3y7000%E7%AD%89%E5%90%8C%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91CPU%E8%A2%AB%E9%99%8D%E9%A2%91%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">联想y7000等同系列笔记本电脑CPU被降频以及蓝牙设置丢失解决办法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-27 20:48:22" itemprop="dateCreated datePublished" datetime="2022-08-27T20:48:22+08:00">2022-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 10:48:58" itemprop="dateModified" datetime="2022-08-30T10:48:58+08:00">2022-08-30</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>137</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="联想y7000等同系列笔记本电脑CPU被降频以及蓝牙设置丢失解决办法"><a href="#联想y7000等同系列笔记本电脑CPU被降频以及蓝牙设置丢失解决办法" class="headerlink" title="联想y7000等同系列笔记本电脑CPU被降频以及蓝牙设置丢失解决办法"></a>联想y7000等同系列笔记本电脑CPU被降频以及蓝牙设置丢失解决办法</h1><ul>
<li>CPU被降频为0.78或者CPU的占用封顶34%，同时没有任何风扇转动声音的情况</li>
<li>或者是蓝牙的设置直接丢失找不到，电脑失去蓝牙功能</li>
<li>拔掉电脑一些外设，包括电源线</li>
<li>关机</li>
<li>长按电脑开机键20-30s释放静电，再重启即可</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/26/KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/26/KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">KMP算法（子字符串快速匹配算法）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-26 21:44:42" itemprop="dateCreated datePublished" datetime="2022-08-26T21:44:42+08:00">2022-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><ul>
<li>求一个字符串是不是另一个字符串子串的问题</li>
<li>暴力方法是O(N*M)的复杂度<h3 id="最长前缀和后缀的匹配长度"><a href="#最长前缀和后缀的匹配长度" class="headerlink" title="最长前缀和后缀的匹配长度"></a>最长前缀和后缀的匹配长度</h3></li>
<li>一个字符位置存储的信息是匹配长度</li>
<li><img src="/imgs/2196bf830f7b5db687473c79422ad7dfdec5d981f834054f9ac75eda56f6f7a0.png" alt="图 10">  <ul>
<li>上图中前缀从最左算起，后缀从最右算起，等于3的时候相等</li>
<li>将这个信息记录在K这个字符的位置</li>
<li>这个长度必须小于整体的长度</li>
</ul>
</li>
<li>以上这个信息需要对str2（也就是<strong>较短的字符串</strong>）求的<ul>
<li><img src="/imgs/fb0d130530c2ce09057006d9d7424b35ea7456661bc3604cb0c91ef4823f5c67.png" alt="图 11">  </li>
<li>第一个是<code>-1</code>是人为定义的<h3 id="加速过程"><a href="#加速过程" class="headerlink" title="加速过程"></a>加速过程</h3></li>
</ul>
</li>
<li><img src="/imgs/a4b9841bb42c9a4e0047bfef0ba00cc98d660c07dc4212c2bd9f2dc4b2e584a5.png" alt="图 12">  <ul>
<li>当长字符串的匹配进行到x位置的时候发现匹配不能继续，假如此时短字符串的匹配进行到了y位置，那么<strong>不需要回退x</strong>，只需要回退y到<strong>最长前缀的末尾位置（图中画框的位置）</strong>，相当于不需要从头开始匹配，而是从<strong>图上的j位置（下标三角）开始</strong>，只需要通过最长前缀和后缀跳过长字符串和短字符串中<strong>已经匹配过的段</strong>，实际上相当于将短字符串直接<strong>后移到最长前缀的位置</strong>，然后继续匹配即可。</li>
<li> 另一个问题是从i到j位置之间不可能有任何一个位置能够配出短字符串</li>
</ul>
</li>
<li>举例</li>
<li><img src="/imgs/2809ae063ab9181ec086ffc99f622621c7cc923e0381e0a8ae7458c1d25dd66d.png" alt="图 13">  <ul>
<li>团上的行为是先从两个字符串的头位置开始比对两个字符串，然后到第一个字符串的e位置发现不对，然后寻找此时短字符串的w位置的最长前缀位置的下一个位置也就是t，但是t于e仍然不相等，那么就寻找t位置的最长前缀的下一个位置，也就是s与e比较，但是还不相等，那么就<strong>选择s位置的最长前缀的下一个位置</strong>是短字符串的开始位置，也不行，此时将长字符串的比较位置后移一位到e的下一个位置，重新开始比较<h3 id="如何求"><a href="#如何求" class="headerlink" title="如何求"></a>如何求</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span> <span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == s[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>j指向的是前缀末尾位置，初始化为0</li>
<li>i是后缀末尾位置，初始化为1</li>
<li>next数组第一个位置也初始化为0</li>
<li>如果i和j位置的字母不相等，那么j开始回退到上一个位置的前缀结束位置（相当于前缀长度减少了1）<ul>
<li>直到前缀和后缀字母相同的位置</li>
</ul>
</li>
<li>此时如果前后缀的最后一个位置字母相同，则给j的大小+1，因为相同的话后缀长度+1</li>
<li>然后将这个值赋给i位置（也就是当前后缀得末尾位置），记录下<strong>到这个位置的最长后缀长度</strong></li>
</ul>
<h3 id="Leetcode-28-找出字符串中第一个匹配项的下标"><a href="#Leetcode-28-找出字符串中第一个匹配项的下标" class="headerlink" title="Leetcode 28. 找出字符串中第一个匹配项的下标"></a>Leetcode 28. 找出字符串中第一个匹配项的下标</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jb411V78H/?share_source=copy_web&vd_source=e29d06662d9baca058bed682909766d6">讲解</a></li>
<li>注意比较的时候<ul>
<li>如果二者不相等，<strong>needle就按照<u>当前不匹配位置的前一个位置</u>的next表持续回退到起始或者相等</strong>，<em>使得前缀来到原来后缀的位置</em></li>
<li>如果相等，就二者一起前进一位</li>
<li>如果到达了needle的末尾，就认为是匹配到了，返回位置<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, needle);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/26/%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">并查集相关</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-26 20:52:15" itemprop="dateCreated datePublished" datetime="2022-08-26T20:52:15+08:00">2022-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%BE%E8%AE%BA%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF">参考链接</a></li>
<li>注意，实现的功能是添加<strong>边</strong>，将一条边两端的两个元素归为一个组合中的两个元素</li>
<li>在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根</li>
<li>在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; father = vector&lt;<span class="keyword">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u != father[u]) <span class="comment">// 如果自己不是根节点</span></span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 将自己的根节点直接改为最顶的根节点</span></span><br><span class="line">        father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-1971-寻找图中是否存在路径"><a href="#Leetcode-1971-寻找图中是否存在路径" class="headerlink" title="Leetcode 1971. 寻找图中是否存在路径"></a>Leetcode 1971. 寻找图中是否存在路径</h2><ul>
<li>此题的原理就是将所有的边加入并查集，最后查找二者是否对应同一个祖先<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">200005</span>; <span class="comment">// 节点数量 20000</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; father = vector&lt;<span class="keyword">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 并查集里寻根的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u);</span><br><span class="line">        v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">return</span> u == v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">        v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">        father[v] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPath</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSame</span>(source, destination);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-684-冗余连接"><a href="#Leetcode-684-冗余连接" class="headerlink" title="Leetcode 684. 冗余连接"></a>Leetcode 684. 冗余连接</h2><ul>
<li>此题同样是使用并查集</li>
<li>主要是在插入之前检测是否边两端的节点已经是一个集合中的了</li>
<li>如果不是的话就插入，是的话说明边是冗余的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1005</span>; <span class="comment">// 节点数量3 到 1000</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; father = vector&lt;<span class="keyword">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 并查集里寻根的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> u == father[u] ? u : father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u);</span><br><span class="line">        v = <span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">return</span> u == v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">        v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">        father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isSame</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>])) <span class="keyword">return</span> edges[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h2><ul>
<li>此题是找能将所有点联通的最小代价的所有路径</li>
<li>使用kruskal算法<ul>
<li>初始化一个并查集，最开始每个节点都是独立的</li>
<li>将所有路径加入一个代价从小到大的最小堆，每次取出一个路径</li>
<li>如果路径两端的点在一个集合中，则忽略，如果不在，则该路径是必须的路径，加入需要的路径集合中并且加入总代价中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u != father[u])</span><br><span class="line">    &#123;</span><br><span class="line">        father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(u) == <span class="built_in">find</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span>;</span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, e;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;e;</span><br><span class="line">    father = vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> edge&amp; a, <span class="keyword">const</span> edge&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// int conned = 1;</span></span><br><span class="line">    priority_queue&lt;edge, vector&lt;edge&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;e; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp.start&gt;&gt;tmp.end&gt;&gt;tmp.val;</span><br><span class="line">        pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="comment">// cout&lt;&lt;tmp.val&lt;&lt;endl;</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isSame</span>(tmp.start, tmp.end))</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=tmp.val;</span><br><span class="line">            <span class="built_in">join</span>(tmp.start, tmp.end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="41-岛屿数量（第四期模拟笔试）"><a href="#41-岛屿数量（第四期模拟笔试）" class="headerlink" title="41. 岛屿数量（第四期模拟笔试）"></a>41. 岛屿数量（第四期模拟笔试）</h2><ul>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1041">链接</a></li>
<li>此题是标准的并查集问题<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; father, <span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u!=father[u])</span><br><span class="line">    &#123;</span><br><span class="line">        father[u] = <span class="built_in">find</span>(father, father[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, vector&lt;<span class="keyword">int</span>&gt;&amp; father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(father, u) == <span class="built_in">find</span>(father, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">join</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; father, <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(father, u);</span><br><span class="line">    v = <span class="built_in">find</span>(father, v);</span><br><span class="line">    <span class="keyword">if</span>(u == v)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> father[v] = u;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, k;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">father</span><span class="params">(m*n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m*n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a&gt;=m || b&gt;=n || a&lt;<span class="number">0</span> || b&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!map[a][b]) ++cnt;</span><br><span class="line">        map[a][b] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> tmp = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">0</span> &amp;&amp; map[a<span class="number">-1</span>][b])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="built_in">join</span>(father, (a<span class="number">-1</span>)*m+b, a*m+b);</span><br><span class="line">            cnt-=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;<span class="number">0</span> &amp;&amp; map[a][b<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="built_in">join</span>(father, (a*m+b<span class="number">-1</span>), a*m+b);</span><br><span class="line">            cnt-=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;m<span class="number">-1</span> &amp;&amp; map[a+<span class="number">1</span>][b])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="built_in">join</span>(father, (a+<span class="number">1</span>)*m+b, a*m+b);</span><br><span class="line">            cnt-=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b&lt;n<span class="number">-1</span> &amp;&amp; map[a][b+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp =<span class="built_in">join</span>(father, a*m+b+<span class="number">1</span>, a*m+b);</span><br><span class="line">            cnt-=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;cnt&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/26/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/26/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" class="post-title-link" itemprop="url">一致性哈希</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-26 19:06:11" itemprop="dateCreated datePublished" datetime="2022-08-26T19:06:11+08:00">2022-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>760</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><ul>
<li><p>哈希函数的输入数据一般是<strong>巨量</strong>的，输出数据的的范围往往是<strong>有限</strong>的</p>
</li>
<li><p>哈希函数的输出存在<strong>均匀性</strong>，也就是无论输入是什么，输入是否接近，输出均匀分布在整个输出域之中。</p>
<h2 id="哈希表处理冲突位置（映射）的方法"><a href="#哈希表处理冲突位置（映射）的方法" class="headerlink" title="哈希表处理冲突位置（映射）的方法"></a>哈希表处理冲突位置（映射）的方法</h2></li>
<li><p>链接法：</p>
<ul>
<li>对于经过哈希函数得到<strong>同一个index</strong>的数据，利用链表（或者类似的形式）将其串联起来，寻找的时候先进行哈希得到index，然后再该index对应的位置逐个遍历链表得到要找的对象</li>
</ul>
</li>
<li><p><em><strong>其他方法</strong></em>参考链接 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26567507/article/details/80167351">参考</a></p>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2></li>
<li><p>用在给服务器分配数据问题减少迁移数据的工作量</p>
</li>
<li><p>一般情况下将输入数据的<code>key</code>值进行哈希，哈希得到的结果对服务器的数量取模，按照取得的结果分配到不同的服务器上，但是此时假如增加或者减少了服务器，就会因为取模的数字变化导致整个系统的哈希取模的数字都需要重新计算和分配，进而整体前迁移，工作量很大</p>
</li>
<li><p>引入一致性哈希得目的是减少上文描述得<em>前移工作量</em></p>
</li>
<li><p><img src="/imgs/a906dd8694b2b5033a83f841abd7919f93a7e4dfb74e15f6a7af6663c9ba82d3.png" alt="图 1">  </p>
</li>
<li><p>将三个机器的特征名称进行哈希，哈希过后将三个机器放在一个由哈希结果范围组成的环上（最大值和最小值头尾相接）。此时得到一个数据，同样将数据进行哈希，哈希得到的结果在环上找距离最近（此处的算法可以更换）的服务器存储该数据，假如数据的哈希值比所有服务器的哈希值都大的话就找哈希值最小的服务器，因为大小首尾相接。</p>
<h3 id="增加机器"><a href="#增加机器" class="headerlink" title="增加机器"></a>增加机器</h3></li>
<li><p><img src="/imgs/c482331ba4e5bc111d2b96bf43bf9e04837530b69657f089fed48fda2b8626e3.png" alt="图 2">  </p>
</li>
<li><p>假如此时需要增加M4，那么只需要将M3和M4之间的数据迁移到M4即可，不需要将所有数据进行重新计算迁移。</p>
</li>
<li><p>潜在问题：</p>
<ul>
<li>一开始的时候因为机器的地址是哈希得到的，未必均衡</li>
<li>增加机器之后可能导致局部机器比较密集，同样负载不均衡</li>
</ul>
</li>
<li><p>解决上述问题的方法：<strong>虚拟节点技术</strong></p>
<ul>
<li><p><img src="/imgs/8e91c4642b1ac4809f2c2adda961253bb18c6d7baaf8e888115f4cc5a4fde64c.png" alt="图 3">  </p>
</li>
<li><p>给每个服务器分配多个用于哈希的序列，每个服务器在环上具有<strong>多个</strong>对应的序列哈希得到的节点位置，<strong>相对均匀</strong>，同时也比较方便虚拟节点之间的数据迁移</p>
</li>
<li><p>不同的机器可以根据机器性能和状态的不同分配<strong>不同数量</strong>的虚拟节点，实现对于负载比例的不同分配。</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/24/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/24/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">图相关算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-24 00:20:38" itemprop="dateCreated datePublished" datetime="2022-08-24T00:20:38+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图对象的定义"><a href="#图对象的定义" class="headerlink" title="图对象的定义"></a>图对象的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">	<span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="边对象的定义"><a href="#边对象的定义" class="headerlink" title="边对象的定义"></a>边对象的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">	<span class="keyword">public</span> Node from;</span><br><span class="line">	<span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> weight, Node from, Node to)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">		<span class="keyword">this</span>.from = from;</span><br><span class="line">		<span class="keyword">this</span>.to = to;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="节点对象的定义"><a href="#节点对象的定义" class="headerlink" title="节点对象的定义"></a>节点对象的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点结构的描述</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> in;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> out;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		out = <span class="number">0</span>;</span><br><span class="line">		nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code01_BFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从node出发，进行宽度优先遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node start)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		queue.add(start);</span><br><span class="line">		set.add(start);</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">			Node cur = queue.poll();</span><br><span class="line">			System.out.println(cur.value);</span><br><span class="line">			<span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">					set.add(next);</span><br><span class="line">					queue.add(next);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>主要是在添加一个节点的所有相邻节点到队列里的时候使用了一个set结构判断这个节点是否被添加过，防止无限循环的产生<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code02_DFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		stack.add(node);</span><br><span class="line">		set.add(node);</span><br><span class="line">		System.out.println(node.value);</span><br><span class="line">		<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">			Node cur = stack.pop();</span><br><span class="line">			<span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">					stack.push(cur);</span><br><span class="line">					stack.push(next);</span><br><span class="line">					set.add(next);</span><br><span class="line">					System.out.println(next.value);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用一个栈的数据结构，每从栈中弹出一个节点的时候，遍历该节点的所有邻接点，如果不在已经遍历过的节点的set内，那么先将<strong>节点自身</strong>进栈，然后再将<strong>该邻接节点</strong>进栈<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2></li>
<li>对于一个带权连通无向图G=(V,E)，生成树不同，每棵树的权（<strong>树中所有边上的权值和</strong>）也不同，设R为G的所有生成树的集合，若T为R中权值和最小的生成树，则T称为G的最小生成树（Minimum-Spanning-Tree，MST）<h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2></li>
<li>并查集：具有检查数据结构中的一些节点是否在同一个集合中、以及将不同的集合合并为一个集合的功能的数据结构<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//undirected graph only</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code04_Kruskal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Union-Find Set</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">		<span class="comment">// key 某一个节点， value key节点往上的节点</span></span><br><span class="line">		<span class="keyword">private</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">		<span class="comment">// key 某一个集合的代表节点, value key所在集合的节点个数</span></span><br><span class="line">		<span class="keyword">private</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">			sizeMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(Collection&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">			fatherMap.clear();</span><br><span class="line">			sizeMap.clear();</span><br><span class="line">			<span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">				fatherMap.put(node, node);</span><br><span class="line">				sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> Node <span class="title">findFather</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">			Stack&lt;Node&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">			<span class="keyword">while</span>(n != fatherMap.get(n)) &#123;</span><br><span class="line">				path.add(n);</span><br><span class="line">				n = fatherMap.get(n);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(!path.isEmpty()) &#123;</span><br><span class="line">				fatherMap.put(path.pop(), n);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> findFather(a) == findFather(b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Node aDai = findFather(a);</span><br><span class="line">			Node bDai = findFather(b);</span><br><span class="line">			<span class="keyword">if</span> (aDai != bDai) &#123;</span><br><span class="line">				<span class="keyword">int</span> aSetSize = sizeMap.get(aDai);</span><br><span class="line">				<span class="keyword">int</span> bSetSize = sizeMap.get(bDai);</span><br><span class="line">				<span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">					fatherMap.put(aDai, bDai);</span><br><span class="line">					sizeMap.put(bDai, aSetSize + bSetSize);</span><br><span class="line">					sizeMap.remove(aDai);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					fatherMap.put(bDai, aDai);</span><br><span class="line">					sizeMap.put(aDai, aSetSize + bSetSize);</span><br><span class="line">					sizeMap.remove(bDai);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">kruskalMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">		UnionFind unionFind = <span class="keyword">new</span> UnionFind();</span><br><span class="line">		unionFind.makeSets(graph.nodes.values());</span><br><span class="line">		<span class="comment">// 从小的边到大的边，依次弹出，小根堆！</span></span><br><span class="line">		PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">		<span class="keyword">for</span> (Edge edge : graph.edges) &#123; <span class="comment">// M 条边</span></span><br><span class="line">			priorityQueue.add(edge);  <span class="comment">// O(logM)</span></span><br><span class="line">		&#125;</span><br><span class="line">		Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123; <span class="comment">// M 条边</span></span><br><span class="line">			Edge edge = priorityQueue.poll(); <span class="comment">// O(logM)</span></span><br><span class="line">			<span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="comment">// O(1)</span></span><br><span class="line">				result.add(edge);</span><br><span class="line">				unionFind.union(edge.from, edge.to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>findfFather函数是当一个节点具有多级的父亲的时候找到最高级别的父亲，并且修改一路上所有节点的父亲为最高级的父亲</li>
<li>算法的思路是先按照权值将图中所有的边都放入小根堆中，将图中所有节点放入并查集中独立存在，然后从堆中依次弹出边，假如边链接的两端不是同一个集合，那么将边放入结果中，同时在并查集中合并两个集合，直到无可合并为止。<h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// undirected graph only</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code05_Prim</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">primMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 解锁的边进入小根堆</span></span><br><span class="line">		PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 哪些点被解锁出来了</span></span><br><span class="line">		HashSet&lt;Node&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 依次挑选的的边在result里</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="comment">// 随便挑了一个点</span></span><br><span class="line">			<span class="comment">// node 是开始点</span></span><br><span class="line">			<span class="keyword">if</span> (!nodeSet.contains(node)) &#123;</span><br><span class="line">				nodeSet.add(node);</span><br><span class="line">				<span class="keyword">for</span> (Edge edge : node.edges) &#123; <span class="comment">// 由一个点，解锁所有相连的边</span></span><br><span class="line">					priorityQueue.add(edge);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">					Edge edge = priorityQueue.poll(); <span class="comment">// 弹出解锁的边中，最小的边</span></span><br><span class="line">					Node toNode = edge.to; <span class="comment">// 可能的一个新的点</span></span><br><span class="line">					<span class="keyword">if</span> (!nodeSet.contains(toNode)) &#123; <span class="comment">// 不含有的时候，就是新的点</span></span><br><span class="line">						nodeSet.add(toNode);</span><br><span class="line">						result.add(edge);</span><br><span class="line">						<span class="keyword">for</span> (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">							priorityQueue.add(nextEdge);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// break;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请保证graph是连通图</span></span><br><span class="line">	<span class="comment">// graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路</span></span><br><span class="line">	<span class="comment">// 返回值是最小连通图的路径之和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = graph.length;</span><br><span class="line">		<span class="keyword">int</span>[] distances = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">		<span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">		visit[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			distances[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> minPath = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">int</span> minIndex = -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!visit[j] &amp;&amp; distances[j] &lt; minPath) &#123;</span><br><span class="line">					minPath = distances[j];</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (minIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> sum;</span><br><span class="line">			&#125;</span><br><span class="line">			visit[minIndex] = <span class="keyword">true</span>;</span><br><span class="line">			sum += minPath;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!visit[j] &amp;&amp; distances[j] &gt; graph[minIndex][j]) &#123;</span><br><span class="line">					distances[j] = graph[minIndex][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>prim算法主要用到一个存储边用的小根堆和一个记录哪些点被解锁的set</li>
<li>首先在graph中随便选择一个点，将这个点加入记录解锁的点的集合，然后将这个<strong>点的所有边</strong>放入优先级队列中，然后开始while循环，每次从优先级队列中弹出一个权值最小的边，假如这个边指向的节点<strong>不在</strong>前面的set中的话就将这个边指向的节点放入点set中，将这条边放入结果中，然后将<strong>该节点延伸出的所有边</strong>放入优先级队列中。<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2></li>
<li>该算法主要是找到指定起始点到图上剩余所有点的最近距离<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no negative weight</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code06_Dijkstra</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra1</span><span class="params">(Node from)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    distanceMap.put(from, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 打过对号的点</span></span><br><span class="line">    HashSet&lt;Node&gt; selectedNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    <span class="keyword">while</span> (minNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//  原始点  -&gt;  minNode(跳转点)   最小距离distance</span></span><br><span class="line">        <span class="keyword">int</span> distance = distanceMap.get(minNode);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : minNode.edges) &#123;</span><br><span class="line">            Node toNode = edge.to;</span><br><span class="line">            <span class="keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;</span><br><span class="line">                distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// toNode </span></span><br><span class="line">                distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selectedNodes.add(minNode);</span><br><span class="line">        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distanceMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMinDistanceAndUnselectedNode</span><span class="params">(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;</span><br><span class="line">    Node minNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">        Node node = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">            minNode = node;</span><br><span class="line">            minDistance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node node;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.distance = distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>算法主要依赖一个记录到对应节点最近距离的哈希表和一个记录某个节点是否已经被锁定的set</li>
<li>在初始时刻将起始点到起始点放入哈希表，并且将其距离设置为0。</li>
<li>然后的while循环每次都对找出的当前<strong>尚未被锁定</strong>而且在哈希表中到起始位置距离最小的点指向的所有尚未被锁定的节点的距离进行重算，假如被指向的节点之前的距离小于从该点出发到被指向的点的距离，将被指向点的距离更新为被选中的点出发的距离。（假如被指向的点<strong>不存在</strong>于哈希表中的话认为被指向的点的距离为<strong>正无穷</strong>，同样添加该点的距离条目进行更新）。然后将当前选中的点锁定，也就是假如被锁定的点的set中，然后找到当前未被锁定而且从总出发点开始距离最短的点，再次重复循环。</li>
</ul>
<h2 id="卡码网-29-安排超市（第一期模拟笔试）"><a href="#卡码网-29-安排超市（第一期模拟笔试）" class="headerlink" title="卡码网 29. 安排超市（第一期模拟笔试）"></a>卡码网 29. 安排超市（第一期模拟笔试）</h2><ul>
<li>此题先用bfs找到每个分立的区域，假如某个独立的区域里具有住户，则需要设置超市，超市尽可能的少</li>
<li>然后寻找到每个住户综合距离最小的超市，实际上可以从每个住户出发bfs遍历所在的区域，bfs每前进一层，意味着从住户出发到这个位置的距离+1，由此可以得出住户出发到这个区域每个位置的距离</li>
<li>对每个住户执行上述操作然后累加，就可以找出从每个位置出发到每个住户距离之和</li>
<li>找出每个区域中距离之和最小的位置即可作为超市的位置</li>
<li>注意bfs的时候需要<strong>一遇到某个点就在<code>visited</code>数组中标记这个位置</strong>，而<em>不是</em>从队列中弹出的时候再标记这个位置，否则会导致这个位置<strong>入队多次</strong>，使得算法超时<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set&lt;pair&lt;int, int&gt;&gt; houses;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;vector&lt;pair&lt;short, short&gt;&gt;&gt; regions;</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; visited;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">short</span>&gt;&gt; m;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dist;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">short</span>&gt;&gt; region;</span><br><span class="line"><span class="comment">// vector&lt;vector&lt;bool&gt;&gt; visitedDis;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs4Reg</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> n, <span class="keyword">int</span> reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x0, y0&#125;);</span><br><span class="line">    region[x0][y0] = reg;</span><br><span class="line">    visited[x0][y0] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> x = tmp.first;</span><br><span class="line">        <span class="keyword">int</span> y = tmp.second;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(m[x][y] == 1)houses.insert(&#123;x, y&#125;);</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; !visited[x<span class="number">-1</span>][y] &amp;&amp; m[x<span class="number">-1</span>][y]&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            region[x<span class="number">-1</span>][y] = reg;</span><br><span class="line">            visited[x<span class="number">-1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x<span class="number">-1</span>, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;<span class="number">0</span> &amp;&amp; !visited[x][y<span class="number">-1</span>] &amp;&amp; m[x][y<span class="number">-1</span>]&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            region[x][y<span class="number">-1</span>] = reg;</span><br><span class="line">            visited[x][y<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x, y<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;n<span class="number">-1</span> &amp;&amp; !visited[x+<span class="number">1</span>][y] &amp;&amp; m[x+<span class="number">1</span>][y]&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            region[x+<span class="number">1</span>][y] = reg;</span><br><span class="line">            visited[x+<span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x+<span class="number">1</span>, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;n<span class="number">-1</span> &amp;&amp; !visited[x][y+<span class="number">1</span>] &amp;&amp; m[x][y+<span class="number">1</span>]&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            region[x][y+<span class="number">1</span>] = reg;</span><br><span class="line">            visited[x][y+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x, y+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disFromHouse</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> curDis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;v; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> x = tmp.first;</span><br><span class="line">            <span class="keyword">int</span> y = tmp.second;</span><br><span class="line">            dist[x][y] += curDis;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; !visited[x<span class="number">-1</span>][y] &amp;&amp; m[x<span class="number">-1</span>][y]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x<span class="number">-1</span>, y&#125;);</span><br><span class="line">                visited[x<span class="number">-1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;<span class="number">0</span> &amp;&amp; !visited[x][y<span class="number">-1</span>] &amp;&amp; m[x][y<span class="number">-1</span>]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y<span class="number">-1</span>&#125;);</span><br><span class="line">                visited[x][y<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;n<span class="number">-1</span> &amp;&amp; !visited[x+<span class="number">1</span>][y] &amp;&amp; m[x+<span class="number">1</span>][y]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x+<span class="number">1</span>, y&#125;);</span><br><span class="line">                visited[x+<span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;n<span class="number">-1</span> &amp;&amp; !visited[x][y+<span class="number">1</span>] &amp;&amp; m[x][y+<span class="number">1</span>]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y+<span class="number">1</span>&#125;);</span><br><span class="line">                visited[x][y+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++curDis;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    visited = vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    m = vector&lt;vector&lt;<span class="keyword">short</span>&gt;&gt;(n, vector&lt;<span class="keyword">short</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    dist = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    region = vector&lt;vector&lt;<span class="keyword">short</span>&gt;&gt;(n, vector&lt;<span class="keyword">short</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// visitedDis = vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(n, false));</span></span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row:m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:row)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tmp;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: i = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">/* code */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>: i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: i = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> regCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; m[i][j]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bfs4Reg</span>(i, j, n, regCnt++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sumOfDist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minDist = INT_MAX;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">hasHouse</span><span class="params">(regCnt, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                visited = vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">                <span class="built_in">disFromHouse</span>(i, j, n);</span><br><span class="line">                hasHouse[region[i][j]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">regMin</span><span class="params">(regCnt, INT_MAX)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][j]&gt;<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            regMin[region[i][j]] = <span class="built_in">min</span>(regMin[region[i][j]], dist[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> disSUm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> marketCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;regCnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hasHouse[i])</span><br><span class="line">        &#123;</span><br><span class="line">            disSUm+=regMin[i];</span><br><span class="line">            ++marketCnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;marketCnt&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt; disSUm &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;regions.size()&lt;&lt;&#x27; &#x27;&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FrankZhang"
      src="/images/avatar1.jpg">
  <p class="site-author-name" itemprop="name">FrankZhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">173</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FrankZhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">626k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">18:59</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
