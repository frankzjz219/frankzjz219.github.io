<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/rPi.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/rPi.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/rPi.png">
  <link rel="mask-icon" href="/images/rPi.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"frankzjz219.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Frank&#39;s blogs">
<meta property="og:url" content="https://frankzjz219.github.io/page/3/index.html">
<meta property="og:site_name" content="Frank&#39;s blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FrankZhang">
<meta property="article:tag" content="C, C++, Leetcode, Linux, 嵌入式, Ununtu, 驱动">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://frankzjz219.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Frank's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Frank's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">永远好奇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/frankzjz219" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/" class="post-title-link" itemprop="url">背包问题（动态规划）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-26 21:36:09" itemprop="dateCreated datePublished" datetime="2024-01-26T21:36:09+08:00">2024-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-11 21:07:49" itemprop="dateModified" datetime="2024-07-11T21:07:49+08:00">2024-07-11</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode-416-分割等和子集"><a href="#Leetcode-416-分割等和子集" class="headerlink" title="Leetcode 416. 分割等和子集"></a>Leetcode 416. 分割等和子集</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">背包原理教程</a></li>
<li>此题实际上就是使用数组的元素作为物品，数组元素本身的大小就是价值，讨论是否能使用数组中的元素凑出数组大小一半的值</li>
<li>使用的是01背包，倒序遍历即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = <span class="built_in">max</span>(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="comment">// int num = nums[i];</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] = dp[j]|dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-1049-最后一块石头重量-II"><a href="#Leetcode-1049-最后一块石头重量-II" class="headerlink" title="Leetcode 1049. 最后一块石头重量 II"></a>Leetcode 1049. 最后一块石头重量 II</h2><ul>
<li>主要思路还是背包问题，只不过此时的背包容量和装的物品的价值<strong>都是石头的重量</strong></li>
<li><u>注意内存循环必须从后往前遍历，否则会导致前面被添加过的物品被连续重复添加</u></li>
<li>外层循环的意思是使用到的石头是<code>0</code>-<code>i</code>个，内层的意思是石头<u>总重不超过某个值的时候的最大总重是多少</u><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:stones)sum+=i;</span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxArr</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;stones.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wi = stones[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j&gt;=wi; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                maxArr[j] = <span class="built_in">max</span>(maxArr[j], maxArr[j-wi]+wi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - (maxArr[target]*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h2><ul>
<li>此题主要是将字符串视为一个背包，字典中的每个单词都是一个物品</li>
<li>从字符串的每个位置开始，如果这个位置已经可达，那么从这个位置开始枚举substring，如果这个substring在字典中，则这个substring的位置也可达，从前往后遍历（因为每个单词使用次数不限制）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;string&gt; us; </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; able;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">able</span><span class="params">(s.size()+<span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        unordered_set&lt;string&gt; um;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; w : wordDict)</span><br><span class="line">        &#123;</span><br><span class="line">            um.<span class="built_in">insert</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">        able[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!able[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i+j<span class="number">-1</span>&lt;=s.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(um.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(i<span class="number">-1</span>, j)))</span><br><span class="line">                &#123;</span><br><span class="line">                    able[i+j<span class="number">-1</span>] = able[i+j<span class="number">-1</span>]|able[i<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> able[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-474-一和零"><a href="#Leetcode-474-一和零" class="headerlink" title="Leetcode 474. 一和零"></a>Leetcode 474. 一和零</h2><ul>
<li>此题是一个递推问题，做题方式类似于背包法</li>
<li>遍历同样是外层循环指定此时能使用的字符串的最大index</li>
<li>内层循环从已经可达的位置往外递推，类似于广度优先搜索<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// int maxLen;</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; lenMap;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c0 = <span class="number">0</span>, c1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a:i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a == <span class="string">&#x27;0&#x27;</span>)++c0;</span><br><span class="line">                <span class="keyword">else</span> ++c1;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(c0, c1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        map[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c0 = arr[i].first;</span><br><span class="line">            <span class="keyword">int</span> c1 = arr[i].second;</span><br><span class="line">            <span class="comment">// int s = q.size();</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j&gt;=c0; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n; k&gt;=c1; --k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[j-c0][k-c1]&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    map[j][k] = <span class="built_in">max</span>(map[j-c0][k-c1]+<span class="number">1</span>, map[j][k]);</span><br><span class="line">                    map[m][n] = <span class="built_in">max</span>(map[m][n], map[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[m][n]&lt;<span class="number">0</span>?<span class="number">0</span>:map[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-518-零钱兑换II"><a href="#Leetcode-518-零钱兑换II" class="headerlink" title="Leetcode 518. 零钱兑换II"></a>Leetcode 518. 零钱兑换II</h2></li>
<li>此题是一个完全背包类型的题<a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">参考链接</a></li>
<li>注意循环次序的变化，0 1背包循环一般内层递推循环都是倒序的，但是这种是正序的</li>
<li>完全背包遍历背包容量的时候是正序的，但是不完全背包遍历背包容量是倒序的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(amount+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// queue&lt;int&gt; q;</span></span><br><span class="line">        <span class="comment">// q.push(0);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;coins.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coins[i]; j&lt;=amount; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j]+=arr[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-377-组合总和IV"><a href="#Leetcode-377-组合总和IV" class="headerlink" title="Leetcode 377. 组合总和IV"></a>Leetcode 377. 组合总和IV</h2></li>
<li>如果求<strong>组合数</strong>就是外层for循环遍历物品，内层for遍历背包。</li>
<li>如果求<strong>排列数</strong>就是外层for遍历背包，内层for循环遍历物品。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; <span class="title">arr</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=target; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&gt;=<span class="number">0</span>)</span><br><span class="line">                arr[j]+=arr[j-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-279-完全平方数"><a href="#Leetcode-279-完全平方数" class="headerlink" title="Leetcode 279. 完全平方数"></a>Leetcode 279. 完全平方数</h2><ul>
<li>转化为一个完全背包问题即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; minCnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        minCnt = vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        minCnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i*i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;=n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minCnt[j-i]!=INT_MAX)minCnt[j] = <span class="built_in">min</span>(minCnt[j], minCnt[j-i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCnt[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="卡码网-28-子序列中的-k-种字母"><a href="#卡码网-28-子序列中的-k-种字母" class="headerlink" title="卡码网 28. 子序列中的 k 种字母"></a>卡码网 28. 子序列中的 k 种字母</h2><ul>
<li><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1028">链接</a></li>
<li>此题是一个背包问题，主要是先统计字符串中26个字母每个包含几个</li>
<li>因为顺序无所谓，因此直接开始找字母的种类</li>
<li>假设此时字符串已经有了k种字母，凑到k+1种字母的方式就是通过添加一个新的种类的字母，但是新的种类的字母可能有多个备选项比如<code>n</code></li>
<li>那么最终的字符串中可以在这n的字母种选择小于等于n的任意个，选择方式共有<img src="/imgs/b43e2b5ad8a38f7eed236cc409d35ddf366b245f2701794b13aac3c9ffb3073d.png" alt="picture 0">  种，上述结果的求和是<code>2^n-1</code></li>
<li>因此实际上在递推背包的时候，假如当前选择的字母的个数有n个，那么具有k种字母的字符串的种类是具有k-1种字母的字符串的种类*<code>2^n-1</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; letters;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        letters[tmp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">combs</span><span class="params">(k+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    combs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;i : letters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sec = (<span class="keyword">long</span> <span class="keyword">long</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, i.second)<span class="number">-1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j&gt;=<span class="number">1</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            combs[j]+=combs[j<span class="number">-1</span>]*sec;</span><br><span class="line">            combs[j]%=<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;combs[k]%<span class="number">1000000007</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="nowcoder-HJ16-购物单"><a href="#nowcoder-HJ16-购物单" class="headerlink" title="nowcoder HJ16 购物单"></a>nowcoder HJ16 购物单</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&tqId=21239&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?page=2&tpId=37&type=37&difficulty=undefined&judgeStatus=undefined&tags=&title=">链接</a></li>
<li>此题是一个分组背包问题，也就是每一组的物品只能买一个</li>
<li>主要是在遍历每一组的不同物品尝试的时候，不能修改本身的dp数组，要遍历完某一个分组之后再修改</li>
<li>此题因为一个物品最多有2个附属物品，因此每一组最多也就是4种组合，可以直接枚举<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money, n;</span><br><span class="line">    cin&gt;&gt;money&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="built_in">items</span>(n);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            items[i].<span class="built_in">insert</span>(items[i].<span class="built_in">begin</span>(), &#123;a, b, a*b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            items[c<span class="number">-1</span>].<span class="built_in">push_back</span>(&#123;a, b, a*b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(items[i].<span class="built_in">size</span>() ==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(items[i].<span class="built_in">size</span>() == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">0</span>] += items[i][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">1</span>] += items[i][<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">2</span>] += items[i][<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(items[i].<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">       &#123;</span><br><span class="line">            items[i].<span class="built_in">push_back</span>(&#123;items[i][<span class="number">0</span>][<span class="number">0</span>]+items[i][<span class="number">1</span>][<span class="number">0</span>]+items[i][<span class="number">2</span>][<span class="number">0</span>], items[i][<span class="number">0</span>][<span class="number">1</span>]+items[i][<span class="number">1</span>][<span class="number">1</span>]+items[i][<span class="number">2</span>][<span class="number">1</span>], items[i][<span class="number">0</span>][<span class="number">2</span>]+items[i][<span class="number">1</span>][<span class="number">2</span>]+items[i][<span class="number">2</span>][<span class="number">2</span>]&#125;);</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">0</span>] = items[i][<span class="number">0</span>][<span class="number">0</span>]+items[i][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">1</span>] = items[i][<span class="number">0</span>][<span class="number">1</span>]+items[i][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            items[i][<span class="number">1</span>][<span class="number">2</span>] = items[i][<span class="number">0</span>][<span class="number">2</span>]+items[i][<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            items[i][<span class="number">2</span>][<span class="number">0</span>] = items[i][<span class="number">0</span>][<span class="number">0</span>]+items[i][<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">            items[i][<span class="number">2</span>][<span class="number">1</span>] = items[i][<span class="number">0</span>][<span class="number">1</span>]+items[i][<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">            items[i][<span class="number">2</span>][<span class="number">2</span>] = items[i][<span class="number">0</span>][<span class="number">2</span>]+items[i][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(money+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; dpRes = dp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = items[i].<span class="built_in">size</span>()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; dpTmp = dp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = money; k&gt;=items[i][j][<span class="number">0</span>]; --k)</span><br><span class="line">            &#123;</span><br><span class="line">                dpTmp[k] = <span class="built_in">max</span>(dpTmp[k], dpTmp[k-items[i][j][<span class="number">0</span>]]+items[i][j][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b&lt;dp.<span class="built_in">size</span>(); ++b)</span><br><span class="line">            &#123;</span><br><span class="line">                dpRes[b] = <span class="built_in">max</span>(dpTmp[b], dpRes[b]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp = dpRes;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[money];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64 位输出请用 printf(&quot;%lld&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h2></li>
<li>此题不能用传统的背包理论做，因为是每个物品必须用到而不是可用可不用</li>
<li>使用了两个数组滚动进行更新，从上一次迭代能达到的位置出发，推算这一次迭代能达到的位置以及能达到的方式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> maxAbs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            maxAbs+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = nums[i];</span><br><span class="line">            tmp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> p : arr)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[p.first+n]+=p.second;</span><br><span class="line">                tmp[p.first-n]+=p.second;</span><br><span class="line">            &#125;</span><br><span class="line">            arr = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> arr[target];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/22/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">Linux进程、线程等底层原理笔记（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 20:11:48" itemprop="dateCreated datePublished" datetime="2024-01-22T20:11:48+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-18 20:23:17" itemprop="dateModified" datetime="2024-04-18T20:23:17+08:00">2024-04-18</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h2><ul>
<li><code>fork</code>创建进程的时候，将父进程的所有资源拷贝给子进程<ul>
<li>写时复制的</li>
<li>实际上是将内存地址设置为只读的</li>
<li>假如任何一个进程试图写入的话，会触发<code>page fault</code>导致系统给他分配新的内存，也就是复制</li>
</ul>
</li>
<li><code>vfork</code>的时候是直接将子进程的资源指向父进程的，二者是同时共有资源的，一个修改会影响另一个<h2 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h2></li>
<li>通过<code>pthread_create</code>创建线程的时候，实际上是调用系统的<code>clone</code>（类似于<code>vfork</code>）方式创建了一个<u>与父进程共享一切资源的子进程</u></li>
<li><img src="/imgs/df695c03041cf38aefbc7ecbbdedac0edeb848523d8e8e8de52c8026a22c85fe.png" alt="picture 0">  </li>
<li>本来理论上父子进程之间的资源是写时复制的，但是这里直接共享了</li>
<li>每个线程都有一个独立的PID<h3 id="线程的真假ID"><a href="#线程的真假ID" class="headerlink" title="线程的真假ID"></a>线程的真假ID</h3></li>
<li>用户空间<code>getpid()</code>获得的PID是<u>进程ID</u>，并不是线程独立的PID<ul>
<li><code>gettid()</code>获得的才是真正<strong>线程PID</strong>，也就是内核的真正PID</li>
<li><img src="/imgs/a91e7465f98780d02621e8f5b9b630367fa9ac81365bb4c16b76064c3b778a4c.png" alt="picture 1">  </li>
</ul>
</li>
</ul>
<h2 id="进程的托孤"><a href="#进程的托孤" class="headerlink" title="进程的托孤"></a>进程的托孤</h2><ul>
<li>一个拥有子进程的进程终止的时候，会向init进程或者是自己最近一级的父进程中的subreaper进程托孤，将自己的子进程交给这些进程处理<ul>
<li>subreaper需要一个进程<strong>自己声明自己是</strong>才可以<h2 id="深度睡眠和浅度睡眠"><a href="#深度睡眠和浅度睡眠" class="headerlink" title="深度睡眠和浅度睡眠"></a>深度睡眠和浅度睡眠</h2></li>
</ul>
</li>
<li>深度睡眠只能被资源唤醒<ul>
<li>甚至无法被信号杀死</li>
</ul>
</li>
<li>浅度睡眠可以被资源或者是信号（signal）唤醒</li>
<li>比如程序因为内存没加载导致page fault<ul>
<li>此时如果因为接收到信号开始执行内容，会导致程序继而触发更多的page fault</li>
<li>因此只有等到相关内存页面被分配了才可以</li>
</ul>
</li>
</ul>
<h2 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h2><ul>
<li>程序的睡眠是程序访问资源的时候发现需要等待，自己让出CPU使用权并且将状态设置为sleep</li>
<li>睡眠结束的时候需要判断自己是被什么唤醒的（如果是浅度睡眠的话）<ul>
<li>是被信号唤醒的？是什么信号</li>
<li>是被资源唤醒的？继续执行</li>
</ul>
</li>
</ul>
<h2 id="第一个进程是被谁创建出来的"><a href="#第一个进程是被谁创建出来的" class="headerlink" title="第一个进程是被谁创建出来的"></a>第一个进程是被谁创建出来的</h2><ul>
<li>1进程（也就是init）是被Linux的0进程创建出来的</li>
<li>但是Linux的0进程使用pstree看不到</li>
<li>退化为了IDLE进程<ul>
<li>所有进程停止或者睡眠之后，才会调度的进程</li>
<li>它会把将CPU设置为省电状态，只有中断可以唤醒<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2></li>
</ul>
</li>
<li>进程切换的开销不只是上下文切换，主要还包括进程切换引起的内存cache 的<code>cache miss</code></li>
<li>因为不同进程需要的内存空间不同，导致切换会极大增加miss概率</li>
</ul>
<h2 id="非实时进程的时间片分配"><a href="#非实时进程的时间片分配" class="headerlink" title="非实时进程的时间片分配"></a>非实时进程的时间片分配</h2><ul>
<li>使用<code>nice</code>值分配</li>
<li><code>nice</code>越大，优先级越低</li>
<li>优先级高的相对于优先级低的可以在唤醒的一瞬间抢占，但是之后会一起轮转</li>
<li>优先级越高的在轮转中分配到的时间片越长</li>
<li>在整个循环过程中是所有优先级的进程一起轮转的，不会高优先级阻塞低优先级运行</li>
<li>系统会针对应用是IO类型还是CPU消耗类型来调整nice值<ul>
<li>越CPU占用，nice越低<h2 id="控制实时进程和非实时进程占用的CPU比例"><a href="#控制实时进程和非实时进程占用的CPU比例" class="headerlink" title="控制实时进程和非实时进程占用的CPU比例"></a>控制实时进程和非实时进程占用的CPU比例</h2></li>
</ul>
</li>
<li><code>sched_rt_period_us</code>和<code>shced_rt_runtime_us</code></li>
<li>控制FIFO和RR最多占用的时间</li>
<li><code>sudo sh -c &#39;echo CPU核心数*1000000 &gt; /proc/sys/kernel/sched_rt_period_us&#39;</code><ul>
<li>上面那个不能超过<code>CPU核心数*1000000</code></li>
</ul>
</li>
<li><code>sudo sh -c &#39;echo 某个小于period的值 &gt; /proc/sys/kernel/sched_rt_runtime_us&#39;</code></li>
<li>不能超过<code>sched_rt_period_us</code><ul>
<li><strong>但是可能会导致系统崩溃</strong></li>
</ul>
</li>
<li><img src="/imgs/852dd435f32fd9baa80f8fd4e531104996a4aefc62f80afc69816d2f63d3c04a.png" alt="picture 2">  </li>
</ul>
<h2 id="CFS-完全公平调度"><a href="#CFS-完全公平调度" class="headerlink" title="CFS-完全公平调度"></a>CFS-完全公平调度</h2><ul>
<li>每次都调度到当前位置vruntime最小的进程</li>
<li>也就是考虑到优先级修正之后，运行时间最小的进程</li>
<li>完全公平，使得所有进程的vruntime尽可能公平分配<ul>
<li>vruntime是实际运行时间进行一些权重和系数运算得出的</li>
<li>物理runtime除以权重</li>
<li><img src="/imgs/e478ee6ad032f1596c2fb5c13bad47341d7da1c13f4987d3cee46d0360a00958.png" alt="picture 3">  </li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>System Call</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>nice()</td>
<td>Sets a process’s nice value</td>
</tr>
<tr>
<td>sched_setscheduler()</td>
<td>Sets a process’s scheduling policy</td>
</tr>
<tr>
<td>sched_getscheduler()</td>
<td>Gets a process’s scheduling pol1icy</td>
</tr>
<tr>
<td>sched_setparam()</td>
<td>Sets a process’s real-time priority</td>
</tr>
<tr>
<td>sched_getparam()</td>
<td>Gets a process’s real-time priority</td>
</tr>
<tr>
<td>sched_get_priority_max()</td>
<td>Gets the maximum real-time priority</td>
</tr>
<tr>
<td>sched_get_priority_min()</td>
<td>Gets the minimum real-time priority</td>
</tr>
<tr>
<td>sched_rr_get_interval()</td>
<td>Gets a process’s timeslice value</td>
</tr>
<tr>
<td>sched_setaffinity()</td>
<td>Sets a process’s processor affinity</td>
</tr>
<tr>
<td>sched_getaffinity()</td>
<td>Gets a process’s processor affinity</td>
</tr>
<tr>
<td>sched_yield()</td>
<td>Temporarily yields the processor</td>
</tr>
</tbody></table>
<h2 id="设置进程的CPU亲和"><a href="#设置进程的CPU亲和" class="headerlink" title="设置进程的CPU亲和"></a>设置进程的CPU亲和</h2><ul>
<li>使用<code>taskset</code>命令行工具</li>
<li>上文提到的<code>sched_setaffinity()</code></li>
<li>或者单独设置线程的亲和力<code>pthread_setaffinity_np()</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>或者创建新线程时，通过属性结构体，控制新线程的亲和性<code>pthread_attr_setaffinity_np()</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setaffinity_np</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><ul>
<li>cgroup（Control Groups）是 Linux 内核提供的一个功能，用于限制、控制和监视一个或多个进程的资源使用。cgroup 允许你将进程组织在层次结构中，并为每个组分配特定的资源限制。</li>
<li>创建<ul>
<li><code>sudo mkdir /sys/fs/cgroup/cpu/my_cgroup</code></li>
</ul>
</li>
<li>添加进程<ul>
<li><code>echo &lt;PID&gt; &gt; /sys/fs/cgroup/cpu/my_cgroup/tasks</code></li>
</ul>
</li>
<li>设置 cgroup 的资源限制<ul>
<li><code>echo 1000000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us</code></li>
</ul>
</li>
<li>查看 cgroup 信息<ul>
<li><code>cat /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us</code></li>
</ul>
</li>
<li>删除 cgroup<ul>
<li><code>sudo rmdir /sys/fs/cgroup/cpu/my_cgroup</code></li>
</ul>
</li>
</ul>
<h2 id="如何使用sudo权限将echo的输出写入到文件中"><a href="#如何使用sudo权限将echo的输出写入到文件中" class="headerlink" title="如何使用sudo权限将echo的输出写入到文件中"></a>如何使用sudo权限将echo的输出写入到文件中</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;echo string &gt; /path/to/file&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">echo &quot;Hello, world&quot; | sudo tee -a /path/to/file</span><br></pre></td></tr></table></figure>
<h2 id="Linux中进程可以抢占的部分"><a href="#Linux中进程可以抢占的部分" class="headerlink" title="Linux中进程可以抢占的部分"></a>Linux中<code>进程</code>可以抢占的部分</h2><ul>
<li>即使是在下面不可调度的部分唤醒了一个优先级再高的进程，也不允许抢占执行</li>
<li>一个核心上的进程拿到了spinlock，会直接关闭这个核心的调度器停止调度</li>
<li>一个程序的<strong>优先级改变（降低）</strong>的时候，别的优先级高的进程可以<strong>立即抢占</strong></li>
</ul>
<table>
<thead>
<tr>
<th>区间</th>
<th>可调度性</th>
</tr>
</thead>
<tbody><tr>
<td>（硬）中断（不允许中断嵌套）</td>
<td>不可调度</td>
</tr>
<tr>
<td>软中断（可以中断嵌套）</td>
<td>不可调度</td>
</tr>
<tr>
<td>进程上下文中获取到<code>spinlock</code></td>
<td>不可调度</td>
</tr>
<tr>
<td>其他进程上下文</td>
<td>可以调度</td>
</tr>
</tbody></table>
<ul>
<li>自旋锁的自旋一定发生在不同的核心之间<ul>
<li>如果同一个核心的两个进程争夺自旋锁，一个抢到之后就直接关闭了调度器，另一个进程根本上不来，不可能自旋</li>
<li>只有可能是一个核心持有锁，另一个核心自旋</li>
</ul>
</li>
</ul>
<h2 id="进程回收和僵尸进程"><a href="#进程回收和僵尸进程" class="headerlink" title="进程回收和僵尸进程"></a>进程回收和僵尸进程</h2><ul>
<li>一个进程变成僵尸状态之后，进程的资源都消失了</li>
<li>但是进程的<code>task_struct</code>还没有消失</li>
<li>等待父进程使用<code>waitpid</code>回收并且查看进程的<strong>退出码</strong>，判断子进程的死因</li>
<li>只有父进程使用wait等待的时候他的task struct才会消失</li>
<li>这个进程无法使用系统的signal杀死</li>
</ul>
<h2 id="Linux进程状态"><a href="#Linux进程状态" class="headerlink" title="Linux进程状态"></a>Linux进程状态</h2><ul>
<li><img src="/imgs/8234473b9b901abca50f411cfe93f07e7bb03b02e925e19096cfe46f38cd29fb.png" alt="picture 4">  </li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>就绪</td>
<td>等待上CPU（因为时间片结束或者被抢占等）</td>
</tr>
<tr>
<td>运行</td>
<td>执行</td>
</tr>
<tr>
<td>睡眠</td>
<td>等资源（等到了就绪）</td>
</tr>
<tr>
<td>僵尸</td>
<td>执行完但是还没有回收</td>
</tr>
<tr>
<td>停止</td>
<td>STOP或者收到了Ctrl+Z等信号，还可以继续恢复（输入fg，bg等）</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/22/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E6%B3%95%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/22/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E6%B3%95%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">回溯和递归法题目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-22 00:39:27" itemprop="dateCreated datePublished" datetime="2024-01-22T00:39:27+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-12 12:10:39" itemprop="dateModified" datetime="2024-06-12T12:10:39+08:00">2024-06-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LeetCode-332-重新安排行程"><a href="#LeetCode-332-重新安排行程" class="headerlink" title="LeetCode 332. 重新安排行程"></a>LeetCode 332. 重新安排行程</h2><ul>
<li>此题的大部分是按照回溯法标准套路进行<ul>
<li>也就是</li>
<li>遍历尝试DFS</li>
<li>满足条件的修改环境</li>
<li>递归</li>
<li>出现结果的话直接返回</li>
<li>没出现的话将环境复原</li>
<li>继续尝试下一种</li>
</ul>
</li>
<li>但是注意需要一个<strong>排序</strong>（因为返回字典序最小的结果）快速的从一个<code>string</code>出发到一个<code>string</code>截止并且能处理重复情况的方式<ul>
<li>使用了<code>unordered_map&lt;string, map&lt;string, int&gt;&gt;</code></li>
<li>外层map将起点映射到终点</li>
<li>内层map将终点映射到出现过的次数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// unordered_set&lt;int&gt; used;</span></span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    unordered_map&lt;string, map&lt;string, <span class="keyword">int</span>&gt;&gt; to;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:tickets)</span><br><span class="line">        &#123;</span><br><span class="line">            ++to[i[<span class="number">0</span>]][i[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="comment">// ans.resize(tickets.size());</span></span><br><span class="line">        <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets, vector&lt;string&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;tickets.size()&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = tickets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!ans.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : to[<span class="string">&quot;JFK&quot;</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i.second&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --i.second;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i.first);</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">                    <span class="keyword">if</span>(flag)<span class="keyword">return</span>;</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ++i.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == cnt+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : to[ans[ans.<span class="built_in">size</span>()<span class="number">-1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i.second--;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i.first);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i.first&lt;&lt;endl;</span></span><br><span class="line">                <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">                <span class="keyword">if</span>(flag)<span class="keyword">return</span>;</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                i.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-47-全排列II"><a href="#Leetcode-47-全排列II" class="headerlink" title="Leetcode 47. 全排列II"></a>Leetcode 47. 全排列II</h2><ul>
<li>关键是去重</li>
<li>还要强调的是去重一定要对元素进行<strong>排序</strong>，这样我们才方便通过相邻的节点来判断是否重复使用了<ul>
<li>有两种去重的方式，其中一种是当目前循环的时候如果i大于起始位置而且数组中第i个的值等于第i-1个的话，则跳过i（这种去重的方式允许不同层级的回溯具有相同的元素值，因为允许在当前迭代的第一个元素的位置进入下一层）</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">参考力扣子集II</a></li>
<li>另一种方式是使用<code>used</code>数组来记录，跳过所有与上一个元素相同而且目前没有被使用的元素，也就是在这一层出现的重复元素。</li>
<li><img src="/imgs/e603911ea5befcd9846a5d3ab96f008fd5e373ac9bf6c7720c932888e2a59505.png" alt="picture 0">  </li>
<li>如果这个位置和上个位置相同，而且上个位置的数字在另外的分支里被使用过（也就是<code>used[i-1] == false</code>），那么跳过这个数字来去重</li>
<li>在这个位置中被使用过的数字的<code>used</code>是<code>true</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; path;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; seq, vector&lt;<span class="keyword">bool</span>&gt;&amp; used, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        seq.<span class="built_in">push_back</span>(nums[start]);</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (seq.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(seq);</span><br><span class="line">            seq.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">backtracking</span>(nums, seq, used, i);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        seq.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] == nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">            <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, seq, used, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-90-子集-II"><a href="#Leetcode-90-子集-II" class="headerlink" title="Leetcode 90. 子集 II"></a>Leetcode 90. 子集 II</h2><ul>
<li>此题不讲究顺序，所以可以使用先排序再相邻去重的方式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="comment">// vector&lt;bool&gt; used;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; ans, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(nums[start]);</span><br><span class="line">        </span><br><span class="line">        ret.<span class="built_in">push_back</span>(ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start+<span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[start] = true;</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, ans, i);</span><br><span class="line">            <span class="comment">// used[start] = false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        ret.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="comment">// used = vector&lt;bool&gt;(nums.size(), false);</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[i] = true;</span></span><br><span class="line">            <span class="built_in">backtracking</span>(nums, tmp, i);</span><br><span class="line">            <span class="comment">// used[i] = false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-491-非递减子序列"><a href="#Leetcode-491-非递减子序列" class="headerlink" title="Leetcode 491. 非递减子序列"></a>Leetcode 491. 非递减子序列</h2><ul>
<li>注意此题不能手动重新排序数组</li>
<li>因此需要防止<strong>同一层中出现重复的</strong>，使用set</li>
<li>每个递归函数自己定义自己的set，只考虑自己这一层是否出现过重复的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; used;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used.<span class="built_in">count</span>(nums[i]))<span class="keyword">continue</span>;</span><br><span class="line">            used.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">            <span class="built_in">recur</span>(nums, seq, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; seq, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(seq.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(seq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        seq.<span class="built_in">push_back</span>(nums[start]);</span><br><span class="line">        <span class="keyword">if</span>(seq.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)</span><br><span class="line">            ret.<span class="built_in">push_back</span>(seq);</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(used.<span class="built_in">count</span>(nums[i]) || nums[i]&lt;seq.<span class="built_in">back</span>())<span class="keyword">continue</span>;</span><br><span class="line">            used.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="built_in">recur</span>(nums, seq, i);</span><br><span class="line">            <span class="comment">// used.erase(i);</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        seq.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-40-组合总和-II"><a href="#Leetcode-40-组合总和-II" class="headerlink" title="Leetcode 40. 组合总和 II"></a>Leetcode 40. 组合总和 II</h2><ul>
<li>注意此题的去重方法，是放在<strong>循环中</strong></li>
<li>如果上一个元素与这个元素相等而且上一个元素与这个元素没出现在同一个数组之中</li>
<li>则说明在之前的某个位置，上一个元素<strong>必定在这个位置已经出现过了</strong><ul>
<li>因为没出现过，意味着上一个元素与当前的这个元素在不同的尝试中被遍历过一次了，再来一次必然会重复<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="comment">// vector&lt;bool&gt; used;</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">// used = vector&lt;bool&gt;(candidates.size(), false);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;candidates.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; candidates[i<span class="number">-1</span>] == candidates[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[i] = true;</span></span><br><span class="line">            <span class="built_in">traversal</span>(candidates, target, i, ans);</span><br><span class="line">            <span class="comment">// used[i] = false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; c, <span class="keyword">int</span> target, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(c[start]);</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= c[start])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == c[start])</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(ans);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i&lt;c.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start+<span class="number">1</span> &amp;&amp; c[i] == c[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">traversal</span>(c, target-c[start], i, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-93-复原IP地址"><a href="#Leetcode-93-复原IP地址" class="headerlink" title="Leetcode 93. 复原IP地址"></a>Leetcode 93. 复原IP地址</h2></li>
</ul>
</li>
<li>注意此题的去重方式，主要是决定在哪个位置结束</li>
<li>注意，必须是前面<strong>明确声明要结束了</strong>的地址才可以作为答案之一</li>
<li><strong>否则会重复</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="comment">// ans+=s[0];</span></span><br><span class="line">        <span class="built_in">traversal</span>(s, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(string&amp; s, <span class="keyword">int</span> start, <span class="keyword">int</span> cnt, <span class="keyword">int</span> remain, string ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==s.<span class="built_in">size</span>()&amp;&amp;cnt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(remain == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(ans.<span class="built_in">substr</span>(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == s.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span> || cnt == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=<span class="string">&quot;.&quot;</span>;</span><br><span class="line">            ans+=s[start];</span><br><span class="line">            <span class="keyword">if</span>(s[start] ==<span class="string">&#x27;0&#x27;</span>)  </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 结束本节</span></span><br><span class="line">                <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, <span class="number">3</span>, remain<span class="number">-1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 结束本节，1个数字</span></span><br><span class="line">                <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, <span class="number">3</span>, remain<span class="number">-1</span>, ans);</span><br><span class="line">                <span class="comment">// 继续本节，最少有2个数字</span></span><br><span class="line">                <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, <span class="number">1</span>, remain<span class="number">-1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">1</span> || cnt == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=s[start];</span><br><span class="line">            <span class="comment">// 如果超出限制 则提前结束</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stoi</span>(ans.<span class="built_in">substr</span>(ans.<span class="built_in">size</span>()-cnt<span class="number">-1</span>))&gt;<span class="number">255</span>)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 在只有2个数字的时候结束本节</span></span><br><span class="line">                <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, <span class="number">3</span>, remain, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续本节cnt = 2(本节有3个数字)或者cnt = 3</span></span><br><span class="line">            <span class="built_in">traversal</span>(s, start+<span class="number">1</span>, cnt+<span class="number">1</span>, remain, ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">二叉树的非递归遍历（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-17 12:38:29" itemprop="dateCreated datePublished" datetime="2024-01-17T12:38:29+08:00">2024-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:41:25" itemprop="dateModified" datetime="2024-04-27T15:41:25+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><ul>
<li>通过在遍历过一次的节点前面加入一个NULL指针，提示下一个节点遍历过一次了<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>遍历过一次的节点第二次直接输出<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>针对没访问过的节点，先把他的左孩子入栈，再把NULL和自身入栈，再入栈右孩子<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>针对没访问过的节点，先把自己和NULL入栈，再把右孩子入栈，再把左孩子入栈</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2024/01/11/%E6%90%BA%E7%A8%8B%E5%BA%93%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/11/%E6%90%BA%E7%A8%8B%E5%BA%93%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">协程库实现（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-11 17:50:36" itemprop="dateCreated datePublished" datetime="2024-01-11T17:50:36+08:00">2024-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/52886">参考</a><h2 id="ucontext-h上下文切换"><a href="#ucontext-h上下文切换" class="headerlink" title="ucontext.h上下文切换"></a><code>ucontext.h</code>上下文切换</h2></li>
<li>上下文结构体定义</li>
<li> <code>mcontext_t</code>类型与机器相关，并且不透明.<code>ucontext_t</code>结构体则至少拥有以下几个域:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span>         uc_sigmask;</span><br><span class="line">    <span class="keyword">stack_t</span>          uc_stack;</span><br><span class="line">    <span class="keyword">mcontext_t</span>       uc_mcontext;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure></li>
<li>当当前上下文(如使用makecontext创建的上下文）运行终止时系统会恢复<code>uc_link</code>指向的上下文；<code>uc_sigmask</code>为该上下文中的阻塞信号集合；<code>uc_stack</code>为该上下文中使用的栈；<code>uc_mcontext</code>保存的上下文的特定机器表示，包括调用线程的特定寄存器等<h3 id="四个操作函数"><a href="#四个操作函数" class="headerlink" title="四个操作函数"></a>四个操作函数</h3></li>
<li><code>int getcontext(ucontext_t *ucp);</code><ul>
<li>初始化ucp结构体，将当前的上下文保存到ucp中</li>
</ul>
</li>
<li><code>int setcontext(const ucontext_t *ucp);</code><ul>
<li>设置当前的上下文为ucp，setcontext的上下文ucp应该通过getcontext或者makecontext取得，如果调用成功则不返回。</li>
<li>如果上下文是通过调用getcontext()取得,程序会继续执行这个调用。如果上下文是通过调用makecontext取得,程序会调用makecontext函数的第二个参数指向的函数，如果func函数返回,则恢复makecontext第一个参数指向的上下文第一个参数指向的上下文context_t中指向的uc_link</li>
<li>如果uc_link为NULL,则线程退出。</li>
</ul>
</li>
<li><code>void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</code><ul>
<li> <code>makecontext</code>修改通过<code>getcontext</code>取得的上下文ucp(这意味着调用makecontext前必须先调用getcontext)。然后给该上下文指定一个栈空间ucp-&gt;stack，设置后继的上下文ucp-&gt;uc_link.</li>
<li> 当上下文通过setcontext或者swapcontext激活后，执行func函数，argc为func的参数个数，后面是func的参数序列。当func执行返回后，继承的上下文被激活，如果继承上下文为NULL时，线程退出</li>
</ul>
</li>
<li><code>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</code><ul>
<li><strong>保存当前上下文到oucp结构体中</strong>，<strong>然后激活upc上下文</strong>。 </li>
</ul>
</li>
<li>如果执行成功，<code>getcontext</code>返回0，<code>setcontext</code>和<code>swapcontext</code>不返回；如果执行失败，<code>getcontext</code>,<code>setcontext</code>,<code>swapcontext</code>返回-1，并设置对于的errno.</li>
</ul>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getcontext</td>
<td>获取上下文</td>
</tr>
<tr>
<td>setcontext</td>
<td>设置上下文</td>
</tr>
<tr>
<td>swapcontext</td>
<td>保存当前上下文，切换上下文</td>
</tr>
<tr>
<td>makecontext</td>
<td>创建新的上下文</td>
</tr>
</tbody></table>
<ul>
<li>例子<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">ucontext_t</span> context;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;context);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setcontext</span>(&amp;context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上述函数会不断重复输出<code>Hello World</code>，因为<code>getcontext</code>将上下文设置在了输出之前，<code>setcontext</code>每次都把整个执行流返回到输出的位置</li>
</ul>
<h3 id="更换为执行时间最短先服务逻辑的调度器版本"><a href="#更换为执行时间最短先服务逻辑的调度器版本" class="headerlink" title="更换为执行时间最短先服务逻辑的调度器版本"></a>更换为执行时间最短先服务逻辑的调度器版本</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Winnerhust/uthread">参考的原版</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/frankzjz219/coThread">我改进代码的github仓库</a></li>
<li>使用了优先级队列重写携程选择逻辑，切换的时候会选择当前已经运行时间最短的携程上处理机执行</li>
<li>运行结果<ul>
<li><img src="/imgs/941347f9abd1720738aefc5d97931550f21aa9612e6620b2f0e59f887e23f2f5.png" alt="picture 0">  </li>
<li>四个线程的优先级分别是4，3，2，1，可见是符合设置的<h3 id="1月12日修改"><a href="#1月12日修改" class="headerlink" title="1月12日修改"></a>1月12日修改</h3></li>
</ul>
</li>
<li>修改为了多线程版本，分别调度，分别设置优先级</li>
<li><img src="/imgs/e31840ca773951d3d8406fb1a527485c5ca3492df2b7055bd5d175e851c5e9d0.png" alt="picture 1">  </li>
<li><img src="/imgs/d78782a55f0dc69ab765b2e962fede515994cce6269969ff93cea72ac87690e4.png" alt="picture 2">  </li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>C/C++文件编译的时候<strong>每个源文件都是独立编译的</strong>，这样会导致即使头文件使用了<code>ifndef</code>之类的保护，仍然可能在整个项目中被<strong>不同的文件</strong>引用多次<ul>
<li>因此如果头文件中出现了函数或者是变量的定义的话，这个变量在整个项目中会被定义多次</li>
<li>因此头文件中只能声明，变量使用<code>extern</code>关键字声明</li>
<li>必须定义的函数用<code>inline</code></li>
</ul>
</li>
<li>注意类的静态<code>static</code>成员变量必须在某个源文件中定义，才能在其他源文件中使用类名和作用域运算符<code>::</code>访问</li>
<li>C++可以使用宏<code>__FILE__</code>判断自己所处的文件名称</li>
<li><code>makecontext</code>的第二个参数无论传入的是什么函数，都要将其转换为<code>void(*)(void)</code>类型的函数指针，然后再给出参数</li>
<li>执行流路径<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------调度器或main中-----------------</span><br><span class="line">创建协程(create)--&gt;</span><br><span class="line">  获取互斥锁</span><br><span class="line">  使用makecontext生成开始执行协程函数的上下文</span><br><span class="line">  令目标函数的上下文的后继位置时刻指向调度器schedule的上下文main</span><br><span class="line">  释放互斥锁</span><br><span class="line">切换到协程(resume)--&gt;</span><br><span class="line">  将当前的上下文保存在调度器schedule.main中，切换到目标函数的上下文</span><br><span class="line">-----------协程函数中----------------</span><br><span class="line">切换回main(yield)--&gt;</span><br><span class="line">  获取锁</span><br><span class="line">  将协程当前的上下文保存在ctx中</span><br><span class="line">  释放锁</span><br><span class="line">  切换回之前指向的main上下文</span><br><span class="line">-----------------main中-----------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>因为添加协程<code>create</code>函数与协程调度器不在一个线程中，可能会有竞争关系，因此添加了互斥锁防止冲突</li>
</ul>
<h2 id="lt-setjmp-h-gt-实现切换"><a href="#lt-setjmp-h-gt-实现切换" class="headerlink" title="&lt;setjmp.h&gt;实现切换"></a><code>&lt;setjmp.h&gt;</code>实现切换</h2><h3 id="setjmp-函数："><a href="#setjmp-函数：" class="headerlink" title="setjmp 函数："></a><code>setjmp</code> 函数：</h3><ul>
<li><p><code>setjmp</code> 用于保存当前程序的执行状态，并返回一个整数值。</p>
</li>
<li><p>当首次调用 <code>setjmp</code> 时，它返回0，表示保存了当前执行状态。</p>
</li>
<li><p>当从 <code>longjmp</code> 调用返回时，<code>setjmp</code> 返回一个非零值，通常用于区分<strong>正常返回和通过 <code>longjmp</code> 返回</strong>。</p>
<h3 id="longjmp函数"><a href="#longjmp函数" class="headerlink" title="longjmp函数"></a><code>longjmp</code>函数</h3></li>
<li><p><code>longjmp</code> 用于恢复之前由 <code>setjmp</code> 保存的执行状态。</p>
</li>
<li><p>它接受两个参数：保存的执行状态（由 <code>setjmp</code> 返回的值）和一个非零的返回值。</p>
</li>
<li><p>调用 <code>longjmp</code> 会导致程序跳转到相应 <code>setjmp</code> 处，并且 <code>setjmp</code> 返回的值为 <code>longjmp</code> 的返回值。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3></li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82492121">参考</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;do not allow division by 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">longjmp</span>(env, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">setjmp</span>(env);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;return from setjmp\n&quot;</span>);</span><br><span class="line">        <span class="built_in">my_func</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;return from longjmp: %d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-语言的锁机制"><a href="#C-语言的锁机制" class="headerlink" title="C++语言的锁机制"></a>C++语言的锁机制</h2><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a><code>unique_lock</code></h3></li>
<li><p><code>#include &lt;mutex&gt;</code>和<code>#include &lt;thread&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(myMutex)</span></span>;  <span class="comment">// 构造 unique_lock，并锁定互斥量</span></span><br></pre></td></tr></table></figure></li>
<li><p>构造就是加锁</p>
</li>
<li><p>析构就是解锁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lock.<span class="built_in">lock</span>();  <span class="comment">// 手动锁定互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁定期间的其他操作...</span></span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">unlock</span>();  <span class="comment">// 手动释放锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 unique_lock 离开作用域时，会自动释放锁</span></span><br></pre></td></tr></table></figure></li>
<li><p>同样支持手动操作，加锁和解锁</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2023/12/19/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/19/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">leetcode字符串题目详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-19 10:38:33" itemprop="dateCreated datePublished" datetime="2023-12-19T10:38:33+08:00">2023-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-16 23:23:50" itemprop="dateModified" datetime="2024-06-16T23:23:50+08:00">2024-06-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode-49-字母异位词分组"><a href="#Leetcode-49-字母异位词分组" class="headerlink" title="Leetcode 49. 字母异位词分组"></a>Leetcode 49. 字母异位词分组</h2><ul>
<li>此题除了使用哈希或者类似哈希的方式之外，还有一个简单的方式</li>
<li>就是将字符串直接按字母排序，相同的就是字母异位词<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string tmp = s;</span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            m[tmp].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : m)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(i.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-299-猜数字游戏"><a href="#Leetcode-299-猜数字游戏" class="headerlink" title="Leetcode 299. 猜数字游戏"></a>Leetcode 299. 猜数字游戏</h2></li>
<li>遍历两个字符串，假如相同的话就加一个公牛，假如不同的话就对各自的char做数量统计（0, 1, 2, …, 9）各有多少个</li>
<li>最终母牛的结果是每个类型的char中谜底和猜测中较小的一个<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bulls = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cntS</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">cntG</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret[i] == guess[i]) &#123;</span><br><span class="line">                ++bulls;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++cntS[secret[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">                ++cntG[guess[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            cows += <span class="built_in">min</span>(cntS[i], cntG[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(bulls) + <span class="string">&quot;A&quot;</span> + <span class="built_in">to_string</span>(cows) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-316-去除重复字母"><a href="#Leetcode-316-去除重复字母" class="headerlink" title="Leetcode 316. 去除重复字母"></a>Leetcode 316. 去除重复字母</h2><ul>
<li>对已经入栈的字符而言，只要后面还出现而且字典顺序大于当前字符的一律弹出，将标记重新设置为0</li>
<li>然后加入当前字符，并且设置已经过标记为1</li>
<li>意义就是将较大而且后面还出现的字符的出现尽量推迟靠后<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(<span class="number">26</span>)</span>, <span class="title">num</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">            num[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string stk;</span><br><span class="line">        <span class="comment">// 对已经入栈的字符而言，只要后面还出现而且字典顺序大于当前字符的一律弹出，将标记重新设置为0</span></span><br><span class="line">        <span class="comment">// 然后加入当前字符，并且设置已经过标记为1</span></span><br><span class="line">        <span class="comment">// 意义就是将较大而且后面还出现的字符的出现尽量推迟靠后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[ch - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">back</span>() &gt; ch) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num[stk.<span class="built_in">back</span>() - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        vis[stk.<span class="built_in">back</span>() - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                        stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                stk.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            num[ch - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2023/12/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">动态规划（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-12 17:01:13" itemprop="dateCreated datePublished" datetime="2023-12-12T17:01:13+08:00">2023-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:41:25" itemprop="dateModified" datetime="2024-04-27T15:41:25+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode-343-整数拆分"><a href="#Leetcode-343-整数拆分" class="headerlink" title="Leetcode 343. 整数拆分"></a>Leetcode 343. 整数拆分</h2><ul>
<li>此题也是使用动态规划，主要是分两种情况讨论<ul>
<li>将一个数字拆成a和b，b使用之前拆分的最大乘积</li>
<li>b不拆分，直接相乘<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxArr</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        maxArr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        maxArr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                maxArr[i] = <span class="built_in">max</span>(j*maxArr[i-j], maxArr[i]); <span class="comment">// 拆分</span></span><br><span class="line">                maxArr[i] = <span class="built_in">max</span>(j*(i-j), maxArr[i]); <span class="comment">// 不拆分，就两个数字算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArr[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-718-最长重复子数组"><a href="#Leetcode-718-最长重复子数组" class="headerlink" title="Leetcode 718. 最长重复子数组"></a>Leetcode 718. 最长重复子数组</h2></li>
</ul>
</li>
<li>递推，使用上一个位置的连续长度加上这个位置是否相等递推出这个位置的</li>
<li>如果相等，就是到<code>i-1</code>,<code>j-1</code>位置为止的连续长度+1<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(nums1.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(nums2.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;nums2.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        map[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        map[i][j] = map[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxLen = <span class="built_in">max</span>(map[i][j], maxLen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-115-不同的子序列"><a href="#Leetcode-115-不同的子序列" class="headerlink" title="Leetcode 115. 不同的子序列"></a>Leetcode 115. 不同的子序列</h2><ul>
<li>因为是从s中找t，所以递归的主要顺序是t找到了哪个位置</li>
<li>假如s的<code>i</code>位置与t的<code>j</code>相等，那么该位置的子字符串种类就是<code>i-1</code>和<code>j-1</code>位置位置+t到<code>j</code>位置时之前的种类之和</li>
<li>不等的话，就继承s字符串在之前位置，j字符串在当前位置的种类数量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(t.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=t.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j]=(map[i<span class="number">-1</span>][j<span class="number">-1</span>]+map[i<span class="number">-1</span>][j])%((<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>); <span class="comment">// 此处就是求和t字符串到j位置的所有可能性（包括s字符串之前的可能性）</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = map[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-583-两个字符串的删除操作"><a href="#Leetcode-583-两个字符串的删除操作" class="headerlink" title="Leetcode 583. 两个字符串的删除操作"></a>Leetcode 583. 两个字符串的删除操作</h2><ul>
<li><p>从<code>i-1</code>和<code>j-1</code>递推<code>i</code>和<code>j</code></p>
</li>
<li><p>当<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>相同的时候，<code>dp[i][j] = dp[i - 1][j - 1]</code></p>
</li>
<li><p>当<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>不相同的时候，有三种情况：</p>
<ul>
<li><p>情况一：删<code>word1[i - 1]</code>，最少操作次数为<code>dp[i - 1][j] + 1</code></p>
</li>
<li><p>情况二：删<code>word2[j - 1]</code>，最少操作次数为<code>dp[i][j - 1] + 1</code></p>
</li>
<li><p>情况三：同时删<code>word1[i - 1]</code>和<code>word2[j - 1]</code>，操作的最少次数为<code>dp[i - 1][j - 1] + 2</code></p>
</li>
</ul>
</li>
<li><p>那最后当然是取最小值，所以当<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>不相同的时候，递推公式：<code>dp[i][j] = min(&#123;dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1&#125;);</code></p>
</li>
<li><p>因为 <code>dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2</code>，所以递推公式可简化为：<code>dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</code></p>
<ul>
<li>因为对于<code>dp[i][j-1]</code>而言，就是第一个字符串到<code>i-1</code>位置和第二个字符串到<code>j-2</code>位置，第一个字符串增加一步删除就可以到<code>i-2</code>和<code>j-2</code>的位置，因此二者只差一步</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode-72-编辑距离"><a href="#Leetcode-72-编辑距离" class="headerlink" title="Leetcode 72. 编辑距离"></a>Leetcode 72. 编辑距离</h2><ul>
<li>此题遇上一个类似，只是增加了几个操作<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-1035-不相交的线"><a href="#Leetcode-1035-不相交的线" class="headerlink" title="Leetcode 1035. 不相交的线"></a>Leetcode 1035. 不相交的线</h2><ul>
<li>此题同样是类似的动态规划</li>
<li>利用<code>i-1</code>和<code>j-1</code>推导<code>i</code>和<code>j</code>位置的值</li>
<li>如果当前位置相等，此时则是在<code>i-1</code>和<code>j-1</code>位置的基础上<code>+1</code></li>
<li>因为递推的上一级是<code>i-1</code>和<code>j-1</code>，这就导致<u>之前的连线最多只涉及之前的数字，不会于新加入的相交</u>，从而防止了相交<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(B.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B.<span class="built_in">size</span>(); j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[A.<span class="built_in">size</span>()][B.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-1143-最长公共子序列"><a href="#Leetcode-1143-最长公共子序列" class="headerlink" title="Leetcode 1143. 最长公共子序列"></a>Leetcode 1143. 最长公共子序列</h2><ul>
<li><strong>暴力递归方法（或者动态规划）</strong></li>
<li>每次两个字符串往前走一个位置（比如到达i, j），假如两个字符串在这个位置的值相同，那么就以(i-1, j-1)位置的最长子串的长度+1作为当前位置的值</li>
<li>否则，就从两个字符串分别到（i-1，j）和（i，j-1）位置选择一个较大的作为结果<ul>
<li><strong><u>这么做的关键原因（也就是遇上一题的区别）就是因为这个不必须是连续的</u></strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="LeetCode-72-编辑距离"><a href="#LeetCode-72-编辑距离" class="headerlink" title="LeetCode 72. 编辑距离"></a>LeetCode 72. 编辑距离</h2><ul>
<li>创建一个二维数组，一个维度是第一个字符串的长度，另一个是第二个字符串的长度</li>
<li>当 <code>word1[i] == word2[j]</code>，<code>dp[i][j] = dp[i-1][j-1]</code></li>
<li>当 <code>word1[i] != word2[j]</code>，<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code></li>
<li>其中，<code>dp[i-1][j-1]</code> 表示<strong>替换</strong>操作，<code>dp[i-1][j]</code> 表示<strong>删除</strong>操作，<code>dp[i][j-1]</code> 表示<strong>插入</strong>操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> n = word2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, INT_MAX));</span><br><span class="line">        map[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>&amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = map[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = map[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = map[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = <span class="built_in">min</span>(map[i<span class="number">-1</span>][j], <span class="built_in">min</span>(map[i][j<span class="number">-1</span>], map[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><ul>
<li>注意循环顺序，从中间到两边，所以要从<strong>末端开始</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><ul>
<li>此题大体与上面类似，唯一的区别是不需连续</li>
<li>因此需要在条件不成立的时候使用<code>dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</code>保存结果递推<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) </span><br><span class="line">                    &#123; </span><br><span class="line">                        <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        dp[i][j] = j-i+<span class="number">1</span>;</span><br><span class="line">                        result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                        result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-673-最长递增子序列的个数"><a href="#Leetcode-673-最长递增子序列的个数" class="headerlink" title="Leetcode 673. 最长递增子序列的个数"></a>Leetcode 673. 最长递增子序列的个数</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/description/">链接</a></li>
<li>这道题目我们要一起维护两个数组。</li>
<li>dp[i]：i之前（包括i）最长递增子序列的长度为dp[i]</li>
<li>count[i]：以nums[i]为结尾的字符串，最长递增子序列的个数为count[i]</li>
<li>那么在<code>nums[i] &gt; nums[j]</code>前提下，如果在[0, i-1]的范围内，找到了j，使得<code>dp[j] + 1 &gt; dp[i]</code>，说明找到了一个更长的递增子序列。</li>
<li>那么以j为结尾的子串的最长递增子序列的个数，就是最新的以i为结尾的子串的最长递增子序列的个数，即：<code>count[i] = count[j]</code>。</li>
<li>在<code>nums[i] &gt; nums[j]</code>前提下，如果在[0, i-1]的范围内，找到了j，使得<code>dp[j] + 1 == dp[i]</code>，说明找到了<strong>两个相同长度</strong>的递增子序列。</li>
<li>那么以i为结尾的子串的最长递增子序列的个数 就应该加上以j为结尾的子串的最长递增子序列的个数，即：<code>count[i] += count[j];</code>    </li>
<li>注意初始化为1<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        count[i] = count[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j] + <span class="number">1</span> == dp[i]) &#123;</span><br><span class="line">                        count[i] += count[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i] &gt; maxCount) maxCount = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxCount == dp[i]) result += count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul>
<li>从大序列中找小序列的问题，假如是连续序列的话，不满足对应的条件的时候可以不处理</li>
<li>但是假如不是连续序列的话，往往需要类似于<code>dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</code>的操作来保存递推结果</li>
</ul>
<h3 id="Leetcode-486-预测赢家"><a href="#Leetcode-486-预测赢家" class="headerlink" title="Leetcode 486. 预测赢家"></a>Leetcode 486. 预测赢家</h3><ul>
<li>此题使用起始和结束位置作为两个坐标的二维数组动态规划</li>
<li>记忆化搜索的递归(<a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1045">原题</a>)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> beg, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&#x27;!&#x27;;</span></span><br><span class="line">    <span class="keyword">if</span>(beg&gt;end || beg&gt;=arr.<span class="built_in">size</span>() || end&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(beg == end)<span class="keyword">return</span> arr[beg];</span><br><span class="line">    <span class="keyword">if</span>(res[beg][end]&gt;=<span class="number">0</span>)<span class="keyword">return</span> res[beg][end];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">max</span>(arr[beg]+<span class="built_in">min</span>(<span class="built_in">traversal</span>(arr, beg+<span class="number">1</span>, end<span class="number">-1</span>), <span class="built_in">traversal</span>(arr, beg+<span class="number">2</span>, end)),</span><br><span class="line">        arr[end]+<span class="built_in">min</span>(<span class="built_in">traversal</span>(arr, beg+<span class="number">1</span>, end<span class="number">-1</span>), <span class="built_in">traversal</span>(arr, beg, end<span class="number">-2</span>)));</span><br><span class="line">    res[beg][end] = ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    cin&gt;&gt;cnt;</span><br><span class="line">    res = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(cnt, vector&lt;<span class="keyword">int</span>&gt;(cnt, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(cnt, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        sum+=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i][i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(first, sum-first)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>动态规划的答案</li>
<li>dp[i][j] 表示两个玩家在数组 i 到 j 区间内游戏能赢对方的差值（i &lt;= j）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">PredictTheWinner</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示两个玩家在数组 i 到 j 区间内游戏能赢对方的差值（i &lt;= j）</span></span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">22</span>][<span class="number">22</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 当i == j的时候，nums[i]就是dp[i][j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>((nums[i] - dp[i + <span class="number">1</span>][j]), (nums[j] - dp[i][j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][nums.<span class="built_in">size</span>() - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2023/12/06/Leetcode%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/06/Leetcode%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE/" class="post-title-link" itemprop="url">Leetcode数组题目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-06 15:12:07" itemprop="dateCreated datePublished" datetime="2023-12-06T15:12:07+08:00">2023-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-04 22:53:43" itemprop="dateModified" datetime="2024-07-04T22:53:43+08:00">2024-07-04</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode-283-移动零"><a href="#Leetcode-283-移动零" class="headerlink" title="Leetcode 283. 移动零"></a>Leetcode 283. 移动零</h2><ul>
<li>此题是使用双指针法<ul>
<li>一个指针是依次向前的</li>
<li>另一个是指向非0区的左边界</li>
<li>每次遇到一个非0的数字，就把他跟左边界位置的数字互换然后将左边界右移一位<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nonZero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[nonZero]);</span><br><span class="line">                ++nonZero;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-560-和为k的子数组"><a href="#Leetcode-560-和为k的子数组" class="headerlink" title="Leetcode 560.和为k的子数组"></a>Leetcode 560.和为k的子数组</h2><ul>
<li>循环一次，每次寻找每个位置的前缀和</li>
<li>然后寻找字典中是否存在<code>pre-k</code></li>
<li>假如存在的话，意味着从<code>pre-k</code>的结束位置开始，到当前的位置结束的一段数组的和是k<ul>
<li>map中<code>pre-k</code>有多少个，增加多少个到结果中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x:nums) &#123;</span><br><span class="line">            pre += x; <span class="comment">// 这一步是前缀和</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                count += mp[pre - k]; <span class="comment">// 可行的计数加上这个计数</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++; <span class="comment">// 添加上当前计算的前缀和到字典</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-33-搜索旋转排序数组"><a href="#Leetcode-33-搜索旋转排序数组" class="headerlink" title="Leetcode 33. 搜索旋转排序数组"></a>Leetcode 33. 搜索旋转排序数组</h2><ul>
<li>此题是针对一个向后平移过的有序数组进行操作</li>
<li>如果数组的第一个元素小于当前元素，则当前元素位于数组的前半部分，否则是后半部分</li>
<li>然后在自己的区间内二分即可，与数组的最左侧和最右侧元素比较<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-977-有序数组的平方"><a href="#Leetcode-977-有序数组的平方" class="headerlink" title="Leetcode 977. 有序数组的平方"></a>Leetcode 977. 有序数组的平方</h2></li>
<li>此题因为是针对一个已经排序的数组，所以最大值不是在数组的头部就是在数组的尾部，因此每次只要从后往前依次插入当前首部和尾部平方值较大的一个元素即可</li>
<li>注意插入是倒序的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[begin]*nums[begin]&lt;nums[end]*nums[end])</span><br><span class="line">            &#123;</span><br><span class="line">                ret[k--] = nums[end]*nums[end];</span><br><span class="line">                --end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                ret[k--] = nums[begin]*nums[begin];</span><br><span class="line">                ++begin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LeetCode-153-寻找旋转排序数组中的最小值"><a href="#LeetCode-153-寻找旋转排序数组中的最小值" class="headerlink" title="LeetCode 153. 寻找旋转排序数组中的最小值"></a>LeetCode 153. 寻找旋转排序数组中的最小值</h2><ul>
<li>我们考虑数组中的最后一个元素<code>x</code>：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于<code>x</code>；而在最小值左侧的元素，它们的值一定都严格大于<code>x</code>。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-4-寻找两个正序数组的中位数"><a href="#Leetcode-4-寻找两个正序数组的中位数" class="headerlink" title="Leetcode 4. 寻找两个正序数组的中位数"></a>Leetcode 4. 寻找两个正序数组的中位数</h2></li>
<li>此题较为复杂，建议查看<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/?envType=study-plan-v2&envId=top-100-liked">题解</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="keyword">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="keyword">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-136-只出现一次的数字"><a href="#Leetcode-136-只出现一次的数字" class="headerlink" title="Leetcode 136. 只出现一次的数字"></a>Leetcode 136. 只出现一次的数字</h2><ul>
<li>对整个数组元素挨个求异或，最后剩下的一个就是只出现一次的那个</li>
<li>因为出现过两次的会因为自己异或自己而变为0<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LeetCode-31-下一个排列"><a href="#LeetCode-31-下一个排列" class="headerlink" title="LeetCode 31. 下一个排列"></a>LeetCode 31. 下一个排列</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/">参考</a></li>
<li>从后向前 查找第一个 相邻升序 的元素对 <code>(i,j)</code>，满足 <code>A[i] &lt; A[j]</code>。此时 <code>[j,end)</code> 必然是降序</li>
<li>在 <code>[j,end)</code> 从后向前 查找第一个满足 <code>A[i] &lt; A[k]</code> 的 <code>k</code>。<code>A[i]</code>、<code>A[k]</code> 分别就是上文所说的「小数」、「大数」</li>
<li>将 <code>A[i]</code> 与 <code>A[k]</code> 交换</li>
<li>可以断定这时 <code>[j,end)</code> 必然是降序，逆置 <code>[j,end)</code>，使其升序</li>
<li>如果在步骤 1 找不到符合的相邻元素对，说明当前 <code>[begin,end)</code> 为一个降序顺序，则直接跳到步骤 4</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=nums.<span class="built_in">size</span>(),i=l<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=l<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//找出nums[i]后面大于nums[i]的最小数的下标</span></span><br><span class="line">            <span class="keyword">while</span>(nums[j]&lt;=nums[i])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>());<span class="comment">//交换完后对nums[i]后面的数字进行从小到大排列</span></span><br><span class="line">            <span class="comment">//因为此时nums.begin()+i+1到nums.end()一定是降序排列,所以只需reverse就是从小到大排列了</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//说明是最大排列,下一个应该是最小排列</span></span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode-452-用最少数量的箭引爆气球"><a href="#Leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="Leetcode 452. 用最少数量的箭引爆气球"></a>Leetcode 452. 用最少数量的箭引爆气球</h2><ul>
<li>按照区间的<strong>右端点排序</strong>，取右端点的值，直到目前的区间的右端点的值小于下一个区间的左端点的值的时候就说明没有重叠部分了，需要增加新的区间<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; u, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> pos = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; balloon: points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (balloon[<span class="number">0</span>] &gt; pos) &#123;</span><br><span class="line">                pos = balloon[<span class="number">1</span>];</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2023/12/05/Leetcode%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/05/Leetcode%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">Leetcode图相关遍历</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-05 16:25:50" itemprop="dateCreated datePublished" datetime="2023-12-05T16:25:50+08:00">2023-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图的拓扑排序"><a href="#图的拓扑排序" class="headerlink" title="图的拓扑排序"></a>图的拓扑排序</h2><h3 id="广度优先搜索（Leetcode-207-课程表）"><a href="#广度优先搜索（Leetcode-207-课程表）" class="headerlink" title="广度优先搜索（Leetcode 207.课程表）"></a>广度优先搜索（Leetcode 207.课程表）</h3><ul>
<li>用一个数组记录每个节点的进入边的数量</li>
<li>开始的时候将所有入度为0的点加入队列</li>
<li>依次从队列中弹出点，将从这个点出发指向的所有点的入度-1，然后将跟这个点相关的路径全部删除<ul>
<li>假如此时遇到点的入度是0的话，将这个点加入队列</li>
</ul>
</li>
<li>将队列中弹出的点加入输出序列中</li>
<li>假如最后图上的<strong>所有点都在输出序列中</strong>，说明无环，否则有环<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vMap</span>(numCourses);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inCnt</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prerequisites.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vMap[prerequisites[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            ++inCnt[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inCnt[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:vMap[temp])</span><br><span class="line">            &#123;</span><br><span class="line">                --inCnt[i];</span><br><span class="line">                <span class="keyword">if</span>(inCnt[i] == <span class="number">0</span>)q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            vMap[temp] = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&lt;numCourses)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul>
<li>遍历所有节点，先标记自己被遍历过了</li>
<li>每个节点递归的遍历<strong>自己所有边</strong>指向的没有被打上遍历过的标签的节点</li>
<li>回溯的时候（也就是之后的节点都遍历结束之后）将自己添加到拓扑顺序的栈中</li>
<li>依次弹出栈中元素，得到顺序<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vertices;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span>(<span class="keyword">int</span> V) : <span class="built_in">vertices</span>(V), <span class="built_in">adjList</span>(V) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjList[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topologicalSortUtil</span><span class="params">(<span class="keyword">int</span> v, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited, stack&lt;<span class="keyword">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : adjList[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                <span class="built_in">topologicalSortUtil</span>(neighbor, visited, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(vertices, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">topologicalSortUtil</span>(i, visited, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Topological Sort: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!result.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; result.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            result.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">topologicalSort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="417-太平洋大西洋水流问问题"><a href="#417-太平洋大西洋水流问问题" class="headerlink" title="417. 太平洋大西洋水流问问题"></a>417. 太平洋大西洋水流问问题</h2></li>
<li>此题主要是使用逆向搜索</li>
<li>也就是从海边往上倒溯看能到达哪个位置，减少遍历的次数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">passed</span>(heights.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(heights[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">passedR</span>(heights.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(heights[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(heights.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(heights[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(passed[i][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">            queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            passed[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> curH = heights[t.first][t.second];</span><br><span class="line">                visited[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(t.first<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t.first<span class="number">-1</span>][t.second] &amp;&amp; heights[t.first<span class="number">-1</span>][t.second]&gt;=curH &amp;&amp; !passed[t.first<span class="number">-1</span>][t.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    passed[t.first<span class="number">-1</span>][t.second] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first<span class="number">-1</span>, t.second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.second<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t.first][t.second<span class="number">-1</span>] &amp;&amp; heights[t.first][t.second<span class="number">-1</span>]&gt;=curH &amp;&amp; !passed[t.first][t.second<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    passed[t.first][t.second<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first, t.second<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.first+<span class="number">1</span>&lt;m &amp;&amp; !visited[t.first+<span class="number">1</span>][t.second] &amp;&amp; heights[t.first+<span class="number">1</span>][t.second]&gt;=curH &amp;&amp; !passed[t.first+<span class="number">1</span>][t.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    passed[t.first+<span class="number">1</span>][t.second] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first+<span class="number">1</span>, t.second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.second+<span class="number">1</span>&lt;n &amp;&amp; !visited[t.first][t.second+<span class="number">1</span>] &amp;&amp; heights[t.first][t.second+<span class="number">1</span>]&gt;=curH &amp;&amp; !passed[t.first][t.second+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    passed[t.first][t.second+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first, t.second+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : visited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fill</span>(i.<span class="built_in">begin</span>(), i.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(passed[<span class="number">0</span>][i])<span class="keyword">continue</span>;</span><br><span class="line">            queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            passed[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, i));</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> curH = heights[t.first][t.second];</span><br><span class="line">                visited[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(t.first<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t.first<span class="number">-1</span>][t.second] &amp;&amp; heights[t.first<span class="number">-1</span>][t.second]&gt;=curH &amp;&amp; !passed[t.first<span class="number">-1</span>][t.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    passed[t.first<span class="number">-1</span>][t.second] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first<span class="number">-1</span>, t.second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.second<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t.first][t.second<span class="number">-1</span>] &amp;&amp; heights[t.first][t.second<span class="number">-1</span>]&gt;=curH &amp;&amp; !passed[t.first][t.second<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    passed[t.first][t.second<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first, t.second<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.first+<span class="number">1</span>&lt;m &amp;&amp; !visited[t.first+<span class="number">1</span>][t.second] &amp;&amp; heights[t.first+<span class="number">1</span>][t.second]&gt;=curH &amp;&amp; !passed[t.first+<span class="number">1</span>][t.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    passed[t.first+<span class="number">1</span>][t.second] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first+<span class="number">1</span>, t.second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.second+<span class="number">1</span>&lt;n &amp;&amp; !visited[t.first][t.second+<span class="number">1</span>] &amp;&amp; heights[t.first][t.second+<span class="number">1</span>]&gt;=curH &amp;&amp; !passed[t.first][t.second+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    passed[t.first][t.second+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first, t.second+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : visited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fill</span>(i.<span class="built_in">begin</span>(), i.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(passedR[i][n<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            passedR[i][n<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i, n<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> curH = heights[t.first][t.second];</span><br><span class="line">                visited[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(passed[t.first][t.second])ret.<span class="built_in">push_back</span>(&#123;t.first, t.second&#125;);</span><br><span class="line">                <span class="keyword">if</span>(t.first<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t.first<span class="number">-1</span>][t.second] &amp;&amp; heights[t.first<span class="number">-1</span>][t.second]&gt;=curH &amp;&amp; !passedR[t.first<span class="number">-1</span>][t.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    passedR[t.first<span class="number">-1</span>][t.second] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first<span class="number">-1</span>, t.second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.second<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t.first][t.second<span class="number">-1</span>] &amp;&amp; heights[t.first][t.second<span class="number">-1</span>]&gt;=curH &amp;&amp; !passedR[t.first][t.second<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    passedR[t.first][t.second<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first, t.second<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.first+<span class="number">1</span>&lt;m &amp;&amp; !visited[t.first+<span class="number">1</span>][t.second] &amp;&amp; heights[t.first+<span class="number">1</span>][t.second]&gt;=curH &amp;&amp; !passedR[t.first+<span class="number">1</span>][t.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    passedR[t.first+<span class="number">1</span>][t.second] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first+<span class="number">1</span>, t.second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.second+<span class="number">1</span>&lt;n &amp;&amp; !visited[t.first][t.second+<span class="number">1</span>] &amp;&amp; heights[t.first][t.second+<span class="number">1</span>]&gt;=curH &amp;&amp; !passedR[t.first][t.second+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    passedR[t.first][t.second+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first, t.second+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : visited)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fill</span>(i.<span class="built_in">begin</span>(), i.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(passedR[m<span class="number">-1</span>][i])<span class="keyword">continue</span>;</span><br><span class="line">            queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            passedR[m<span class="number">-1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(m<span class="number">-1</span>, i));</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> curH = heights[t.first][t.second];</span><br><span class="line">                visited[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(passed[t.first][t.second])ret.<span class="built_in">push_back</span>(&#123;t.first, t.second&#125;);</span><br><span class="line">                <span class="keyword">if</span>(t.first<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t.first<span class="number">-1</span>][t.second] &amp;&amp; heights[t.first<span class="number">-1</span>][t.second]&gt;=curH &amp;&amp; !passedR[t.first<span class="number">-1</span>][t.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    passedR[t.first<span class="number">-1</span>][t.second] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first<span class="number">-1</span>, t.second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.second<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[t.first][t.second<span class="number">-1</span>] &amp;&amp; heights[t.first][t.second<span class="number">-1</span>]&gt;=curH &amp;&amp; !passedR[t.first][t.second<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    passedR[t.first][t.second<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first, t.second<span class="number">-1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.first+<span class="number">1</span>&lt;m &amp;&amp; !visited[t.first+<span class="number">1</span>][t.second] &amp;&amp; heights[t.first+<span class="number">1</span>][t.second]&gt;=curH &amp;&amp; !passedR[t.first+<span class="number">1</span>][t.second])</span><br><span class="line">                &#123;</span><br><span class="line">                    passedR[t.first+<span class="number">1</span>][t.second] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first+<span class="number">1</span>, t.second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.second+<span class="number">1</span>&lt;n &amp;&amp; !visited[t.first][t.second+<span class="number">1</span>] &amp;&amp; heights[t.first][t.second+<span class="number">1</span>]&gt;=curH &amp;&amp; !passedR[t.first][t.second+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    passedR[t.first][t.second+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(t.first, t.second+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-827-最大人工岛"><a href="#Leetcode-827-最大人工岛" class="headerlink" title="Leetcode 827. 最大人工岛"></a>Leetcode 827. 最大人工岛</h2><ul>
<li>此题关键是要使用grid本身的空间在岛屿的<strong>每个位置上存储本身的大小</strong>方便计算</li>
<li>要额外维护一张表，将同一个岛屿的点编号为同样的，不同的岛屿编为不同的，防止最后求和的时候比如某个0的位置被<strong>同一个岛屿的多个点包围</strong>导致同一个岛屿累加了多次的重复<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">visited</span>(grid.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">identity</span>(grid.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; visQue;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;grid.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(visited[i][j] || grid[i][j] == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">                visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i, j));</span><br><span class="line">                <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;tmp.first&lt;&lt;&#x27;|&#x27;&lt;&lt;tmp.second&lt;&lt;endl;</span></span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    visQue.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                    </span><br><span class="line">                    ++cnt;</span><br><span class="line">                    <span class="keyword">if</span>(tmp.first<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[tmp.first<span class="number">-1</span>][tmp.second] &amp;&amp; grid[tmp.first<span class="number">-1</span>][tmp.second] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tmp.first<span class="number">-1</span>, tmp.second));</span><br><span class="line">                        visited[tmp.first<span class="number">-1</span>][tmp.second] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(tmp.second<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; !visited[tmp.first][tmp.second<span class="number">-1</span>] &amp;&amp; grid[tmp.first][tmp.second<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tmp.first, tmp.second<span class="number">-1</span>));</span><br><span class="line">                        visited[tmp.first][tmp.second<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(tmp.first+<span class="number">1</span>&lt;m &amp;&amp; !visited[tmp.first+<span class="number">1</span>][tmp.second] &amp;&amp; grid[tmp.first+<span class="number">1</span>][tmp.second] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tmp.first+<span class="number">1</span>, tmp.second));</span><br><span class="line">                        visited[tmp.first+<span class="number">1</span>][tmp.second] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(tmp.second+<span class="number">1</span>&lt;m &amp;&amp; !visited[tmp.first][tmp.second+<span class="number">1</span>] &amp;&amp; grid[tmp.first][tmp.second+<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(tmp.first, tmp.second+<span class="number">1</span>));</span><br><span class="line">                        visited[tmp.first][tmp.second+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; k : visQue)</span><br><span class="line">                &#123;</span><br><span class="line">                    grid[k.first][k.second] = cnt;</span><br><span class="line">                    identity[k.first][k.second] = id;</span><br><span class="line">                &#125;</span><br><span class="line">                id++;</span><br><span class="line">                visQue.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; ids;</span><br><span class="line">        <span class="keyword">int</span> maxS = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                maxS = <span class="built_in">max</span>(maxS, grid[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]&gt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j]&gt;<span class="number">0</span> &amp;&amp; ids.<span class="built_in">count</span>(identity[i<span class="number">-1</span>][j]) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ids.<span class="built_in">insert</span>(identity[i<span class="number">-1</span>][j]);</span><br><span class="line">                    sum+=grid[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>]&gt;<span class="number">0</span> &amp;&amp; ids.<span class="built_in">count</span>(identity[i][j<span class="number">-1</span>]) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ids.<span class="built_in">insert</span>(identity[i][j<span class="number">-1</span>]);</span><br><span class="line">                    sum+=grid[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;m<span class="number">-1</span> &amp;&amp; grid[i+<span class="number">1</span>][j]&gt;<span class="number">0</span> &amp;&amp; ids.<span class="built_in">count</span>(identity[i+<span class="number">1</span>][j]) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ids.<span class="built_in">insert</span>(identity[i+<span class="number">1</span>][j]);</span><br><span class="line">                    sum+=grid[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;n<span class="number">-1</span> &amp;&amp; grid[i][j+<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; ids.<span class="built_in">count</span>(identity[i][j+<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ids.<span class="built_in">insert</span>(identity[i][j+<span class="number">1</span>]);</span><br><span class="line">                    sum+=grid[i][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                maxS = <span class="built_in">max</span>(maxS, sum+<span class="number">1</span>);</span><br><span class="line">                ids.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxS;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-127-单词接龙"><a href="#Leetcode-127-单词接龙" class="headerlink" title="Leetcode 127. 单词接龙"></a>Leetcode 127. 单词接龙</h2><ul>
<li>此题是讲字母相邻的单词组织成一张图</li>
<li>实际上是求图上两个点的最近距离</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/solutions/473600/dan-ci-jie-long-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150">题解</a></li>
<li>广度优先搜索法<ul>
<li>每循环一次，找一个没有接触过的位置，将其距离更新为接触过的位置+1，然后也放入队列遍历</li>
<li>注意，只考虑之前没有加入过的点，防止环的影响</li>
<li>广搜到的<strong>第一条路一定是最近的</strong>，因为广搜会一次遍历所有可能的路径<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getdistence</span><span class="params">(string&amp; s1, string&amp; s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m&lt;s1.<span class="built_in">size</span>(); ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[m]!=s2[m])++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(wordList.find(endWord) == wordList.end())return 0;</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(wordList.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; toBegin;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">int</span> endIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;wordList.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wordList[i] == endWord)endIndex = i;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getdistence</span>(wordList[i], beginWord) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// toBegin.push_back(i);</span></span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;wordList.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="built_in">getdistence</span>(wordList[i], wordList[j]);</span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    edges[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                    edges[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(endIndex == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = q.<span class="built_in">size</span>();</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">// cout&lt;&lt;wordList[tmp]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">                <span class="keyword">if</span>(wordList[tmp] == endWord)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!edges.<span class="built_in">count</span>(tmp))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; f : edges[tmp])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(visited[f])<span class="keyword">continue</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(f);</span><br><span class="line">                    visited[f] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-463-岛屿的周长"><a href="#Leetcode-463-岛屿的周长" class="headerlink" title="Leetcode 463. 岛屿的周长"></a>Leetcode 463. 岛屿的周长</h2><ul>
<li>这道题<strong>不需要使用搜索</strong></li>
<li>只使用遍历即可，招每个节点左和上的相邻节点，减去内部边界</li>
<li>不找右和下是因为怕重复<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;    <span class="comment">// 陆地数量</span></span><br><span class="line">        <span class="keyword">int</span> cover = <span class="number">0</span>;  <span class="comment">// 相邻数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    <span class="comment">// 统计上边相邻陆地</span></span><br><span class="line">                    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) cover++;</span><br><span class="line">                    <span class="comment">// 统计左边相邻陆地</span></span><br><span class="line">                    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>) cover++;</span><br><span class="line">                    <span class="comment">// 为什么没统计下边和右边？ 因为避免重复计算</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum * <span class="number">4</span> - cover * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2023/12/04/C%E5%92%8CCpp%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/04/C%E5%92%8CCpp%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">C和Cpp语言语法注意事项小结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-12-04 17:59:56" itemprop="dateCreated datePublished" datetime="2023-12-04T17:59:56+08:00">2023-12-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>43 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="STL相关"><a href="#STL相关" class="headerlink" title="STL相关"></a>STL相关</h2><ul>
<li><p>注意<code>vector&lt;&gt;.size()</code>返回的是无符号整数，<code>unsigned</code>与<strong>同样大小类型的有符号整数相加的时候会将这个有符号整数类型转换为无符号的，导致表示的意思出现区别</strong></p>
</li>
<li><p>对无符号数字给负值的时候，实际的到的值是<code>给的数字+该类型能表达的最大数字</code></p>
<h3 id="initializer-list-lt-gt"><a href="#initializer-list-lt-gt" class="headerlink" title="initializer_list&lt;&gt;"></a>initializer_list&lt;&gt;</h3></li>
<li><p>用于不定参数个数的函数的传参</p>
</li>
<li><p>只能传递同一个类型的参数</p>
</li>
<li><p>复制的时候是浅拷贝</p>
<h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p>函数|功能<br>|—|—|<br>find(begin, end, val)|在begin和end（不包括）之间找val，找不到返回end，找到返回位置迭代器，是<strong>线性查找</strong><br>stable_sort(begin, end, compare)|是稳定排序算法，会保证相等元素的顺序</p>
</li>
<li><p>其他</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>std::sort</code></td>
<td>对给定范围的元素进行排序。</td>
</tr>
<tr>
<td><code>std::reverse</code></td>
<td>反转给定范围的元素。</td>
</tr>
<tr>
<td><code>std::rotate</code></td>
<td>将给定范围的元素循环右移指定位置。</td>
</tr>
<tr>
<td><code>std::find</code></td>
<td>在给定范围内查找指定值，返回第一个匹配元素的迭代器。</td>
</tr>
<tr>
<td><code>std::binary_search</code></td>
<td>在有序范围内执行二分查找，返回是否找到指定值的布尔值。</td>
</tr>
<tr>
<td><code>std::count</code></td>
<td>计算给定范围内等于指定值的元素个数。</td>
</tr>
<tr>
<td><code>std::accumulate</code></td>
<td>对给定范围内的元素进行累积（求和）操作。</td>
</tr>
<tr>
<td><code>std::max_element</code></td>
<td>返回给定范围内的最大元素的迭代器。</td>
</tr>
<tr>
<td><code>std::min_element</code></td>
<td>返回给定范围内的最小元素的迭代器。</td>
</tr>
<tr>
<td><code>std::copy</code></td>
<td>将一个范围的元素复制到另一个范围。</td>
</tr>
<tr>
<td><code>std::fill</code></td>
<td>将给定范围的元素都设置为指定的值。</td>
</tr>
<tr>
<td><code>std::unique</code></td>
<td>移除给定范围内的重复元素，返回指向新范围结尾的迭代器。</td>
</tr>
<tr>
<td><code>std::next_permutation</code></td>
<td>将给定范围的元素重新排列为下一个字典序排列。</td>
</tr>
<tr>
<td><code>std::prev_permutation</code></td>
<td>将给定范围的元素重新排列为前一个字典序排列。</td>
</tr>
<tr>
<td><code>std::shuffle</code></td>
<td>将给定范围内的元素随机重排。</td>
</tr>
<tr>
<td><code>std::transform</code></td>
<td>对给定范围内的元素执行指定操作，结果存储在另一个范围。</td>
</tr>
<tr>
<td><code>std::merge</code></td>
<td>将两个有序范围合并成一个有序范围。</td>
</tr>
<tr>
<td><code>std::partition</code></td>
<td>根据指定条件对给定范围进行分区，将满足条件的元素放在前面。</td>
</tr>
<tr>
<td><code>std::nth_element</code></td>
<td>对给定范围的元素进行局部排序，使得第n个元素是排好序的。</td>
</tr>
</tbody></table>
<h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><ul>
<li>用于包装函数改变其参数列表<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span> (callable, arg_list);</span><br></pre></td></tr></table></figure></li>
<li>将可调用对象和参数绑定成一个新的可调用对象，可以延迟调用或者传递给其他函数使用。</li>
<li>将多元（参数个数大于1）的可调用对象转换成一元或者少元的可调用对象，即只绑定部分参数，剩下的参数在调用时传入。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将print函数和一个参数绑定成一个新的可调用对象，另一个参数用占位符表示</span></span><br><span class="line"><span class="keyword">auto</span> f2 = <span class="built_in">bind</span>(print, placeholders::_1, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">f2</span>(<span class="number">1</span>); <span class="comment">// 输出 1 2</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">3</span>); <span class="comment">// 输出 3 2</span></span><br></pre></td></tr></table></figure></li>
<li>注意bind后的函数传参是按照placeholder<strong>从小到大</strong>传参的，<strong>可以人为颠倒顺序</strong></li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li>将拷贝的参数转换为引用</li>
<li><code>ref(val)</code><h3 id="hash哈希函数"><a href="#hash哈希函数" class="headerlink" title="hash哈希函数"></a>hash哈希函数</h3></li>
<li><code>hash&lt;key_type&gt;()</code>函数为内置类型，指针，string和智能指针提供了哈希函数</li>
</ul>
<h3 id="智能指针shared-ptr和unique-ptr"><a href="#智能指针shared-ptr和unique-ptr" class="headerlink" title="智能指针shared_ptr和unique_ptr"></a>智能指针<code>shared_ptr</code>和<code>unique_ptr</code></h3><ul>
<li><code>shared_ptr</code>允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>独占所指向的对象<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4></li>
<li>对指针可以直接做条件判断，<code>true</code>就是非空，否则是空</li>
<li>最好<strong>不要</strong>用将<u>自己申请的动态内存转化为智能指针</u>的方式创建智能指针，可能会泄露</li>
<li><code>p.get()</code>返回指针指向的对象<ul>
<li>注意，如果智能指针被释放，那么使用get返回的指针指向的对象也会被释放</li>
</ul>
</li>
<li><code>shared_ptr</code>比较是否相等时候，比较的是<strong>指向的对象是否相等</strong>，因此可以用来在STL中find()等等</li>
<li><code>shared_ptr</code>基本用法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 shared_ptr，并分配一个整数</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; sharedInt = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 shared_ptr</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *sharedInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取引用计数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; sharedInt.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建另一个 shared_ptr，共享相同的整数</span></span><br><span class="line">    std::shared_ptr&lt;<span class="keyword">int</span>&gt; anotherSharedInt = sharedInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数增加</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Reference count: &quot;</span> &lt;&lt; sharedInt.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>另一种初始化</li>
<li><code>shared_ptr&lt;int&gt; p(new int(1024));</code>可以用动态对象初始化指针</li>
<li>但是必须显式的调用，不能隐式类型转换</li>
<li>不要使用<code>shared_ptr</code>的<code>get</code>方法为另一个智能指针赋值，会导致内存管理混乱<ul>
<li>比如另一个位置的shared_ptr析构，可能使得另一侧的引用计数为0，导致指向的对象直接被析构，但是这一侧的shated_ptr并不知情，再访问会导致段错误</li>
</ul>
</li>
<li><code>unique_ptr</code>基本用法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 unique_ptr，并分配一个整数</span></span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; uniqueInt = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 unique_ptr</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *uniqueInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unique_ptr 不能被拷贝，这会导致编译错误</span></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;int&gt; anotherUniqueInt = uniqueInt; // 错误！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以用<code>release</code>或者<code>reset</code>转移指针的所有权<ul>
<li>reset会<strong>释放本身指向的内存</strong>，将目标转移到函数传入的新地址上</li>
<li>release会返回自己指向的内存地址，同时放弃对这个位置的控制权（不会释放内存）</li>
</ul>
</li>
<li><code>unique_ptr</code>只有在即将被销毁（比如函数返回）或者是临时对象的时候可以被拷贝，接手自己的内存区域<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3></li>
<li>可以绑定到<code>shared_ptr</code>但是不影响引用计数</li>
<li><code>lock</code>方法用于获取对应的shared_ptr，<strong>不存在则是空的指针对象</strong></li>
<li><code>expired</code>可以看当前是不是还有shared_ptr在指向空间<h3 id="Blob"><a href="#Blob" class="headerlink" title="Blob"></a>Blob</h3></li>
<li>与vector类似，但是其中数据在拷贝的时候是公用的，不是像vector是复制的</li>
<li>管理机制与共享指针类似，最后一个被释放之后存储的数据才会删除</li>
</ul>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><ul>
<li>多种不同类型的组合</li>
<li>注意<code>make_tuple</code>可以不显式的声明类型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function">std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">float</span>, std::string&gt; <span class="title">myTuple</span><span class="params">(<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">auto</span> myTuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(myTuple) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Second element: &quot;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(myTuple) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Third element: &quot;</span> &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(myTuple) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 解包为多个变量</span></span><br><span class="line"><span class="keyword">int</span> intValue;</span><br><span class="line"><span class="keyword">double</span> doubleValue;</span><br><span class="line">std::string stringValue;</span><br><span class="line">std::<span class="built_in">tie</span>(intValue, doubleValue, stringValue) = myTuple;</span><br><span class="line"><span class="comment">// 使用 std::tuple_size 获取 tuple 大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Tuple size: &quot;</span> &lt;&lt; std::tuple_size&lt;<span class="keyword">decltype</span>(myTuple)&gt;::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><ul>
<li>用于位运算的类<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个有 8 位的 bitset，初始值为 0</span></span><br><span class="line">std::bitset&lt;8&gt; myBitset1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用整数值初始化 bitset</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">myBitset2</span><span class="params">(<span class="number">42</span>)</span></span>;  <span class="comment">// 使用二进制表示为 00101010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用字符串初始化 bitset</span></span><br><span class="line"><span class="function">std::bitset&lt;8&gt; <span class="title">myBitset3</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 访问位</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Bit at position 3: &quot;</span> &lt;&lt; myBitset[<span class="number">3</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改位</span></span><br><span class="line">myBitset.<span class="built_in">set</span>(<span class="number">1</span>, <span class="literal">true</span>);  <span class="comment">// 将第 1 位设置为 1</span></span><br><span class="line"><span class="comment">// set不给参数的话会默认为1</span></span><br><span class="line"><span class="comment">// reset会把指定的位设置为0</span></span><br><span class="line">myBitset.<span class="built_in">flip</span>(<span class="number">4</span>);       <span class="comment">// 反转第 4 位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位与</span></span><br><span class="line">std::bitset&lt;8&gt; resultAnd = bitset1 &amp; bitset2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位或</span></span><br><span class="line">std::bitset&lt;8&gt; resultOr = bitset1 | bitset2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位异或</span></span><br><span class="line">std::bitset&lt;8&gt; resultXor = bitset1 ^ bitset2;</span><br><span class="line"><span class="comment">// 获取 bitset 的大小</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of myBitset: &quot;</span> &lt;&lt; myBitset.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否所有位都是 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;All zeros? &quot;</span> &lt;&lt; myBitset.<span class="built_in">none</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否有任意位是 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Any ones? &quot;</span> &lt;&lt; myBitset.<span class="built_in">any</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否所有位都是 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;All ones? &quot;</span> &lt;&lt; myBitset.<span class="built_in">all</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (parameters) -&gt; &lt;<span class="keyword">return</span> type&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回类型可以省略</li>
<li>捕获的作用是比如函数作为谓词的时候，<strong>只能</strong>传递两个互相比较的参数，此时<strong>需要外部的参数</strong>就只能用捕获传入。<ul>
<li>全局变量不需要捕获也能使用</li>
<li>可以捕获引用<code>[&amp;var]</code>即可</li>
<li>支持隐式捕获，也就是编译器自己推断捕获什么不捕获什么</li>
<li><code>[=, other vals]</code>等号表示值捕获方式，可以与显式捕获混合使用</li>
<li><code>[&amp;, other vals]</code>引用符号表示引用捕获方式</li>
<li>不同种类的捕获可以互相混用</li>
<li>通过值捕获的变量一般不允许修改，除非在函数体之前加一个<code>mutable</code>关键字</li>
</ul>
</li>
<li>lambda是函数类型，不是函数指针</li>
</ul>
<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li>包装器</li>
<li>可以将任何可以调用的对象存入，能使用<code>()</code>的就可以，包装为一个函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Multiply</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::function 包装普通函数</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; addFunction = Add;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add Function Result: &quot;</span> &lt;&lt; <span class="built_in">addFunction</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 std::function 包装函数对象</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; multiplyFunction = <span class="built_in">Multiply</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Multiply Function Result: &quot;</span> &lt;&lt; <span class="built_in">multiplyFunction</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; lambdaFunction = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lambda Function Result: &quot;</span> &lt;&lt; <span class="built_in">lambdaFunction</span>(<span class="number">8</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h3><ul>
<li>倒序排序<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>()); <span class="comment">// 倒序</span></span><br></pre></td></tr></table></figure>
<h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3></li>
<li>连续输入使用</li>
<li>不初始化的话就是尾后迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;</span><br><span class="line"><span class="comment">// 创建一个表示istream尾后位置的istream_iterator</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof; </span><br><span class="line"><span class="comment">// 创建一个int类型的vector，并用in_iter和eof初始化</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读入一个元素并且赋值</span></span><br><span class="line">in_iter++;</span><br><span class="line"><span class="keyword">int</span> y = *in_iter;</span><br></pre></td></tr></table></figure></li>
<li>输出流迭代器<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个输出流迭代器，绑定到cout，数据类型为int，分隔符为&quot;,&quot;</span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_it</span><span class="params">(cout, <span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 向输出流迭代器写入一个数据</span></span><br><span class="line">*out_it = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个vector容器，存储一些int数据</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用copy算法，将vector中的数据复制到输出流迭代器中</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_it);</span><br></pre></td></tr></table></figure></li>
<li>向输出流迭代器<strong>写入数据</strong>就是输出</li>
<li>初始化的时候加的是每个数据之后的分隔符</li>
<li><code>*</code>, <code>++</code>等运算符对他没什么意义<h2 id="语法相关"><a href="#语法相关" class="headerlink" title="语法相关"></a>语法相关</h2></li>
<li>使用三目运算符<code>?:</code>的时候最好外加括号，否则会因为计算顺序的原因报错<h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3></li>
<li><code>new</code>和<code>delete</code>是运算符一个分配动态对象一个删除动态对象</li>
</ul>
<h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><ul>
<li>作用是对一个区间内的变量每个都执行指定的操作（函数）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个函数，用于在 for_each 中作为操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSquare</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x * x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个向量</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 for_each 遍历向量并应用操作</span></span><br><span class="line">    std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), PrintSquare);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：1 4 9 16 25</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>不要返回局部对象的引用类型，否则会因为局部对象生命周期结束而失效</li>
<li>返回指向某个数组的指针的函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> i))[<span class="number">10</span>];<span class="comment">// 看的时候从里往外看，先返回的是指针，指针指向的是int[10]</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="function">arr* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span></span><br></pre></td></tr></table></figure></li>
<li>也可以直接在返回值的位置使用decltype标出类型</li>
</ul>
<h3 id="Cpp函数重载"><a href="#Cpp函数重载" class="headerlink" title="Cpp函数重载"></a>Cpp函数重载</h3><ul>
<li>函数重载只有在同一个级别的作用域才行<ul>
<li>假如在某个函数内部声明了一个与外部函数同名的函数，会导致外部同名函数被屏蔽</li>
</ul>
</li>
<li>假如有一组参数传入导致系统无法区分具体调用哪个的话会导致编译出错</li>
<li>类型转换的分类</li>
</ul>
<table>
<thead>
<tr>
<th>等级</th>
<th>转换</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>精确匹配</td>
</tr>
<tr>
<td>2</td>
<td>const转换实现匹配</td>
</tr>
<tr>
<td>3</td>
<td>类型提升实现匹配</td>
</tr>
<tr>
<td>4</td>
<td>算数类型转换实现匹配</td>
</tr>
<tr>
<td>5</td>
<td>类类型转换实现匹配</td>
</tr>
</tbody></table>
<h3 id="Cpp函数内联"><a href="#Cpp函数内联" class="headerlink" title="Cpp函数内联"></a>Cpp函数内联</h3><ul>
<li>编译器可以选择忽略内联函数请求，也可以自动优化内联函数</li>
</ul>
<h3 id="是否是开发状态"><a href="#是否是开发状态" class="headerlink" title="是否是开发状态"></a>是否是开发状态</h3><ul>
<li>定义<code>NDEBUG</code></li>
<li>如果定义了就不能使用assert等debug用的工具</li>
<li>也可以自己用<code>#ifndef NDEBUG</code>来控制自己写的代码哪些用在调试阶段<h3 id="调试输出"><a href="#调试输出" class="headerlink" title="调试输出"></a>调试输出</h3></li>
<li>可以用<code>__func__</code>打印<strong>当前函数的名字</strong></li>
<li><code>__FILE__</code>文件名</li>
<li><code>__LINE__</code>行号</li>
<li><code>__TIME__</code>编译时间</li>
<li><code>__DATE__</code>编译日期<h4 id="backtrace和backtrace-symbols函数"><a href="#backtrace和backtrace-symbols函数" class="headerlink" title="backtrace和backtrace_symbols函数"></a><code>backtrace</code>和<code>backtrace_symbols</code>函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span> **buffer, <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><code>backtrace</code>函数是一个用于获取调用栈信息的函数，通常在调试或错误处理中使用。它在标准的C库中，头文件是<code>#include &lt;execinfo.h&gt;</code></li>
<li>使用<code>backtrace_symbols</code>函数将<code>backtrace</code>信息转换成字符串</li>
<li><code>char **bt_strings = backtrace_symbols(bt_buffer, bt_size);</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> max_frames = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">void</span> *addrlist[max_frames + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> addrlen = <span class="built_in">backtrace</span>(addrlist, <span class="built_in"><span class="keyword">sizeof</span></span>(addrlist) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addrlen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;No stack trace available.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> **symbolList = <span class="built_in">backtrace_symbols</span>(addrlist, addrlen);</span><br><span class="line">    <span class="keyword">if</span> (symbolList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;backtrace_symbols&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack trace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addrlen; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, symbolList[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(symbolList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printStackTrace</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>backtrace函数在编译时需要开启调试信息。如果使用gcc编译，可以添加<code>-g</code></li>
<li>传入的需要是一个<strong>指针数组</strong>或者是使用<code>addrlist = (void **)malloc((sizeof(void *) * addrlen));</code>分配好内存的空间<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3></li>
<li>给函数指针赋值的时候加不加取地址符号都一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">return</span> type&gt; (*func name)(&lt;para&gt; parameters);</span><br></pre></td></tr></table></figure></li>
<li><strong>不同种类的函数指针之间无法转换，即使形参列表能转换</strong>，也就是说必须是<em>返回类型</em>和<em>形参列表</em>与自身完全一样的函数才可以赋值给函数指针</li>
<li>但是<strong>调用</strong>的时候可以发生类型转换</li>
<li>返回的时候不能返回函数，因为函数不能拷贝，只能返回函数指针<h4 id="如何返回函数指针"><a href="#如何返回函数指针" class="headerlink" title="如何返回函数指针"></a>如何返回函数指针</h4></li>
<li><code>int (*f1(int))(int, int);</code>返回的是一个<code>int(*)(int, int)</code>类型的函数指针</li>
<li>或者写<code>auto f(int) -&gt; int(*)(int, int)</code></li>
</ul>
<h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><ul>
<li><code>int*a = new int[10];</code>是未初始化的</li>
<li><code>int*a = new int[10]();</code>是已经值初始化为0的</li>
<li><code>int* a = new int[3]&#123;0, 1, 2&#125;;</code>是显式初始化列表的</li>
<li>创建长度为0的动态数组可以，但<strong>不能解引用</strong></li>
<li>释放的时候必须用<code>delete [] ptr</code></li>
</ul>
<h3 id="allocator类申请内存"><a href="#allocator类申请内存" class="headerlink" title="allocator类申请内存"></a>allocator类申请内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 std::allocator 分配一块内存来存储 int 类型的元素</span></span><br><span class="line">    std::allocator&lt;<span class="keyword">int</span>&gt; allocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存以存储一个 int</span></span><br><span class="line">    <span class="keyword">int</span>* ptr = allocator.<span class="built_in">allocate</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在分配的内存上构造 int 对象</span></span><br><span class="line">    allocator.<span class="built_in">construct</span>(ptr, <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用构造的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁对象并释放内存</span></span><br><span class="line">    allocator.<span class="built_in">destroy</span>(ptr);</span><br><span class="line">    allocator.<span class="built_in">deallocate</span>(ptr, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>alloccate</code>仅仅是分配内存</li>
<li><code>construct</code>才构造对象</li>
<li>删除的时候先<code>destroy</code></li>
<li>然后再解除内存占用<code>deallocate</code></li>
<li>使用<code>allocator</code>构造内存的时候可以像使用指针一样对指针做加减，只要不超出构造的范围即可<h4 id="一次初始化多个元素"><a href="#一次初始化多个元素" class="headerlink" title="一次初始化多个元素"></a>一次初始化多个元素</h4></li>
<li>`std::uninitialized_fill(intPtr, intPtr + 3, 1);<ul>
<li>注意，<code>uninitialized_fill</code>的第二个参数类似于尾后迭代器，不会真的被赋值</li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><ul>
<li><p>常量成员函数<code>&lt;return type&gt; func() const &#123;&#125;</code></p>
<ul>
<li>不修改类对象的函数</li>
<li>对这个类的const实例的时候会调用const的成员函数</li>
<li>但是假如某个成员有<code>mutable</code>关键字，那么也可以修改<h3 id="访问说明符"><a href="#访问说明符" class="headerlink" title="访问说明符"></a>访问说明符</h3></li>
</ul>
</li>
<li><p><code>public</code>和<code>private</code>可以反复出现多次</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3></li>
<li><p>类内声明</p>
</li>
<li><p><code>friend &lt;return type&gt; func();</code></p>
</li>
<li><p>即使这个类被内嵌在一个子类中，也可以访问相应部分的成员</p>
<h3 id="不同类别的继承"><a href="#不同类别的继承" class="headerlink" title="不同类别的继承"></a>不同类别的继承</h3></li>
<li><p>private继承会把所有从基类继承的成员都作为private对象</p>
</li>
<li><p>protected会把所有的作为protected</p>
</li>
<li><p>public则不改变权限</p>
</li>
<li><p>可以手动在public、protected或者private后面使用<code>using 基类名:: 基类成员</code>手动变更访问权限</p>
</li>
<li><p>继承的时候子类的同名成员会覆盖基类的，无论是变量还是成员函数</p>
<h3 id="作用域运算符"><a href="#作用域运算符" class="headerlink" title="作用域运算符::"></a>作用域运算符<code>::</code></h3></li>
<li><p>访问全局作用域中的变量直接用<code>::&lt;variable&gt;</code>即可</p>
</li>
<li><p>访问类的就用<code>&lt;class name&gt;::&lt;var&gt;</code></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3></li>
<li><p>子类在构造的时候必须在初始化列表中显式的调用基类的构造函数构造基类的部分</p>
</li>
<li><p>派生类构造函数只能通过初始化列表或构造函数的成员初始化列表来调用基类构造函数，而在函数体中是无法再次调用的</p>
<h3 id="类成员初始化"><a href="#类成员初始化" class="headerlink" title="类成员初始化"></a>类成员初始化</h3></li>
<li><p>无论初始化列表里怎么写，类成员的初始化顺序是<strong>按照他们在类中定义的顺序的</strong></p>
<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3></li>
<li><p>类的多个构造函数中一个构造函数借用类的其他功能强大的构造函数构造对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">test</span>(string s):<span class="built_in">data</span>(s)&#123;&#125;</span><br><span class="line">    <span class="built_in">test</span>():<span class="built_in">test</span>(<span class="string">&quot;Hello World&quot;</span>)&#123;&#125; <span class="comment">// 这里是委托带参数的构造函数test(string s)构造对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用默认构造函数（无参数）的时候不能加括号，否则编译器会认为你想声明一个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">className <span class="title">obj</span><span class="params">()</span></span>;<span class="comment">// 看起来就是声明一个叫obj的函数</span></span><br></pre></td></tr></table></figure>
<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3></li>
<li><p><code>className(const className&amp; cName)&#123;&#125;;</code></p>
</li>
<li><p>第一个参数必须是自身的引用</p>
</li>
<li><p>其他参数必须有默认值</p>
</li>
<li><p>注意形如<code>&lt;className&gt; val = valOld;</code>的是拷贝初始化</p>
<h3 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h3></li>
<li><p>移动语义的目的是在<strong>避免不必要的数据复制</strong>的同时，更高效地管理资源。</p>
</li>
<li><p>在 C++11 引入右值引用之前，对象的拷贝构造函数是唯一的构造函数，用于复制对象。然而，对于临时对象或即将销毁的对象，进行深拷贝可能是不必要的开销。移动构造函数通过使用右值引用，允许在不复制底层资源的情况下将资源从一个对象“移动”到另一个对象。</p>
</li>
<li><p>必须是<code>noexcept</code>标明的</p>
</li>
<li><p>传入的参数是一个右值引用</p>
</li>
<li><p>有不具备移动构造功能的成员，自身也不能移动构造</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">data</span>(other.data), <span class="built_in">length</span>(other.length) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Move Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 移动构造函数中，将原对象的资源指针置为空，避免资源被析构</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        other.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span><br><span class="line">        : <span class="built_in">data</span>(<span class="built_in">strdup</span>(str)), <span class="built_in">length</span>(<span class="built_in">strlen</span>(str)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="built_in">free</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* data;</span><br><span class="line">    std::<span class="keyword">size_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个对象</span></span><br><span class="line">    <span class="function">MyString <span class="title">source</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用移动构造函数，将资源从 source 移动到 target</span></span><br><span class="line">    MyString target = std::<span class="built_in">move</span>(source);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Source String: &quot;</span> &lt;&lt; (source.<span class="built_in">GetData</span>() ? source.<span class="built_in">GetData</span>() : <span class="string">&quot;nullptr&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Target String: &quot;</span> &lt;&lt; (target.<span class="built_in">GetData</span>() ? target.<span class="built_in">GetData</span>() : <span class="string">&quot;nullptr&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3></li>
<li><p>可以是成员函数也可以直接是函数</p>
</li>
<li><p>如果运算符是某个类的成员函数那么左侧的操作数<strong>必须是这个类的对象</strong></p>
</li>
<li><p>重载输入输出运算符的时候必须不是成员函数</p>
</li>
<li><p>下标运算符必须是成员函数</p>
</li>
<li><p>赋值运算符必须是成员函数</p>
<h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4></li>
<li><p><code>className&amp; operator++();</code>前置</p>
</li>
<li><p><code>className&amp; operator(int); </code>后置，参数无用，用于与前置区分</p>
</li>
<li><p>一般是成员函数</p>
</li>
</ul>
<h4 id="重载-gt-运算符"><a href="#重载-gt-运算符" class="headerlink" title="重载-&gt;运算符"></a>重载<code>-&gt;</code>运算符</h4><ul>
<li>返回值必须是指针（<strong>可以是某个成员函数类型的指针</strong>）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying MyClass&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 -&gt; 运算符</span></span><br><span class="line">    MyClass* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass myObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载的 -&gt; 运算符</span></span><br><span class="line">    myObject-&gt;<span class="built_in">Display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="等号运算符"><a href="#等号运算符" class="headerlink" title="等号运算符"></a>等号运算符</h3><ul>
<li><code>className&amp; operator=(const className&amp;);</code></li>
<li>控制等号的行为</li>
<li><code>return *this;</code>即可</li>
<li>注意处理等号左右是同一个变量的情况</li>
</ul>
<h3 id="要求系统合成一个默认的构造-析构函数"><a href="#要求系统合成一个默认的构造-析构函数" class="headerlink" title="要求系统合成一个默认的构造/析构函数"></a>要求系统合成一个默认的构造/析构函数</h3><ul>
<li><code>ClassName() = default;</code></li>
<li><code>=default;</code><h3 id="禁止一个构造-复制函数被调用"><a href="#禁止一个构造-复制函数被调用" class="headerlink" title="禁止一个构造/复制函数被调用"></a>禁止一个构造/复制函数被调用</h3></li>
<li><code>ClassName &amp;operator=(const ClassName&amp;) = delete;</code></li>
<li><code>=delete;</code></li>
<li>可以对于任何函数使用</li>
<li>删除析构函数的类型，不能定义该类型的变量或者释放该类型动态对象的指针</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>如果类具有只接受一个参数的构造函数，那么编译器可以将<strong>这个参数类型的对象</strong>自动转换为这个类的对象<ul>
<li>给构造函数增加一个<code>explicit</code>参数可以禁止这种转换</li>
<li>但是static_cast可以调用<code>explicit</code>的构造函数</li>
</ul>
</li>
</ul>
<h3 id="重载类型转换运算符"><a href="#重载类型转换运算符" class="headerlink" title="重载类型转换运算符"></a>重载类型转换运算符</h3><ul>
<li>类型转换运算符通常不显式声明返回类型，因为它们没有返回类型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> feet;</span><br><span class="line">    <span class="keyword">float</span> inches;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Distance</span>(<span class="keyword">int</span> ft, <span class="keyword">float</span> in) : <span class="built_in">feet</span>(ft), <span class="built_in">inches</span>(in) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换运算符，将 Distance 转换为 float</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(feet) + inches / <span class="number">12.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Distance <span class="title">d</span><span class="params">(<span class="number">5</span>, <span class="number">9.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类型转换运算符将 Distance 转换为 float</span></span><br><span class="line">    <span class="keyword">float</span> totalInches = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(d);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total Inches: &quot;</span> &lt;&lt; totalInches &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意防止类型转换运算符与某些具有隐式类型转换功能的构造函数出现二义性</li>
<li>只要有多个用户自定义的类型转换都能达到目的，编译器就认为出线了二义性</li>
</ul>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><ul>
<li><code>override</code>的主要作用是在子类中表明某个<strong>函数是覆盖基类的虚函数的</strong>，方便检查是否真的覆盖了</li>
</ul>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><ul>
<li>使用一个基类的指针调用一个虚函数</li>
<li>根据不同的子类对虚函数的继承，产生不同的结果  </li>
<li>使用基类的指针调用子类的时候，必须基类也有这个函数才行</li>
<li>使用智能指针也能实现这些功能</li>
</ul>
<h3 id="多态和虚函数"><a href="#多态和虚函数" class="headerlink" title="多态和虚函数"></a>多态和虚函数</h3><ul>
<li>使用基类的指针（或引用）<strong>不能</strong>直接访问子类中定义了但是基类中没定义的成员函数和变量<ul>
<li>需要使用类型转换才能访问</li>
</ul>
</li>
<li>但是可以访问子类中重载了的基类的虚函数</li>
<li>虚函数继承的时候<u><strong>必须函数头完全一致才行，这样才能实现多态</strong></u><ul>
<li>不一样的话会直接覆盖基类的虚函数，不会产生多态，用基类的指针的时候还是会调用基类的函数</li>
</ul>
</li>
<li>可以使用类名和<strong>作用域运算符</strong>手动指定通过指针调用的是哪个函数，从而防止运行时才知道是哪个</li>
<li>基类的构造函数中无法访问子类重载的虚函数，因为这个虚函数表是之后才被构建出来的<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4></li>
<li>基类的析构函数最好写成虚函数，方便多态调用的时候析构掉整个的，否则析构基类的动态对象的时候会只析构基类的部分导致内存泄漏</li>
<li>具有手动析构函数的类，编译器一般<strong>不会</strong>自动合成移动构造函数、拷贝构造函数、等号运算符重载等，需要的话最好手动指出<ul>
<li><u>否则会因此导致继承他的子类因为父类没有这些函数而无法复制构造</u><h4 id="基类的拷贝构造函数和移动构造函数"><a href="#基类的拷贝构造函数和移动构造函数" class="headerlink" title="基类的拷贝构造函数和移动构造函数"></a>基类的拷贝构造函数和移动构造函数</h4></li>
</ul>
</li>
<li>必须显式的子类的相应函数中的初始化列表中调用基类的拷贝构造函数或者移动构造函数<ul>
<li><img src="/imgs/44be057dc9bca19ac215614aa2ab6479eb8204fa537f43cb20a96756074c76f2.png" alt="picture 0">  </li>
</ul>
</li>
</ul>
<h4 id="基类和派生类的-赋值运算符"><a href="#基类和派生类的-赋值运算符" class="headerlink" title="基类和派生类的=赋值运算符"></a>基类和派生类的<code>=</code>赋值运算符</h4><ul>
<li>需要在派生类的<code>=</code>赋值运算符函数体中手动调用基类的赋值运算符</li>
</ul>
<h4 id="构造函数虚函数的情况"><a href="#构造函数虚函数的情况" class="headerlink" title="构造函数虚函数的情况"></a>构造函数虚函数的情况</h4><ul>
<li>在派生类的构造函数初始化列表中调用基类的构造函数的时候最好手动通过<code>类名::</code>的形式指定需要调用的函数，防止因为多态导致调用了继承的构造函数</li>
</ul>
<h4 id="智能指针的情况"><a href="#智能指针的情况" class="headerlink" title="智能指针的情况"></a>智能指针的情况</h4><ul>
<li>涉及智能指针的情况也可以实现多态</li>
<li><code>make_shared</code>或者其他构造一个子类对象即可</li>
</ul>
<h3 id="抽象类和纯虚函数"><a href="#抽象类和纯虚函数" class="headerlink" title="抽象类和纯虚函数"></a>抽象类和纯虚函数</h3><ul>
<li>在一个成员函数后面加上<code>=0;</code>即可实现</li>
<li>类不能被实例化</li>
<li>纯虚函数的定义必须在外部</li>
</ul>
<h3 id="集成的时候的构造函数"><a href="#集成的时候的构造函数" class="headerlink" title="集成的时候的构造函数"></a>集成的时候的构造函数</h3><ul>
<li>基类的数据成员必须调用基类的构造函数构造（在初始化列表直接调用）</li>
<li>然后再按声明的顺序构造自身的对象</li>
</ul>
<h3 id="不能被继承的类"><a href="#不能被继承的类" class="headerlink" title="不能被继承的类"></a>不能被继承的类</h3><ul>
<li>类声明之后加一个<code>final</code></li>
</ul>
<h3 id="private和protected"><a href="#private和protected" class="headerlink" title="private和protected"></a><code>private</code>和<code>protected</code></h3><ul>
<li><code>protected</code>是继承的类能拿到但是别的类拿不到</li>
<li><code>private</code>继承的类也拿不到</li>
<li>派生类的友元对基类的保护对象访问没有任何特权，无法访问protected</li>
</ul>
<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><ul>
<li>所有成员public</li>
<li>没有构造函数</li>
<li>类内没给初始值</li>
<li>没有基类和虚函数</li>
<li><strong>可以用花括号直接初始化，类似于struct</strong><h3 id="字面值类"><a href="#字面值类" class="headerlink" title="字面值类"></a>字面值类</h3></li>
<li>数据成员必须都是字面值类型</li>
<li>至少有一个常量表达式的构造函数</li>
<li>析构函数必须是默认的</li>
<li>内置类型必须是常量表达式，类调用自己的常量构造函数</li>
<li><code>constexpr</code>的构造函数的函数体必须是空的</li>
<li>此时可以在构造的时候加一个<code>constexpr</code><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3></li>
<li><code>static</code></li>
<li>对象的内存不包含静态对象</li>
<li>static函数不含有this指针，<strong>不能处理非static成员</strong></li>
<li>可以使用类作用域直接调用，也可以用对象的<code>.</code>调用</li>
<li>static关键字只出现在类内声明的场合，定义的时候不出现</li>
<li>初始化<ul>
<li>只有是constexpr的情况下可以在类内声明，但是无法在外部使用</li>
<li><code>int &lt;class name&gt;:: var = blabla;</code></li>
</ul>
</li>
<li>可以在一个类还没被初始化完的时候就声明它的静态对象</li>
<li>类的（不一定是静态）成员函数操作静态成员的时候可以直接操作，<strong>不需要加作用域运算符</strong></li>
</ul>
<h3 id="IO流对象"><a href="#IO流对象" class="headerlink" title="IO流对象"></a>IO流对象</h3><ul>
<li><code>iostream</code>, <code>fstream</code>, <code>sstream</code> </li>
<li>不能修改，赋值</li>
<li>输出<code>endl</code>是刷新缓冲区附带一个回车，输出<code>flush</code>则只刷新缓冲区，输出<code>ends</code>刷新缓冲区的同时附带一个空格</li>
<li>输入和输出流可以绑定，多个输入可以绑定到一个输出<ul>
<li>用<code>.tie(&lt;some stream&gt;)</code>函数</li>
<li>输入与输出绑定的时候，调用输入流的时候自动刷新输出缓冲区</li>
</ul>
</li>
<li><code>fstream</code>可以用<code>open</code>或者<code>close</code>打开或者关闭文件</li>
<li>析构的时候会自动close文件<h4 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h4>open函数flag|功能<br>|—|—|<br>in|读<br>out|写<br>app|追加(每次操作都从末尾开始)<br>ate|打开的时候定位到结尾<br>trunc|如果存在，丢弃内容<br>binary|二进制</li>
<li>只有app和in方式可以保留原来的内容</li>
<li>不指定的话是<code>out</code>和<code>trunc</code><h3 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a>sstream</h3></li>
<li>自身就是个string</li>
<li>可以初始化也可以不初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将一个整数转换为string</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">123</span>;</span><br><span class="line">    stringstream ss1;</span><br><span class="line">    ss1 &lt;&lt; n; <span class="comment">// 向stringstream写入整数</span></span><br><span class="line">    string s1 = ss1.<span class="built_in">str</span>(); <span class="comment">// 获取stringstream内部的string</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl; <span class="comment">// 输出s1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个string分割为单词</span></span><br><span class="line">    string s2 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss2</span><span class="params">(s2)</span></span>; <span class="comment">// 用string初始化stringstream</span></span><br><span class="line">    string word;</span><br><span class="line">    <span class="keyword">while</span> (ss2 &gt;&gt; word) <span class="comment">// 从stringstream读取单词</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;word = &quot;</span> &lt;&lt; word &lt;&lt; endl; <span class="comment">// 输出单词</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="std-istringstream"><a href="#std-istringstream" class="headerlink" title="std::istringstream"></a>std::istringstream</h3><ul>
<li>一个字符串输入流，允许你从字符串中读取数据，就像从标准输入流中读取数据一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string inputString = <span class="string">&quot;123 4.56 Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 istringstream 对象，并将字符串传入</span></span><br><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(inputString)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> intValue;</span><br><span class="line">    <span class="keyword">float</span> floatValue;</span><br><span class="line">    std::string stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符串流中读取数据</span></span><br><span class="line">    iss &gt;&gt; intValue &gt;&gt; floatValue &gt;&gt; stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出读取到的数据</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; intValue &lt;&lt; <span class="string">&quot;, Float: &quot;</span> &lt;&lt; floatValue &lt;&lt; <span class="string">&quot;, String: &quot;</span> &lt;&lt; stringValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-ostringstream"><a href="#std-ostringstream" class="headerlink" title="std::ostringstream"></a>std::ostringstream</h3></li>
<li>一个字符串输出流，允许你将数据写入字符串，就像写入标准输出流一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> intValue = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">float</span> floatValue = <span class="number">3.14</span>;</span><br><span class="line">    std::string stringValue = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ostringstream 对象</span></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据写入字符串流</span></span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;Int: &quot;</span> &lt;&lt; intValue &lt;&lt; <span class="string">&quot;, Float: &quot;</span> &lt;&lt; floatValue &lt;&lt; <span class="string">&quot;, String: &quot;</span> &lt;&lt; stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取字符串</span></span><br><span class="line">    std::string resultString = oss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出写入的字符串</span></span><br><span class="line">    std::cout &lt;&lt; resultString &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="iostream格式化"><a href="#iostream格式化" class="headerlink" title="iostream格式化"></a>iostream格式化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 进制</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Default: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; std::hex &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; std::oct &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Decimal: &quot;</span> &lt;&lt; std::dec &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//填充字符</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Default fill: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Fill with &#x27;*&#x27;: &quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//对齐</span></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Default alignment: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Left alignment: &quot;</span> &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Right alignment: &quot;</span> &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Internal alignment: &quot;</span> &lt;&lt; std::internal &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; -num &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 精度</span></span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.141592653589793</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Default precision: &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Precision 4: &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 设置宽度</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Width 10: &quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; num &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="iostream其他用法"><a href="#iostream其他用法" class="headerlink" title="iostream其他用法"></a>iostream其他用法</h2><ul>
<li><code>cin.get</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cin.<span class="built_in">get</span>();</span><br><span class="line">istream&amp; cin.<span class="built_in">get</span>(<span class="keyword">char</span>&amp; var);</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">( <span class="keyword">char</span>* s, streamsize n )</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span> <span class="params">( <span class="keyword">char</span>* s,  streamsize  n, <span class="keyword">char</span> delim )</span>。</span></span><br></pre></td></tr></table></figure></li>
<li><code>cin.getline</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>* s, streamsize count)</span></span>; <span class="comment">//默认以换行符结束</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span>* s, streamsize count, <span class="keyword">char</span> delim)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><code>gets</code></li>
<li>gets是C中的库函数，在<code>&lt;stdio.h&gt;</code>申明，从标准输入设备读字符串，可以无限读取</li>
<li>不会判断上限，以回车结束或者EOF时停止读取<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> array[<span class="number">20</span>]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">gets</span>(array);</span><br><span class="line">    cout&lt;&lt;array&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2></li>
<li>声明模板类型</li>
<li><code>template&lt;typename T&gt;</code>或者<code>template&lt;typename T, class U&gt;</code></li>
<li><code>class</code>和<code>typename</code>相同，都可以， <strong>但每个类型钱都必须有这二者之一</strong></li>
</ul>
<h3 id="声明未定大小的数组"><a href="#声明未定大小的数组" class="headerlink" title="声明未定大小的数组"></a>声明未定大小的数组</h3><ul>
<li><code>template&lt;unsigned N, unsigned M&gt;</code>其中N和M是未定的大小，比如用于<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="类模板和类模板的成员函数"><a href="#类模板和类模板的成员函数" class="headerlink" title="类模板和类模板的成员函数"></a>类模板和类模板的成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleTemplate</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SimpleTemplate</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 函数</span></span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        data = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>在类外定义类的成员函数注意也要写模板参数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数的声明</span></span><br><span class="line">    <span class="built_in">MyClass</span>(T value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyClass&lt;T&gt;::<span class="built_in">MyClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> MyClass&lt;T&gt;::<span class="built_in">display</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个模板类的成员函数在<strong>用到</strong>的时候才被实例化</li>
<li>在一个类模板的作用域内，不必在类名之后带<code>&lt;T&gt;</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">retType className&lt;T&gt;::<span class="built_in">func</span>(val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里使用类的时候直接用className就行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板的友元函数"><a href="#类模板的友元函数" class="headerlink" title="类模板的友元函数"></a>类模板的友元函数</h3></li>
<li>只有实例化为同一种类型才成立的友元<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元类模板的特例化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 友元函数模板的特例化</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">FriendFunction</span><span class="params">(<span class="keyword">const</span> MyClass&lt;T&gt;&amp; obj)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板的声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(T value) : <span class="built_in">data</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendClass</span>&lt;</span>T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>可以通过在<code>friend</code>函数前面独立增加一个<code>template &lt;typename X&gt;</code>来打破友元必须与类实例化为相同的类型才能成为友元的要求，从而使得所有情况下友元都成立<h3 id="模板类型别名"><a href="#模板类型别名" class="headerlink" title="模板类型别名"></a>模板类型别名</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">// 相当于`pair&lt;string, string&gt;`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模板类的静态成员"><a href="#模板类的静态成员" class="headerlink" title="模板类的静态成员"></a>模板类的静态成员</h3><ul>
<li>不同实例化的模板类不共享静态数据成员，只有相同实例化的共享<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化静态数据成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">retType ClassName&lt;T&gt;:: val - <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="模板默认参数"><a href="#模板默认参数" class="headerlink" title="模板默认参数"></a>模板默认参数</h3></li>
<li><code>template &lt;typename T = int&gt;</code></li>
<li>希望使用默认模板参数的时候使用<code>&lt;&gt;</code>即可但是<strong>不能省略</strong></li>
</ul>
<h3 id="模板参数推导"><a href="#模板参数推导" class="headerlink" title="模板参数推导"></a>模板参数推导</h3><ul>
<li>编译器会默认进行模板参数推导，比如调用模板函数的时候，编译器会根据调用的方式自动推导函数模板实例化成哪种函数</li>
<li>用给好类型的函数指针指向模板函数的时候，编译器也会根据<strong>要赋值的函数指针的类型</strong>推断模板函数的实例化方式</li>
</ul>
<h3 id="需要置顶尾置返回类型的场合"><a href="#需要置顶尾置返回类型的场合" class="headerlink" title="需要置顶尾置返回类型的场合"></a>需要置顶尾置返回类型的场合</h3><ul>
<li>需要使用模板参数结合<code>decltype</code>推断返回类型的场合<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="模板函数的重载"><a href="#模板函数的重载" class="headerlink" title="模板函数的重载"></a>模板函数的重载</h3><ul>
<li>用别的模板函数重载<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数接受一个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Template Function with one template parameter: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载模板函数，接受两个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Template Function with two template parameters: &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; u &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用非模板函数重载<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Template Function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Non-Template Function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匹配的原则是谁更特殊就匹配谁，非模板版本优先。谁的范围更窄，先匹配谁</li>
</ul>
<h3 id="可变参数类型的类模板"><a href="#可变参数类型的类模板" class="headerlink" title="可变参数类型的类模板"></a>可变参数类型的类模板</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板递归终止条件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;End of recursion&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变模板参数的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">(T first, Args... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; first &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printValues</span>(args...);  <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printValues</span>(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Args...</code> 表示一个参数包，可以接受零个或多个类型。在递归调用中，<code>args...</code> 用于<strong>展开参数包</strong>，使得每个参数都能够被单独处理<ul>
<li>就是每次递归调用的时候都把第一个赋值给fisrt，后面的还在<code>args...</code>内部</li>
</ul>
</li>
<li>使用<code>sizeof...</code>计算参数数量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变模板参数的模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">countArgs</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>...(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of arguments: &quot;</span> &lt;&lt; <span class="built_in">countArgs</span>(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;A&#x27;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板函数特例化"><a href="#模板函数特例化" class="headerlink" title="模板函数特例化"></a>模板函数特例化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用模板函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunction</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Generic Template Function: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化 - 针对int类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">void</span> myFunction&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized Template Function for int: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>就是专门为<code>T</code>是某种特定的类型而设定的版本</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Division by zero!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception caught: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写了<code>noexcept</code>的函数抛出异常不会被<code>catch</code>，会导致程序崩溃<ul>
<li><code>noexept(false)</code>表示可能抛出异常</li>
<li>反之认为不可能抛出异常</li>
</ul>
</li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string errorMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> std::string&amp; message) : <span class="built_in">errorMessage</span>(message) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMessage.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="keyword">int</span> globalVar = <span class="number">42</span>;  <span class="comment">// 命名空间中的全局变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello from MyNamespace!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Inside MyClass&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以不连续，<code>namespace name&#123;&#125;</code>可以在文件中反复出现多次</li>
<li>别名<code>namespace A = B;</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FrankZhang"
      src="/images/avatar1.jpg">
  <p class="site-author-name" itemprop="name">FrankZhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">186</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FrankZhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">661k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">20:02</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
