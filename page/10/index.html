<!DOCTYPE html>


<html lang="Chinese">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Frank’s blogs</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/FLogo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/bkgPic.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Frank’s blogs</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['Linux开发和工科生折腾集锦', '算法题总结', 'C/C++/python等开发'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">Linux编程、C/C++开发、算法题、各种工科生折腾开发集锦</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Linux内核启动分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/27/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/"
    >Linux内核启动分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/27/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2022-02-27T02:52:51.000Z" itemprop="datePublished">2022-02-27</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux内核启动分析"><a href="#Linux内核启动分析" class="headerlink" title="Linux内核启动分析"></a>Linux内核启动分析</h1><h2 id="start-kernel函数"><a href="#start-kernel函数" class="headerlink" title="start_kernel函数"></a>start_kernel函数</h2><ul>
<li><p>start_kernel 通过调用众多的子函数来完成 Linux 启动之前的一些初始化工作，由于 start_kernel 函数里面调用的子函数太多，而这些子函数又很复杂，因此我们简单的来看一下一 些重要的子函数。</p>
</li>
<li><p>精简后的内容大致如下</p>
<ul>
<li><img src="/imgs/image-20220227110529972.png" alt="image-20220227110529062"></li>
<li><img src="/imgs/image-20220227110555519.png" alt="image-20220227110555519"></li>
<li><img src="/imgs/image-20220227110617809.png" alt="image-20220227110617809"></li>
<li><img src="/imgs/image-20220227110631266.png" alt="image-20220227110631266"></li>
<li><img src="/imgs/image-20220227110653054.png" alt="image-20220227110653054"></li>
</ul>
</li>
</ul>
<h3 id="启动过程中调用的函数分析"><a href="#启动过程中调用的函数分析" class="headerlink" title="启动过程中调用的函数分析"></a>启动过程中调用的函数分析</h3><ul>
<li><p><code>lockdep_init();</code>，死锁检测，初始化两个hash表，尽可能早的执行</p>
</li>
<li><p><code>set_task_stack_end_magic(&amp;init_task);</code>，设置任务栈结束魔术数，用于栈溢出检测</p>
</li>
<li><p><code>smp_setup_processor_id();</code>跟 SMP 有关(多核处理器)，设置处理器 ID。</p>
</li>
<li><p><code>debug_objects_early_init();</code>,做一些和 debug 有关的初始化 </p>
</li>
<li><p><code>boot_init_stack_canary();</code>栈溢出检测初始化</p>
</li>
<li><p><code>cgroup_init_early()</code>， cgroup 初始化，cgroup 用于控制 Linux 系统资源</p>
</li>
<li><p><code>local_irq_disable()</code>关闭当前 CPU 中断</p>
</li>
<li><p><code>boot_cpu_init();</code>跟 CPU 有关的初始化</p>
</li>
<li><p><code>page_address_init(); </code> 页地址相关的初始化</p>
</li>
<li><p><code>pr_notice(&quot;%s&quot;, linux_banner);</code>打印 Linux 版本号、编译时间等信息</p>
</li>
<li><p><code>setup_arch(&amp;command_line)</code>架构相关的初始化，此函数会解析传递进来的ATAGS 或者设备树(DTB)文件。会根据设备树里面的 model 和 compatible 这两个属性值来查找Linux 是否支持这个单板。此函数也会获取设备树 中 chosen 节点下的 bootargs 属性值来得到命令 行参数，也就是 uboot 中的 bootargs 环境变量的值，获取到的命令行参数会保存到command_line 中。</p>
</li>
<li><p><code>mm_init_cpumask(&amp;init_mm);</code>看名字，应该是和内存有关的初始化</p>
</li>
<li><p><code>setup_command_line(command_line); </code>好像是存储命令行参数</p>
</li>
<li><p><code>setup_nr_cpu_ids();</code>如果只是 SMP(多核 CPU)的话，此函数用于获取CPU 核心数量，CPU 数量保存在变量 nr_cpu_ids 中。</p>
</li>
<li><p><code>setup_per_cpu_areas(); </code>在 SMP 系统中有用，设置每个 CPU 的 per-cpu 数据</p>
</li>
<li><p><code>build_all_zonelists(NULL, NULL); </code>建立系统内存页区(zone)链表</p>
</li>
<li><p><code>page_alloc_init(); </code>处理用于热插拔 CPU 的页</p>
</li>
<li><p><code>pr_notice(&quot;Kernel command line: %s\n&quot;, boot_command_line);</code> 打印命令行信息 </p>
</li>
<li><p><code>parse_early_param(); </code> 解析命令行中的 console 参数</p>
</li>
<li><p><code>setup_log_buf(0);</code>设置 log 使用的缓冲区</p>
</li>
<li><p><code>pidhash_init();</code> 构建 PID 哈希表，Linux 中每个进程都有一个 ID,这个 ID 叫做 PID。通过构建哈希表可以快速搜索进程信息结构体。</p>
</li>
<li><p><code>vfs_caches_init_early();</code>预先初始化 vfs(虚拟文件系统)的目录项和索引节点缓存</p>
</li>
<li><p><code>sort_main_extable();</code>定义内核异常列表</p>
</li>
<li><p><code>trap_init(); </code>完成对系统保留中断向量的初始化</p>
</li>
<li><p><code>mm_init();</code>内存管理初始化</p>
</li>
<li><p><code>sched_init();</code>初始化调度器，主要是初始化一些结构体</p>
</li>
<li><p><code>preempt_disable();</code>关闭优先级抢占</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (WARN(!irqs_disabled(), <span class="comment">/* 检查中断是否关闭，如果没有的话就关闭中断 */</span></span><br><span class="line"> <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line"> local_irq_disable();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>idr_init_cache(); </code>IDR 初始化，IDR 是 Linux 内核的整数管理机 制，也就是将一个整数 ID 与一个指针关联起来。</li>
<li><code>rcu_init();</code>初始化 RCU，RCU 全称为 Read Copy Update(读-拷贝修改)</li>
<li><code>trace_init();</code>跟踪调试相关初始化</li>
<li><code>radix_tree_init();</code>基数树相关数据结构初始化</li>
<li><code>early_irq_init(); </code>初始中断相关初始化,主要是注册 irq_desc 结构体变量，因为 Linux 内核使用 irq_desc 来描述一个中断。</li>
<li><code>init_IRQ();</code>中断初始化</li>
<li><code>tick_init(); </code> tick 初始化</li>
<li><code>init_timers();</code>初始化定时器</li>
<li><code>hrtimers_init();</code>初始化高精度定时器</li>
<li><code>softirq_init(); </code>软中断初始化</li>
<li><code>time_init();</code>初始化系统时间</li>
<li><code>local_irq_enable(); </code>使能中断</li>
<li><code>kmem_cache_init_late();</code> slab 初始化，slab 是 Linux 内存分配器</li>
<li><code>console_init(); </code>初始化控制台，之前 <u>print 打印的信息都存放 缓冲区中，并没有打印出来。只有调用此函数初始化控制台以后才能在控制台上打印信息</u>。</li>
<li><code>lockdep_info();</code>如果定义了宏 CONFIG_LOCKDEP，那么此函数打印一些信息</li>
<li><code>locking_selftest()</code>锁自测</li>
<li><code>kmemleak_init();</code>kmemleak 初始化，kmemleak 用于检查内存泄漏</li>
<li><code>calibrate_delay(); </code> 测定 BogoMIPS 值，可以通过 BogoMIPS 来判断 CPU 的性能.BogoMIPS 设置越大，说明 CPU 性能越好。</li>
<li><code>pidmap_init();</code> PID 位图初始化</li>
<li><code>anon_vma_init(); </code> 生成 anon_vma slab 缓存</li>
<li><code>cred_init();</code>为对象的每个用于赋予资格(凭证)</li>
<li><code>fork_init(); </code>初始化一些结构体以使用 fork 函数</li>
<li><code>proc_caches_init();</code>给各种资源管理结构分配缓存 </li>
<li><code>buffer_init();</code>初始化缓冲缓存</li>
<li><code>key_init();</code>初始化密钥 </li>
<li><code>security_init(); </code>安全相关初始化 </li>
<li><code>vfs_caches_init(totalram_pages); </code>为 VFS 创建缓存</li>
<li><code>signals_init();</code>初始化信号 </li>
<li><code>page_writeback_init(); </code>页回写初始化</li>
<li><code>proc_root_init(); </code>注册并挂载 proc 文件系统 </li>
<li><code>cpuset_init();</code>初始化 cpuset，cpuset 是将 CPU 和内存资源以逻辑性和层次性集成的一种机制，是 cgroup 使用的子系统之一</li>
<li><code>cgroup_init(); </code>初始化 cgroup</li>
<li><code>taskstats_init_early();</code>进程状态初始化</li>
<li><code>check_bugs();</code>检查写缓冲一致性</li>
</ul>
<h2 id="rest-init-函数"><a href="#rest-init-函数" class="headerlink" title="rest_init 函数"></a>rest_init 函数</h2><ul>
<li><p><img src="/imgs/image-20220227114640698.png" alt="image-20220227114640698"></p>
</li>
<li><p><img src="/imgs/image-20220227114923703.png" alt="image-20220227114923703"></p>
</li>
<li><p>执行内容</p>
<ul>
<li><p>第 387 行，调用函数 rcu_scheduler_starting，启动 RCU 锁调度器 </p>
</li>
<li><p>第 394 行，调用函数 <code>kernel_thread</code> 创建 <code>kernel_init</code> 进程，也就是大名鼎鼎的 <strong>init 内核进程</strong>。 <strong>init 进程的 PID 为 1</strong>。init 进程一开始是内核进程(也就是运行在内核态)，后面 init 进程会在根 文件系统中查找名为“init”这个程序，这个“init”程序处于用户态，通过运行这个“init”程 序，init 进程就会实现从<strong>内核态到用户态</strong>的转变。 </p>
</li>
<li><p>第 396 行，调用函数 <code>kernel_thread</code> 创建 <code>kthreadd </code>内核进程，此<strong>内核进程的 PID 为 2</strong>。<strong>kthreadd 进程负责所有内核进程的调度和管理</strong>。 </p>
</li>
<li><p>第 409 行，最后调用函数 cpu_startup_entry 来进入 idle 进程，cpu_startup_entry 会调用 cpu_idle_loop，cpu_idle_loop 是个 while 循环，也就是 idle 进程代码。idle 进程的 PID 为 0，idle 进程叫做空闲进程，如果学过 FreeRTOS 或者 UCOS 的话应该听说过空闲任务。idle 空闲进程 就和空闲任务一样，当 CPU 没有事情做的时候就在 idle 空闲进程里面“瞎逛游”，反正就是给 CPU 找点事做。当其他进程要工作的时候就会抢占 idle 进程，从而夺取 CPU 使用权。其实大 家应该可以看到 idle 进程并没有使用 kernel_thread 或者 fork 函数来创建，因为它是有主进程演 变而来的。 在 Linux 终端中输入“ps -A”就可以打印出当前系统中的所有进程，其中就能看到 init 进 程和 kthreadd 进程，如图</p>
</li>
<li><p><img src="/imgs/image-20220227120610800.png" alt="image-20220227120610800"></p>
</li>
<li><p>没有显示 PID 为 0 的 idle 进程，那是因为 <strong>idle 进程是内核进程。</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h2><ul>
<li><p>kernel_init 函数就是 init 进程具体做的工作，定义在文件 init/main.c 中，函数内容如下：</p>
</li>
<li><p><img src="/imgs/image-20220227122017680.png" alt="image-20220227122017680"></p>
</li>
<li><p><img src="/imgs/image-20220227122029865.png" alt="image-20220227122029865"></p>
<ul>
<li>第 932 行，<code>kernel_init_freeable</code> 函数用于完成 init 进程的一些其他初始化工作，稍后再来具 体看一下此函数。</li>
<li>第 940 行，ramdisk_execute_command 是一个全局的 char 指针变量，此变量值为“/init”， 也就是根目录下的 init 程序。ramdisk_execute_command 也可以通过 uboot 传递，在 bootargs 中 使用“rdinit=xxx”即可，xxx 为具体的 init 程序名字。 </li>
<li>第 943 行，如果存在“/init”程序的话就通过函数 run_init_process 来运行此程序。 </li>
<li>第 956 行，如果 ramdisk_execute_command 为空的话就看 execute_command 是否为空，反 正不管如何<strong>一定要在根文件系统中找到一个可运行的 init 程序</strong>。execute_command 的值是通过 uboot 传递，在 bootargs 中使用“init=xxxx”就可以了，比如“init=/linuxrc”表示根文件系统中 的 linuxrc 就是要执行的用户空间 init 程序。 </li>
<li>第 963~966 行，如果 ramdisk_execute_command 和 execute_command 都为空，那么就依次 查找“/sbin/init”、“/etc/init”、“/bin/init”和“/bin/sh”，这四个相当于备用 init 程序，如果这四 个也不存在，那么 Linux 启动失败！ </li>
<li>第 969 行，<u>如果以上步骤都没有找到用户空间的 init 程序，那么就提示错误发生！</u></li>
</ul>
</li>
</ul>
<h3 id="kernel-init-freeable-函数"><a href="#kernel-init-freeable-函数" class="headerlink" title="kernel_init_freeable 函数"></a>kernel_init_freeable 函数</h3><ul>
<li>kernel_init 会调用此函数来做一些 init 进程初始化工作。kernel_init_freeable 定义在文件 init/main.c 中</li>
<li>缩减后的函数内容如下</li>
<li><img src="/imgs/image-20220227122233775.png" alt="image-20220227122233775"></li>
<li><img src="/imgs/image-20220227122256401.png" alt="image-20220227122256401"><ul>
<li>第 1002 行，do_basic_setup 函数用于完成 Linux 下<u>设备驱动初始化</u>工作！非常重要。 do_basic_setup 会调用 driver_init 函数完成 Linux 下驱动模型子系统的初始化。</li>
<li> 第 1005 行，打开设备“/dev/console”，在 Linux 中一切皆为文件！因此<strong>“/dev/console”也 是一个文件</strong>，此<strong>文件为控制台设备</strong>。每个文件都有一个文件描述符，<u>此处打开的“/dev/console” 文件描述符为 0，作为标准输入(0)</u></li>
<li>第 1008 和 1009 行，sys_dup 函数将标准输入(0)的文件描述符复制了 2 次，一个作为标准 输出(1)，一个作为标准错误(2)。这样标准输入、输出、错误都是/dev/console 了。console 通过 uboot 的 bootargs 环境变量设置，“console=ttymxc0,115200”表示将/dev/ttymxc0 设置为 console， 也就是 I.MX6U 的串口 1。当然，也可以设置其他的设备为 console，比如虚拟控制台 tty1，设 置 tty1 为 console 就可以在 LCD 屏幕上看到系统的提示信息。</li>
<li> 第 1020 行，调用函数 prepare_namespace 来<strong>挂载根文件系统</strong>。根文件系统也是由命令行参 数指定的，就是 uboot 的 bootargs 环境变量。比如“root=/dev/mmcblk1p2 rootwait rw”就表示根 文件系统在/dev/mmcblk1p2 中，也就是 EMMC 的分区 2 中。</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-U-Boot入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/25/U-Boot%E5%85%A5%E9%97%A8/"
    >U_Boot入门</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/25/U-Boot%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2022-02-25T12:50:25.000Z" itemprop="datePublished">2022-02-25</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="U-Boot入门"><a href="#U-Boot入门" class="headerlink" title="U_Boot入门"></a>U_Boot入门</h1><h2 id="U-Boot简介"><a href="#U-Boot简介" class="headerlink" title="U_Boot简介"></a>U_Boot简介</h2><ul>
<li>Linux 系统要启动就必须需要一个 bootloader 程序，也就说芯片上电以后先运行一段 bootloader程序。这段bootloader程序会先初始化DDR等外设，然后将Linux内核从flash(NAND， NOR FLASH，SD，MMC 等)拷贝到 DDR 中，最后启动 Linux 内核。当然了，bootloader 的实 际工作要复杂的多，但是它最主要的工作就是启动 Linux 内核，bootloader 和 Linux 内核的关系 就跟 PC 上的 BIOS 和 Windows 的关系一样，bootloader 就相当于 BIOS。所以我们要先搞定 bootloader，很庆幸，有很多现成的 bootloader 软件可以使用，比如 U-Boot、vivi、RedBoot 等 等，其中以 U-Boot 使用最为广泛，为了方便书写，本书会将 U-Boot 写为 uboot。</li>
<li>uboot 的全称是 Universal Boot Loader，uboot 是一个遵循 GPL 协议的<strong>开源软件</strong>，uboot <strong>是一 个裸机代码，可以看作是一个裸机综合例程</strong>。现在的 uboot 已经支持液晶屏、网络、USB 等高 级功能。</li>
<li>uboot 官网为 <a target="_blank" rel="noopener" href="http://www.denx.de/wiki/U-Boot/">http://www.denx.de/wiki/U-Boot/</a></li>
</ul>
<h2 id="UBoot顶层makefile"><a href="#UBoot顶层makefile" class="headerlink" title="UBoot顶层makefile"></a>UBoot顶层makefile</h2><ul>
<li><p>编译需要的shell脚本</p>
<ul>
<li><img src="/imgs/image-20220225210752704.png" alt="image-20220225210752704"></li>
<li>第 1 行是 shell 脚本要求的，必须是“#!/bin/bash”或者“#!/bin/sh”</li>
<li>第 2 行使用了 make 命令，用于<u>清理工程</u>，也就是每次在编译 uboot 之前都清理一下工程。 这里的 make 命令带有三个参数，第一个是 ARCH，也就是指定架构，这里肯定是 arm；第二个 参数 CROSS_COMPILE 用于指定编译器，只需要<u>指明编译器前缀</u>就行了，比如 arm-linux-gnueabihf-gcc 编译器的前缀就是“arm-linux-gnueabihf-”；最后一个参数 distclean 就是清除工程。</li>
<li>第 3 行也使用了 make 命令，用于配置 uboot。同样有三个参数，不同的是，最后一个参数是 mx6ull_14x14_ddr512_emmc_defconfig。<strong>前面说了 uboot 是 bootloader 的一种，可以用来引导 Linux，但是 uboot 除了引导 Linux 以外还可以引导其它的系统</strong>，<u>而且 uboot 还支持其它的架构 和外设，比如 USB、网络、SD 卡等。这些都是可以配置的，需要什么功能就使能什么功能</u>。所 以在编译 uboot 之前，一定要根据自己的需求配置 uboot。mx6ull_14x14_ddr512_emmc_defconfig 就是正点原子针对 I.MX6U-ALPHA 的 EMMC 核心板编写的配置文件，这个配置文件在 uboot 源码的 configs 目录中。在 uboot 中，通过“make xxx_defconfig”来配置 uboot，xxx_defconfig 就是不同板子的配置文件，这些配置文件都在 uboot/configs 目录中</li>
<li>第 4 行有 4 个参数，用于编译 uboot，通过第 3 行配置好 uboot 以后就可以直接“make”编 译 uboot 了。其中 V=1 用于设置编译过程的信息输出级别；-j 用于设置主机使用多少线程编译 uboot，最好设置成我们虚拟机所设置的核心数，如果在 VMware 里面给虚拟就分配了 4 个核， 那么使用-j4 是最合适的，这样 4 个核都会一起编译</li>
</ul>
</li>
<li><p>查看UBoot之前需要先进行一次编译</p>
</li>
<li><p>编译后的文件结构</p>
</li>
<li><p><img src="/imgs/image-20220225210424844.png" alt="image-20220225210424844"></p>
</li>
<li><p><img src="/imgs/image-20220225210443748.png" alt="image-20220225210443748"></p>
</li>
<li><p>makefile文件是可以嵌套的</p>
</li>
<li><p>也就是顶层 Makefile 可以<strong>调用子目录 中的 Makefile 文件</strong>。Makefile 嵌套在大项目中很常见，一般大项目里面所有的源代码都不会放 到同一个目录中，各个功能模块的源代码都是分开的，各自存放在各自的目录中。每个功能模 块目录下都有一个 Makefile，这个 Makefile 只处理本模块的编译链接工作，这样所有的编译链接工作就不用全部放到一个 Makefile 中，可以使得 Makefile 变得简洁明了。</p>
</li>
</ul>
<h2 id="Makefile分析"><a href="#Makefile分析" class="headerlink" title="Makefile分析"></a>Makefile分析</h2><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul>
<li><p><img src="/imgs/image-20220225232512333.png" alt="image-20220225232512333"></p>
</li>
<li><p>顶层 Makefile 一开始是版本号，内容如下(为了方便分析，顶层 Makefile 代码段前段行号 采用 Makefile 中的行号，因为 uboot 会更新</p>
</li>
</ul>
<h3 id="MAKEFLAGS变量"><a href="#MAKEFLAGS变量" class="headerlink" title="MAKEFLAGS变量"></a>MAKEFLAGS变量</h3><ul>
<li>make 是支持递归调用的，也就是在 Makefile 中使用“make”命令来执行其他的 Makefile 文件，一般都是子目录中的 Makefile 文件。假如在当前目录下存在一个“subdir”子目录，这个 子目录中又有其对应的 Makefile 文件，那么这个工程在编译的时候其主目录中的 Makefile 就可 以调用子目录中的 Makefile，以此来完成所有子目录的编译。主目录的 Makefile 可以使用如下 代码来编译这个子目录：</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>

<ul>
<li>$(MAKE)就是调用“make”命令，-C 指定子目录。有时候我们需要向子 make 传递变量， 这个时候使用“export”来导出要传递给子 make 的变量即可，如果不希望哪个变量传递给子 make 的话就使用“unexport”来声明不导出:</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> VARIABLE …… //导出变量给子 make 。</span><br><span class="line"><span class="keyword">unexport</span> VARIABLE…… //不导出变量给子 make。</span><br></pre></td></tr></table></figure>

<ul>
<li>有两个特殊的变量：“SHELL”和“MAKEFLAGS”，这两个变量除非使用“unexport”声明， 否则的话在整个make的执行过程中，它们的值始终自动的传递给子make。在uboot的主Makefile 中有如下代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAKEFLAGS += -rR --include-dir=$(CURDIR)</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码使用“+=”来给变量 MAKEFLAGS 追加了一些值，“-rR”表示禁止使用内置的隐 含规则和变量定义，“–include-dir”指明搜索路径，”$(CURDIR)”表示当前目录。</li>
</ul>
<h3 id="命令输出"><a href="#命令输出" class="headerlink" title="命令输出"></a>命令输出</h3><ul>
<li><p>uboot 默认编译是不会在终端中显示完整的命令，都是短命令</p>
</li>
<li><p><img src="/imgs/image-20220225235732726.png" alt="image-20220225235732726"></p>
</li>
<li><p>上述代码中先使用 ifeq 来判断”$(origin V)”和”command line”是否相等。这里用到了 Makefile 中的函数 origin，origin 和其他的函数不一样，它不操作变量的值，origin 用于告诉你变量是哪 来的</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(origin &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>variable 是变量名，origin 函数的返回值就是变量来源，因此$(origin V)就是变量 V 的来源。 如果变量 V 是在命令行定义的那么它的来源就是”command line”，这样”$(origin V)”和”command  line”就相等了。当这两个相等的时候变量 KBUILD_VERBOSE 就等于 V 的值，比如在命令行中 输入“ V=1 “ 的 话 那 么 KBUILD_VERBOSE=1 。如果没有在命令行输入 V 的 话 KBUILD_VERBOSE=0</p>
</li>
<li><p>第 80 行判断 KBUILD_VERBOSE 是否为 1，如果 KBUILD_VERBOSE 为 1 的话变量 quiet</p>
</li>
<li><p>和 Q 都为空，如果 KBUILD_VERBOSE=0 的话变量 quiet 为“quiet_“，变量 Q 为“@”</p>
<ul>
<li><p>V=1 的话</p>
</li>
<li><p><img src="/imgs/image-20220226000158806.png" alt="image-20220226000158806"></p>
</li>
<li><p>V=0 或者命令行不定义 V 的话</p>
</li>
<li><p><img src="/imgs/image-20220226000426810.png" alt="image-20220226000426810"></p>
</li>
</ul>
</li>
<li><p>Makefile 中会用到变量 quiet 和 Q 来控制编译的时候是否在终端输出完整的命令，在顶层 Makefile 中有很多如下所示的命令</p>
<ul>
<li><code>$(Q)$(MAKE) $(build)=tools</code></li>
</ul>
</li>
<li><p>如果 V=0 的话上述命令展开就是“@ make $(build)=tools”，make 在执行的时候默认会在终 端输出命令，但是在命令前面加上“@”就不会在终端输出命令了。当 V=1 的时候 Q 就为空， 上述命令就是“make $(build)=tools”，因此在 make 执行的过程，命令会被完整的输出在终端上</p>
</li>
<li><p>有些命令会有两个版本</p>
<ul>
<li><img src="/imgs/image-20220226000920939.png" alt="image-20220226000920939"></li>
</ul>
</li>
<li><p>sym 命令分为“quiet_cmd_sym”和“cmd_sym”两个版本，这两个命令的功能都是一样的， 区别在于 make 执行的时候输出的命令不同。quiet_cmd_xxx 命令输出信息少，也就是短命令， 而 cmd_xxx 命令输出信息多，也就是完整的命令。</p>
<ul>
<li>如果变量 quiet 为空的话，整个命令都会输出。</li>
<li> 如果变量 quiet 为“quiet_”的话，仅输出短版本。 _</li>
<li>_如果变量 quiet 为“silent_”的话，整个命令都不会输出。</li>
</ul>
</li>
</ul>
<h3 id="静默输出"><a href="#静默输出" class="headerlink" title="静默输出"></a>静默输出</h3><ul>
<li><p>上一小节讲了，设置 V=0 或者在命令行中不定义 V 的话，编译 uboot 的时候终端中显示的 短命令，但是还是会有命令输出，有时候我们在编译 uboot 的时候不需要输出命令，这个时候 就可以使用 uboot 的静默输出功能。编译的时候使用“make -s”即可实现静默输出</p>
<ul>
<li><img src="/imgs/image-20220226002019735.png" alt="image-20220226002019735"></li>
<li><img src="/imgs/image-20220226002036927.png" alt="image-20220226002036927"></li>
</ul>
</li>
<li><p>判断当前正在使用的编译器版本号是否为 4.x，判断$(filter 4.%,$(MAKE_VERSION)) 和“ ”(空)是否相等，如果不相等的话就成立，执行里面的语句。也就是说 $(filter  4.%,$(MAKE_VERSION))不为空的话条件就成立，这里用到了 Makefile 中的 filter 函数，这是 个过滤函数，函数格式如下</p>
<ul>
<li><img src="/imgs/image-20220226002617614.png" alt="image-20220226002617614"></li>
<li>filter 函数表示以 pattern 模式过滤 text 字符串中的单词，仅保留符合模式 pattern 的单词， 可以有多个模式。函数返回值就是符合 pattern 的字符串。因此$(filter 4.%,$(MAKE_VERSION)) 的含义就是在字符串“MAKE_VERSION”中找出符合“4.%”的字符(%为通配符)， MAKE_VERSION 是make工具的版本号，ubuntu16.04里面默认自带的make工具版本号为4.1， 大家可以输入“make -v”查看。因此$(filter 4.%,$(MAKE_VERSION))不为空，条件成立</li>
</ul>
</li>
<li><p>，如果$(filter %s ,$(firstword x$(MAKEFLAGS)))不为空的话条件 成立，变量 quiet 等于“silent_”。这里也用到了函数 filter，在$(firstword x$(MAKEFLAGS)))中 过滤出符合“%s”的单词。到了函数 firstword，函数 firstword 是获取首单词，函数格式如下</p>
<ul>
<li><p><code>$(firstword &lt;text&gt;)</code></p>
</li>
<li><p>firstword 函数用于取出 text 字符串中的第一个单词，函数的返回值就是获取到的单词。当 使用“make -s”编译的时候，“-s”会作为 MAKEFLAGS 变量的一部分传递给 Makefile。</p>
</li>
<li><p>添加如下内容</p>
<ul>
<li><img src="/imgs/image-20220226105110225.png" alt="image-20220226105110225"></li>
</ul>
</li>
<li><p>可见增加<code>-s</code>之后，firstword变成了</p>
<ul>
<li><img src="/imgs/image-20220226110058265.png" alt="image-20220226110058265"></li>
<li>可见也不是直接<code>-s</code>，但是filter的返回值肯定不为空</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设置编译结果的输出目录"><a href="#设置编译结果的输出目录" class="headerlink" title="设置编译结果的输出目录"></a>设置编译结果的输出目录</h3><ul>
<li><p>uboot 可以将编译出来的目标文件输出到单独的目录中，在 make 的时候使用“O”来指定 输出目录，比如“make O=out”就是设置目标文件输出到 out 目录中。这么做是为了将源文件 和编译产生的文件分开，当然也可以不指定 O 参数，不指定的话源文件和编译产生的文件都在 同一个目录内，一般我们不指定 O 参数。</p>
</li>
<li><p><img src="/imgs/image-20220226110625560.png" alt="image-20220226110625560"></p>
</li>
<li><p><img src="/imgs/image-20220226110641751.png" alt="image-20220226110641751"></p>
</li>
<li><p>第 124 行判断“O”是否来自于命令行，如果来自命令行的话条件成立，KBUILD_OUTPUT 就为$(O)，因此变量 KBUILD_OUTPUT 就是输出目录。 </p>
</li>
<li><p>第 135 行判断 KBUILD_OUTPUT 是否为空。 </p>
</li>
<li><p>第 139 行调用 mkdir 命令，创建 KBUILD_OUTPUT 目录，并且将创建成功以后的绝对路 径赋值给 KBUILD_OUTPUT。至此，通过 O 指定的输出目录就存在了。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-DSP28377d开启fp_mode提高浮点数除法性能"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/19/DSP28377d%E5%BC%80%E5%90%AFfp_mode%E6%8F%90%E9%AB%98%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95%E6%80%A7%E8%83%BD/"
    >DSP28377d开启--fp_mode提高浮点数除法性能</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/19/DSP28377d%E5%BC%80%E5%90%AFfp_mode%E6%8F%90%E9%AB%98%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95%E6%80%A7%E8%83%BD/" class="article-date">
  <time datetime="2022-02-19T10:32:24.000Z" itemprop="datePublished">2022-02-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="DSP28377d开启–fp-mode提高浮点数除法性能"><a href="#DSP28377d开启–fp-mode提高浮点数除法性能" class="headerlink" title="DSP28377d开启–fp_mode提高浮点数除法性能"></a>DSP28377d开启–fp_mode提高浮点数除法性能</h1><p>在程序中执行浮点数除法比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Speed=(float)1000000/(float)count*speedTemp*15;</span><br></pre></td></tr></table></figure>

<p>的时候会看到如下的提示：</p>
<p><img src="/imgs/image-20220219183335144.png" alt="image-20220219183335144"></p>
<ul>
<li><p>此时需要在项目的<code>properties</code>中选择</p>
</li>
<li><p><img src="/imgs/image-20220219183408708.png" alt="image-20220219183408708"></p>
</li>
<li><p>选择<code>optimizations</code>中的<code>--fp_mode</code>为<code>relaxed</code>即可（如图）</p>
</li>
<li><p><img src="/imgs/image-20220219183528275.png" alt="image-20220219183528275"></p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-C语言常见内存操作函数"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/18/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"
    >C语言常见内存操作以及系统操作函数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/18/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/" class="article-date">
  <time datetime="2022-02-18T02:31:31.000Z" itemprop="datePublished">2022-02-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="C语言常见内存操作函数"><a href="#C语言常见内存操作函数" class="headerlink" title="C语言常见内存操作函数"></a>C语言常见内存操作函数</h1><ul>
<li>&lt;string.h&gt;目录 <a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-standard-library-string-h.html">https://www.runoob.com/cprogramming/c-standard-library-string-h.html</a></li>
</ul>
<h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy()"></a>memcpy()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void *memcpy(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>str1</strong> – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</p>
</li>
<li><p><strong>str2</strong> – 指向要复制的数据源，类型强制转换为 void* 指针。</p>
</li>
<li><p><strong>n</strong> – 要被复制的字节数。</p>
</li>
<li><p>该函数返回一个指向目标存储区 str1 的指针。</p>
</li>
</ul>
<h2 id="memchr"><a href="#memchr" class="headerlink" title="memchr()"></a>memchr()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *memchr(const void *str, int c, size_t n)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>str</strong> – 指向要执行搜索的内存块。</p>
</li>
<li><p><strong>c</strong> – 以 int 形式传递的值，但是函数在每次字节搜索时是使用该值的无符号字符形式。</p>
</li>
<li><p><strong>n</strong> – 要被分析的字节数。</p>
</li>
<li><p>该函数返回一个指向匹配字节的指针，如果在给定的内存区域未出现字符，则返回 NULL。</p>
</li>
</ul>
<h2 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp()"></a>memcmp()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int memcmp(const void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str1</strong> – 指向内存块的指针。</li>
<li><strong>str2</strong> – 指向内存块的指针。</li>
<li><strong>n</strong> – 要被比较的字节数。</li>
</ul>
<p>返回值</p>
<ul>
<li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li>
<li>如果返回值 &gt; 0，则表示 str1 大于 str2。</li>
<li>如果返回值 = 0，则表示 str1 等于 str2。</li>
</ul>
<h2 id="memmove"><a href="#memmove" class="headerlink" title="memmove()"></a>memmove()</h2><ul>
<li>C 库函数 <strong>void *memmove(void *str1, const void *str2, size_t n)</strong> 从 <strong>str2</strong> 复制 <strong>n</strong> 个字符到 <strong>str1</strong>，但是在重叠内存块这方面，memmove() 是比 memcpy() <strong>更安全</strong>的方法。如果目标区域和源区域有重叠的话，memmove() 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，复制后源区域的内容会被更改。如果目标区域与源区域<strong>没有重叠</strong>，则和 memcpy() 函数<strong>功能相同</strong>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *memmove(void *str1, const void *str2, size_t n)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str1</strong> – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>
<li><strong>str2</strong> – 指向要复制的数据源，类型强制转换为 void* 指针。</li>
<li><strong>n</strong> – 要被复制的字节数。</li>
<li>该函数返回一个指向目标存储区 str1 的指针。</li>
</ul>
<h2 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h2><ul>
<li>C 库函数 <strong>void *memset(void *str, int c, size_t n)</strong> 复制字符 <strong>c</strong>（一个无符号字符）到参数 <strong>str</strong> 所指向的字符串的前 <strong>n</strong> 个字符。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *memset(void *str, int c, size_t n)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 指向要填充的内存块。</li>
<li><strong>c</strong> – 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式。</li>
<li><strong>n</strong> – 要被设置为该值的字符数。</li>
<li>该值返回一个指向存储区 str 的指针。</li>
</ul>
<h2 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h2><ul>
<li>C 库函数 <strong>char *strcat(char *dest, const char *src)</strong> 把 <strong>src</strong> 所指向的字符串追加到 <strong>dest</strong> 所指向的字符串的结尾。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *strcat(char *dest, const char *src)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>dest</strong> – 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。</p>
</li>
<li><p><strong>src</strong> – 指向要追加的字符串，该字符串不会覆盖目标字符串。</p>
</li>
<li><p>该函数返回一个指向最终的目标字符串 dest 的指针。</p>
</li>
</ul>
<h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp()"></a>strcmp()</h2><ul>
<li>C 库函数 <strong>int strcmp(const char *str1, const char *str2)</strong> 把 <strong>str1</strong> 所指向的字符串和 <strong>str2</strong> 所指向的字符串进行比较。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int strcmp(const char *str1, const char *str2)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str1</strong> – 要进行比较的第一个字符串。</li>
<li><strong>str2</strong> – 要进行比较的第二个字符串。</li>
</ul>
<p>返回值</p>
<ul>
<li>如果返回值小于 0，则表示 str1 小于 str2。</li>
<li>如果返回值大于 0，则表示 str1 大于 str2。</li>
<li>如果返回值等于 0，则表示 str1 等于 str2。</li>
</ul>
<hr>
<ul>
<li>&lt;stdlib.h&gt;总目录 <a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-standard-library-stdlib-h.html">https://www.runoob.com/cprogramming/c-standard-library-stdlib-h.html</a></li>
</ul>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *malloc(size_t size)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>size</strong> – 内存块的大小，以字节为单位。</li>
<li>该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL。</li>
</ul>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h2><p>C 库函数 <strong>void *calloc(size_t nitems, size_t size)</strong> 分配所需的内存空间，并返回一个指向它的指针。<strong>malloc</strong> 和 <strong>calloc</strong> 之间的不同点是，<strong>malloc 不会设置内存为零，而 calloc 会设置分配的内存为零。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *calloc(size_t nitems, size_t size)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>nitems</strong> – 要被分配的元素个数。</li>
<li><strong>size</strong> – 元素的大小。</li>
</ul>
<h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc()"></a>realloc()</h2><p>C 库函数 <strong>void *realloc(void *ptr, size_t size)</strong> 尝试<u>重新调整之前调用 <strong>malloc</strong> 或 <strong>calloc</strong> 所分配的 <strong>ptr</strong> 所指向的内存块的大小。</u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *realloc(void *ptr, size_t size)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ptr</strong> – 指针指向一个要重新分配内存的内存块，该内存块之前是通过调用 malloc、calloc 或 realloc 进行分配内存的。如果为空指针，则会分配一个新的内存块，且函数返回一个指向它的指针。</li>
<li><strong>size</strong> – 内存块的新的大小，以字节为单位。如果大小为 0，且 ptr 指向一个已存在的内存块，则 ptr 所指向的内存块会被释放，并返回一个空指针。</li>
<li>该函数返回一个指针 ，指向重新分配大小的内存。如果请求失败，则返回 NULL。</li>
</ul>
<h2 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h2><p>C 库函数 <strong>void free(void *ptr)</strong> 释放之前调用 calloc、malloc 或 realloc 所分配的内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void free(void *ptr)</span><br></pre></td></tr></table></figure>

<h2 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h2><p>C 库函数 <strong>int system(const char *command)</strong> 把 <strong>command</strong> 指定的命令名称或程序名称传给要被命令处理器执行的主机环境，并在命令完成后返回。(实际上就是在程序中执行Linux命令行的指令)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int system(const char *command)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>command</strong> – 包含被请求变量名称的 C 字符串。</li>
<li>如果发生错误，则返回值为 -1，否则返回命令的状态。</li>
</ul>
<h2 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h2><p>C 库函数 <strong>int abs(int x)</strong> 返回 <strong>x</strong> 的绝对值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int abs(int x)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>x</strong> – 完整的值。</li>
<li>该函数返回 x 的绝对值。</li>
</ul>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit()"></a>exit()</h2><p>C 库函数 <strong>void exit(int status)</strong> 立即终止调用进程。任何属于该进程的打开的文件描述符都会被关闭，该进程的子进程由进程 1 继承，初始化，且会向父进程发送一个 SIGCHLD 信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void exit(int status)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>status</strong> – 返回给父进程的状态值。</li>
<li>该函数不返回值。</li>
</ul>
<h2 id="abort"><a href="#abort" class="headerlink" title="abort()"></a>abort()</h2><p>C 库函数 <strong>void abort(void)</strong> <strong>中止程序执行，直接从调用的地方跳出。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void abort(void)</span><br></pre></td></tr></table></figure>

<h2 id="atof"><a href="#atof" class="headerlink" title="atof()"></a>atof()</h2><p>C 库函数 <strong>double atof(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个浮点数（类型为 double 型），<u><strong>根据字面意思，不是根据具体的字节进行转换</strong></u></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double atof(const char *str)</span><br></pre></td></tr></table></figure>

<h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi()"></a>atoi()</h2><p>C 库函数 <strong>int atoi(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int atoi(const char *str)</span><br></pre></td></tr></table></figure>

<h2 id="atol"><a href="#atol" class="headerlink" title="atol()"></a>atol()</h2><p>C 库函数 <strong>long int atol(const char *str)</strong> 把参数 <strong>str</strong> 所指向的字符串转换为一个长整数（类型为 long int 型）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long int atol(const char *str)</span><br></pre></td></tr></table></figure>

<h2 id="strtod"><a href="#strtod" class="headerlink" title="strtod()"></a>strtod()</h2><p>C 库函数 *<em>double strtod(const char *str, char *<em>endptr)</em></em> 把参数 <strong>str</strong> 所指向的字符串转换为一个浮点数（类型为 double 型）。如果 <strong>endptr</strong> 不为空，则指向转换中最后一个字符后的字符的指针会存储在 endptr 引用的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double strtod(const char *str, char **endptr)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 要转换为双精度浮点数的字符串。</li>
<li><strong>endptr</strong> – 对类型为 char* 的对象的引用，其值由函数设置为 <strong>str</strong> 中<u>数值后的下一个字符。</u></li>
</ul>
<h2 id="strtol"><a href="#strtol" class="headerlink" title="strtol()"></a>strtol()</h2><p>C 库函数 *<em>long int strtol(const char *str, char *<em>endptr, int base)</em></em> 把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long int strtol(const char *str, char **endptr, int base)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 要转换为长整数的字符串。</li>
<li><strong>endptr</strong> – 对类型为 char* 的对象的引用，其值由函数设置为 <strong>str</strong> 中数值后的下一个字符。</li>
<li><strong>base</strong> – 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。</li>
</ul>
<h2 id="strtoul"><a href="#strtoul" class="headerlink" title="strtoul()"></a>strtoul()</h2><p>C 库函数 *<em>unsigned long int strtoul(const char *str, char *<em>endptr, int base)</em></em> 把参数 <strong>str</strong> 所指向的字符串根据给定的 <strong>base</strong> 转换为一个无符号长整数（类型为 unsigned long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long int strtoul(const char *str, char **endptr, int base)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>str</strong> – 要转换为无符号长整数的字符串。</li>
<li><strong>endptr</strong> – 对类型为 char* 的对象的引用，其值由函数设置为 str 中数值后的下一个字符。</li>
<li><strong>base</strong> – 基数，必须介于 2 和 36（包含）之间，或者是特殊值 0。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-DSP28377相关知识"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/16/DSP28377%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"
    >DSP28377相关知识</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/16/DSP28377%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" class="article-date">
  <time datetime="2022-02-16T07:43:53.000Z" itemprop="datePublished">2022-02-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="DSP28377相关知识"><a href="#DSP28377相关知识" class="headerlink" title="DSP28377相关知识"></a>DSP28377相关知识</h1><h2 id="BLDC（PWM）相关"><a href="#BLDC（PWM）相关" class="headerlink" title="BLDC（PWM）相关"></a>BLDC（PWM）相关</h2><ul>
<li>驱动的PWM中135为一组，246为一组</li>
<li></li>
</ul>
<h2 id="串口相关"><a href="#串口相关" class="headerlink" title="串口相关"></a>串口相关</h2><ul>
<li>中断：TXINT和RXINT</li>
</ul>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>开启中断的步骤</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “DSP2833x_Device.h”</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> “DSP2833x_Examples.h”</span></span><br><span class="line"></span><br><span class="line">interrupt <span class="keyword">void</span> cpu_TImer0_isr（<span class="keyword">void</span>）;<span class="comment">//声明中断服务函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main（）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step1：初始化系统控制、PLL、看门狗、允许外设时钟</span></span><br><span class="line"></span><br><span class="line">    InitSysCtrl（）;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step2：初始化GPIO</span></span><br><span class="line"></span><br><span class="line">    InitGpio（）;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step3：清除所有中断，初始化PIE向量表</span></span><br><span class="line"></span><br><span class="line">    DINT;</span><br><span class="line"></span><br><span class="line">    InitPieCtrl（）; <span class="comment">//初始化PIE控制器</span></span><br><span class="line"></span><br><span class="line">    IER = <span class="number">0x0000</span>; <span class="comment">//禁止CPU中断</span></span><br><span class="line"></span><br><span class="line">    IFR = <span class="number">0x0000</span>; <span class="comment">//清除所有CPU中断标志</span></span><br><span class="line"></span><br><span class="line">    InitPieVectTable（）; <span class="comment">//初始化PIE中断向量表</span></span><br><span class="line"></span><br><span class="line">    EALLOW;</span><br><span class="line"></span><br><span class="line">    PieVectTable.TINT0 = &amp;cpu_TImer0_isr; <span class="comment">//重映射中断向量，指向中断服务程序</span></span><br><span class="line"></span><br><span class="line">    EDIS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step4：初始化外设模块</span></span><br><span class="line"></span><br><span class="line">    InitCpuTImers（）;</span><br><span class="line"></span><br><span class="line">    ConfigCpuTimer（&amp;CpuTimer0，<span class="number">150</span>，<span class="number">1000000</span>）; <span class="comment">//150MHz，周期1秒</span></span><br><span class="line"></span><br><span class="line">    CpuTimer0Regs.TCR.all = <span class="number">0x4001</span>; <span class="comment">//允许定时器中断，且设置TSS为0启动定时器工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//step5：</span></span><br><span class="line"></span><br><span class="line">    IER |= M_INT1; <span class="comment">//允许CPU的INT1中断，该中断连接至TINT0</span></span><br><span class="line"></span><br><span class="line">    PieCtrlRegs.PIEIER1.bit.INTx7 = <span class="number">1</span>; <span class="comment">//在PIE中断组1中允许TINT0中断</span></span><br><span class="line"></span><br><span class="line">    EINT; <span class="comment">//清除全局屏蔽</span></span><br><span class="line"></span><br><span class="line">    ERTM; <span class="comment">//允许全局实时中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//step6：循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>（<span class="number">1</span>）;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interrupt <span class="keyword">void</span> cpu_timer0_isr（<span class="keyword">void</span>）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CpuTimer0.InterruptCount++;</span><br><span class="line"></span><br><span class="line">    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; <span class="comment">//清除PIE中断组1的应答位，以便CPU再次响应</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-DSP28377d与无刷直流电机的接线方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/16/DSP28377d%E4%B8%8E%E6%97%A0%E5%88%B7%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E7%9A%84%E6%8E%A5%E7%BA%BF%E6%96%B9%E6%B3%95/"
    >DSP28377d与无刷直流电机的接线方法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/16/DSP28377d%E4%B8%8E%E6%97%A0%E5%88%B7%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E7%9A%84%E6%8E%A5%E7%BA%BF%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2022-02-16T03:48:12.000Z" itemprop="datePublished">2022-02-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="DSP28377d与无刷直流电机的接线方法"><a href="#DSP28377d与无刷直流电机的接线方法" class="headerlink" title="DSP28377d与无刷直流电机的接线方法"></a>DSP28377d与无刷直流电机的接线方法</h1><h2 id="霍尔传感器："><a href="#霍尔传感器：" class="headerlink" title="霍尔传感器："></a>霍尔传感器：</h2><ul>
<li>程序中指定的CAP霍尔传感器输入引脚为</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InitECap1Gpio(<span class="number">20</span>);</span><br><span class="line">GPIO_SetupPinOptions(<span class="number">20</span>, GPIO_INPUT, GPIO_ASYNC);</span><br><span class="line">InitECap2Gpio(<span class="number">21</span>);</span><br><span class="line">GPIO_SetupPinOptions(<span class="number">21</span>, GPIO_INPUT, GPIO_ASYNC);</span><br><span class="line">InitECap3Gpio(<span class="number">23</span>);</span><br><span class="line">GPIO_SetupPinOptions(<span class="number">23</span>, GPIO_INPUT, GPIO_ASYNC);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>找到芯片的20，21和23脚，位置在</p>
</li>
<li><p><img src="/imgs/image-20220216115100394.png" alt="image-20220216115100394"></p>
</li>
</ul>
<p>对应的是开发板上的外扩引脚</p>
<ul>
<li><p><img src="/imgs/image-20220216115209306.png" alt="image-20220216115209306"></p>
</li>
<li><p>所以电机驱动板上的<strong>中间霍尔传感器输出口的2，3，4pin</strong>分别连接开发板上<strong>J5的25，26，27引脚</strong>，同时利用J5的30和29脚分别是5V和GND给电机控制板提供5V电源，以上的排针倒数6pin中除了CAP4之外，都接到电机驱动板上的对应的引脚上了。</p>
</li>
</ul>
<h2 id="电机驱动-PWM"><a href="#电机驱动-PWM" class="headerlink" title="电机驱动  PWM"></a>电机驱动  PWM</h2><ul>
<li><p>PWM的连接比较简单，主要就是将开发板上的J5的前6个输出脚</p>
</li>
<li><p><img src="/imgs/image-20220216115439328.png" alt="image-20220216115439328"></p>
</li>
<li><p>按照1-6的顺序对应连接到电机驱动板上的长排针PWM1-6</p>
</li>
<li><p><img src="/imgs/image-20220216115526376.png" alt="image-20220216115526376"></p>
</li>
<li><p>如上，再加上供电即可</p>
</li>
<li><p>注意，假如传感器接线存在问题，电机会停在某一个相位不动（有力矩阻碍转动但是自身不转动）而且会产生大量的热，同时电源会发出一个电流声（猜测是电流太大引起的）。</p>
</li>
</ul>
<h2 id="接线图"><a href="#接线图" class="headerlink" title="接线图"></a>接线图</h2><ul>
<li><p><img src="/imgs/image-20220216120140369.png" alt="image-20220216120140369"></p>
</li>
<li><p><img src="/imgs/image-20220216120155122.png" alt="image-20220216120155122"></p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-C语言多个线程与客户端通信的服务器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/06/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"
    >C语言多个线程与客户端通信的服务器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/06/C%E8%AF%AD%E8%A8%80%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time datetime="2022-02-06T14:11:40.000Z" itemprop="datePublished">2022-02-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="C语言多个线程与客户端通信的服务器"><a href="#C语言多个线程与客户端通信的服务器" class="headerlink" title="C语言多个线程与客户端通信的服务器"></a>C语言多个线程与客户端通信的服务器</h1><ul>
<li>代码结构：将与客户端收发信息的部分单独取出放入新的线程中</li>
<li>捕获服务器收到的<code>Ctrl+c</code>信号（也就是<code>SIGINT</code>），将此信号绑定一个自定义的信号处理函数（为了防止程序被中断但是没有关闭socket描述符）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVERPORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*linux上支持（Android上也支持）， 此函数不仅能获取IP，还可以获取MAC地址、掩码和广播地址等*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_local_ip_using_ifconf</span><span class="params">(<span class="keyword">char</span> *str_ip)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock_fd, intrface;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">buf</span>[<span class="title">INET_ADDRSTRLEN</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ifconf</span> <span class="title">ifc</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *local_ip = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ifc.ifc_len = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">		ifc.ifc_buf = (<span class="keyword">caddr_t</span>)buf;</span><br><span class="line">		<span class="keyword">if</span> (!ioctl(sock_fd, SIOCGIFCONF, (<span class="keyword">char</span> *)&amp;ifc))</span><br><span class="line">		&#123;</span><br><span class="line">			intrface = ifc.ifc_len/<span class="keyword">sizeof</span>(struct ifreq);</span><br><span class="line">			<span class="keyword">while</span> (intrface-- &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!(ioctl(sock_fd, SIOCGIFADDR, (<span class="keyword">char</span> *)&amp;buf[intrface])))</span><br><span class="line">				&#123;</span><br><span class="line">					local_ip = <span class="literal">NULL</span>;</span><br><span class="line">					local_ip = inet_ntoa(((struct sockaddr_in*)(&amp;buf[intrface].ifr_addr))-&gt;sin_addr);</span><br><span class="line">					<span class="keyword">if</span>(local_ip)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">strcpy</span>(str_ip, local_ip);</span><br><span class="line">						status = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, str_ip))</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		close(sock_fd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">clientRoutine</span><span class="params">(<span class="keyword">void</span> * clientFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* clientFdt = (<span class="keyword">int</span>*)clientFd;</span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">512</span>];</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接收缓冲区清零</span></span><br><span class="line">        <span class="built_in">memset</span>(recvbuf, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        ret = recv(*clientFdt, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt;= ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;client disconnected&quot;</span>);</span><br><span class="line">            close(*clientFdt);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将读取到的数据以字符串形式打印出来</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;from client: %s\n&quot;</span>, recvbuf);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(<span class="string">&quot;exit&quot;</span>, recvbuf, <span class="number">4</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server exit...\n&quot;</span>);</span><br><span class="line">            close(*clientFdt);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIGINTHandler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nServer stopping, already closed socket %d. \n&quot;</span>, sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ip_str[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> localIPBuf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    signal(SIGINT, (<span class="keyword">sig_t</span>)SIGINTHandler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 打开套接字，得到套接字描述符 */</span></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; sockfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将套接字与指定端口号进行绑定 */</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(SERVERPORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    get_local_ip_using_ifconf(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    inet_ntop(AF_INET, &amp;(server_addr.sin_addr), localIPBuf, <span class="keyword">sizeof</span>(localIPBuf));</span><br><span class="line">    <span class="built_in">puts</span>(localIPBuf);</span><br><span class="line"></span><br><span class="line">    ret = bind(sockfd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 使服务器进入监听状态 */</span></span><br><span class="line">    ret = listen(sockfd, <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; ret)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 阻塞等待客户端连接 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> clientTemp;</span><br><span class="line">        clientTemp = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;addrlen);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt; clientTemp)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">            close(sockfd);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;有客户端接入...\n&quot;</span>);</span><br><span class="line">        inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, ip_str, <span class="keyword">sizeof</span>(ip_str));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端主机的 IP 地址: %s\n&quot;</span>, ip_str);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;客户端进程的端口号: %d\n&quot;</span>, client_addr.sin_port);</span><br><span class="line">        <span class="keyword">pthread_t</span> thTemp;</span><br><span class="line">        pthread_create(&amp;thTemp, <span class="literal">NULL</span>, clientRoutine, &amp;clientTemp);</span><br><span class="line">        <span class="comment">/* 接收客户端发送过来的数据 */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭套接字 */</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>效果</li>
<li><img src="/imgs/image-20220206222037573.png" alt="image-20220206222037573"></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-LinuxSocket编程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/30/LinuxSocket%E7%BC%96%E7%A8%8B/"
    >LinuxSocket编程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/30/LinuxSocket%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2022-01-30T08:50:09.000Z" itemprop="datePublished">2022-01-30</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux-Socket编程"><a href="#Linux-Socket编程" class="headerlink" title="Linux Socket编程"></a>Linux Socket编程</h1><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul>
<li>套接字（socket）是 Linux 下的一种进程间通信机制（socket IPC），在前面的内容中已经给大家提到过， <strong>使用 socket IPC 可以使得在不同主机上的应用程序之间进行通信</strong>（网络通信），当然也可以是<strong>同一台主机上 的不同应用程序</strong>。socket IPC 通常使用客户端&lt;—&gt;服务器这种模式完成通信，多个客户端可以同时连接到服务器中，与服务器之间完成数据交互。</li>
<li>当前网络中的主流程序设计都是使用 socket 进行编程的，因为它简单易用，它还是一个标准（BSD  socket），能在不同平台很方便移植，比如你的一个应用程序是基于 socket 接口编写的，那么它可以移植到 任何实现 BSD socket 标准的平台，譬如 LwIP，它兼容 BSD Socket；又譬如 Windows，它也实现了一套基于 socket 的套接字接口，更甚至在国产操作系统中，如 RT-Thread，它也实现了 BSD socket 标准的 socket 接 口。</li>
</ul>
<h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket()函数"></a>socket()函数</h4><ul>
<li>socket()函数类似于 open()函数，它用于创建一个网络通信端点（打开一个网络通信），如果成功则返回 一个网络文件描述符，通常把这个文件描述符称为 socket 描述符（socket descriptor），这个 socket 描述符跟 文件描述符一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数 domain 用于指定一个通信域；这将选择将用于通信的协议族。可选的协议族如下表所示</p>
<ul>
<li><p><img src="/imgs/image-20220130165700332.png" alt="image-20220130165700332"></p>
</li>
<li><p><img src="/imgs/image-20220130165812152.png" alt="image-20220130165812152"></p>
</li>
<li><p>对于 TCP/IP 协议来说，通常选择 <strong>AF_INET</strong> 就可以了，当然如果你的 IP 协议的版本支持 IPv6，那么可 以选择 <strong>AF_INET6</strong>。</p>
</li>
</ul>
</li>
<li><p>参数 type 指定套接字的类型，当前支持的类型有</p>
<ul>
<li><img src="/imgs/image-20220130165859271.png" alt="image-20220130165859271"></li>
</ul>
</li>
<li><p>参数 protocol 通常设置为 0，表示为给定的通信域和套接字类型选择默认协议。当对同一域和套接字类 型支持多个协议时，可以使用 protocol 参数选择一个特定协议。在 AF_INET 通信域中，套接字类型为 SOCK_STREAM 的默认协议是传输控制协议（Transmission Control Protocol，TCP 协议）。在 AF_INET 通 信域中，套接字类型为 SOCK_DGRAM 的默认协议时 UDP。</p>
</li>
<li><p>调用 socket()与调用 open()函数很类似，调用成功情况下，均会返回用于文件 I/O 的文件描述符，只不 过对于 socket()来说，其<strong>返回的文件描述符一般称为 socket 描述符</strong>。当不再需要该文件描述符时，可调用 close()函数来关闭套接字，释放相应的资源。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//打开套接字</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &gt; socket_fd) &#123;</span><br><span class="line">     perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">close(socket_fd); <span class="comment">//关闭套接字</span></span><br></pre></td></tr></table></figure>

<h4 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind()函数"></a>bind()函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>bind()函数用于将一个 IP 地址或端口号与一个套接字进行绑定（将套接字与地址进行关联）。</li>
<li>一般来讲，会将一个服务器的 套接字绑定到一个众所周知的地址—即一个固定的与服务器进行通信的客户端应用程序提前就知道的地址 （注意这里说的地址包括 IP 地址和端口号）。因为对于客户端来说，它与服务器进行通信，首先需要知道 服务器的 IP 地址以及对应的端口号，所以通常服务器的 IP 地址以及端口号都是众所周知的。</li>
<li>参数 addr 是一个指针，指向一个 struct sockaddr 类型变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"> 	<span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"> 	<span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二个成员 sa_data 是一个 char 类型数组，一共 14 个字节，在这 14 个字节中就包括了 IP 地址、端口 号等信息，这个结构对用户并不友好，它把这些信息都封装在了 sa_data 数组中，这样使得用户是无法对 sa_data 数组进行赋值。事实上，这是一个通用的 socket 地址结构体。</li>
<li>一般我们在使用的时候都会使用 struct sockaddr_in 结构体，sockaddr_in 和 sockaddr 是<strong>并列的结构</strong>（<strong>占 用的空间是一样的</strong>），<strong>指向 sockaddr_in 的结构体的指针也可以指向 sockadd 的结构体，并代替它</strong>，而且 sockaddr_in 结构对用户将更加友好，在使用的时候进行类型转换就可以了。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"> <span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* 协议族 */</span></span><br><span class="line"> <span class="keyword">in_port_t</span> sin_port; <span class="comment">/* 端口号 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* IP 地址 */</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen()函数"></a>listen()函数</h4><ul>
<li>listen()函数只能在服务器进程中使用，让服务器进程进入监听状态，等待客户端的连接请求，listen()函 数在一般在 bind()函数之后调用，在 accept()函数之前调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数 backlog 用来描述 sockfd 的等待连接队列能够达到的最大值。在服务器进程正处理客户端连接请 求的时候，可能还存在其它的客户端请求建立连接，因为 TCP 连接是一个过程，由于同时尝试连接的用户 过多，使得服务器进程<strong>无法快速地完成所有的连接请求</strong>.因此<strong>内核会在自己的进程空间里维护一个队列</strong>，这些连接请求就会被放入一个队 列中，服务器进程会按照先来后到的顺序去处理这些连接请求，这样的一个队列内核不可能让其任意大，所 以必须有一个大小的上限，这个 backlog 参数告诉内核使用这个数值作为队列的上限。而当一个客户端的连接请求到达并且该队列为满时，客户端可能会收到一个表示连接失败的错误，本次请求会被丢弃不作处理。</li>
</ul>
<h4 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept()函数"></a>accept()函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>服务器流程</p>
<ul>
<li>调用 socket()函数打开套接字；</li>
<li>调用 bind()函数将套接字与一个端口号以及 IP 地址进行绑定；</li>
<li>调用 listen()函数让服务器进程进入监听状态，监听客户端的连接请求；</li>
<li>调用 accept()函数处理到来的连接请求。</li>
</ul>
</li>
<li><p>accept()函数通常只用于服务器应用程序中，如果调用 accept()函数时，并没有客户端请求连接（等待连 接队列中也没有等待连接的请求），此时 accept()会进入阻塞状态，直到有客户端连接请求到达为止。</p>
</li>
<li><p>当有 客户端连接请求到达时，accept()函数与远程客户端之间建立连接，accept()函数返回一个新的套接字。这个 套接字与 socket()函数返回的套接字并不同，socket()函数返回的是服务器的套接字（以服务器为例）</p>
</li>
<li><p><strong>accept()函数返回的套接字连接到调用 connect()的客户端</strong>，服务器<strong>通过该套接字与客户端进行数据交互</strong>，譬 如向客户端发送数据、或从客户端接收数据。</p>
</li>
<li><p>参数 addr 是一个传出参数，参数 addr 用来<strong>返回已连接的客户端的 IP 地址与端口号等这些信息</strong>。参数 addrlen 应设置为 addr 所指向的对象的字节长度，如果我们对客户端的 IP 地址与端口号这些信息不感兴趣， 可以把 arrd 和 addrlen <strong>均置为空指针 NULL</strong>。</p>
</li>
</ul>
<h4 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect()函数"></a>connect()函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>该函数用于客户端应用程序中，<strong>客户端调用</strong> connect()函数将套接字 sockfd 与远程服务器进行连接，参 数 addr 指定了待连接的服务器的 IP 地址以及端口号等信息，参数 addrlen 指定了 addr 指向的 struct sockaddr 对象的字节大小。</li>
<li>客户端通过 connect()函数请求与服务器建立连接，对于 TCP 连接来说，调用该函数将发生 TCP 连接的 握手过程，并最终建立一个 TCP 连接，而对于 UDP 协议来说，调用这个函数只是在 sockfd 中记录服务器 IP 地址与端口号，而不发送任何数据。</li>
<li>函数调用成功则返回 0，失败返回-1，并设置 errno 以指示错误原因。</li>
</ul>
<h3 id="发送和接收函数"><a href="#发送和接收函数" class="headerlink" title="发送和接收函数"></a>发送和接收函数</h3><h4 id="read-函数"><a href="#read-函数" class="headerlink" title="read()函数"></a>read()函数</h4><ul>
<li>通过 read()函数从一个文件描述符中读取指定字节大小的数据并放入到指 定的缓冲区中，read()调用成功将返回读取到的字节数，此返回值受文件剩余字节数限制，当返回值小于指 定的字节数时并不意味着错误；这可能是因为当前可读取的字节数小于指定的字节数（比如已经接近文件 结尾，或者正在从管道或者终端读取数据，或者 read()函数被信号中断等），出错返回-1 并设置 errno，如果 在调 read 之前已到达文件末尾，则这次 read 返回 0。</li>
<li>套接字描述符<strong>也是文件描述符</strong>，所以使用 read()函数读取网络数据时，read()函数的参数 <strong>fd 就是对应的 套接字描述符</strong>。</li>
</ul>
<h4 id="recv-函数"><a href="#recv-函数" class="headerlink" title="recv()函数"></a>recv()函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不论是客户端还是服务器都可以通过 revc()函数读取网络数据，它与 read()函数的功能是相似的。参数 sockfd 指定套接字描述符，参数 buf 指向了一个数据接收缓冲区，参数 len 指定了读取数据的字节大小，参 数 flags 可以指定一些标志用于控制如何接收数据。</p>
</li>
<li><p>函数 recv()与 read()很相似，但是 recv()可以通过指定 flags 标志来控制如何接收数据，这些标志如下所 示：</p>
<ul>
<li><p><img src="/imgs/image-20220130174245872.png" alt="image-20220130174245872"></p>
</li>
<li><p>通常一般我们将 flags 参数设置为 0，当然，你可以根据自己的需求设置该参数。</p>
</li>
<li><p>当指定 MSG_PEEK 标志时，可以查看下一个要读取的数据但不真正取走它，当再次调用 read 或 recv 函数时，会返回刚才查看的数据。</p>
</li>
<li><p>对于 SOCK_STREAM 类型套接字，接收的数据可以比指定的字节大小少。MSG_WAITALL 标志会阻 止这种行为，<strong>直到所请求的数据全部返回，recv 函数才会返回</strong>。对于 SOCK_DGRAM 和 SOCK_SEQPACKET 套接字，MSG_WAITALL 标志并不会改变什么行为，因为这些基于报文的套接字类型一次读取就返回整个 报文。</p>
</li>
<li><p>如果发送者已经调用 shutdown 来结束传输，或者网络协议支持按默认的顺序关闭并且发送端已经关闭， 那么当所有的数据接收完毕后，recv 会返回 0。</p>
</li>
</ul>
</li>
</ul>
<h4 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h4><ul>
<li>通过 write()函数可以向套接字描述符中写入数据，函数调用成功返回写入的字节数，失败返回-1，并设 置 errno 变量。</li>
</ul>
<h4 id="send-函数"><a href="#send-函数" class="headerlink" title="send()函数"></a>send()函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>send 和 write 很相似，但是 send 可以通过参数 flags 指定一些标志，来改变处理传输数据的方式。</p>
<ul>
<li><img src="/imgs/image-20220130174442209.png" alt="image-20220130174442209"></li>
</ul>
</li>
<li><p>即使 send()成功返回，也并不表示连接的另一端的进程就一定接收了数据，我们所能保证的只是当 send 成功返回时，数据已经被<strong>无错误的发送到网络驱动程序上</strong>。</p>
</li>
</ul>
<h4 id="close-关闭套接字"><a href="#close-关闭套接字" class="headerlink" title="close()关闭套接字"></a>close()关闭套接字</h4><ul>
<li>当不再需要套接字描述符时，可调用 close()函数来关闭套接字，释放相应的资源。</li>
</ul>
<h3 id="IP-地址格式转换函数"><a href="#IP-地址格式转换函数" class="headerlink" title="IP 地址格式转换函数"></a>IP 地址格式转换函数</h3><ul>
<li>对于人来说，我们更容易阅读的是点分十进制的 IP 地址，譬如 192.168.1.110、192.168.1.50，这其实是 一种字符串的形式，但是计算机所需要理解的是二进制形式的 IP 地址，所以我们就需要在点分十进制字符 串和二进制地址之间进行转换。</li>
<li>点分十进制字符串和二进制地址之间的转换函数主要有：inet_aton、inet_addr、inet_ntoa、inet_ntop、 inet_pton 这五个，在我们的应用程序中使用它们需要包含头文件、以及&lt;netinet/in.h&gt;。</li>
</ul>
<h4 id="inet-aton、inet-addr、inet-ntoa-函数"><a href="#inet-aton、inet-addr、inet-ntoa-函数" class="headerlink" title="inet_aton、inet_addr、inet_ntoa 函数"></a>inet_aton、inet_addr、inet_ntoa 函数</h4><ul>
<li>这些函数可将一个 IP 地址在点分十进制表示形式和二进制表示形式之间进行转换，这些函数已经废弃 了，基本不用这些函数了，但是在一些旧的代码中可能还会看到这些函数。完成此类转换工作我们应该使用 下面介绍的这些函数。</li>
</ul>
<h4 id="inet-ntop、inet-pton-函数"><a href="#inet-ntop、inet-pton-函数" class="headerlink" title="inet_ntop、inet_pton 函数"></a>inet_ntop、inet_pton 函数</h4><ul>
<li>inet_ntop()、inet_pton()与 inet_ntoa()、inet_aton()类似，但它们还支持 IPv6 地址。它们将二进制 Ipv4 或 Ipv6 地址转换成以点分十进制表示的字符串形式，或将点分十进制表示的字符串形式转换成二进制 Ipv4 或 Ipv6 地址。使用这两个函数只需包含头文件即可！</li>
<li><strong>inet_pton()函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>inet_pton()函数将点分十进制表示的字符串形式转换成二进制 Ipv4 或 Ipv6 地址。</p>
</li>
<li><p>inet_pton()函数将点分十进制表示的字符串形式转换成二进制 Ipv4 或 Ipv6 地址。 将字符串 src 转换为二进制地址，参数 af 必须是 AF_INET 或 AF_INET6，AF_INET 表示待转换的 Ipv4 地址，AF_INET6 表示待转换的是 Ipv6 地址；并将转换后得到的地址存放在参数 dst 所指向的对象中，如果 参数 af 被指定为 AF_INET，则参数 dst 所指对象应该是一个 struct in_addr 结构体的对象；如果参数 af 被指 定为 AF_INET6，则参数 dst 所指对象应该是一个 struct in6_addr 结构体的对象。</p>
</li>
<li><p>inet_pton()转换成功返回 1（已成功转换）。如果 src 不包含表示指定地址族中有效网络地址的字符串， 则返回 0。如果 af 不包含有效的地址族，则返回-1 并将 errno 设置为 EAFNOSUPPORT。</p>
</li>
<li><p><strong>inet_ntop()函数</strong></p>
</li>
<li><p>inet_ntop()函数执行与 inet_pton()相反的操作</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数 af 与 inet_pton()函数的 af 参数意义相同。 </li>
<li>参数 src 应指向一个 struct in_addr 结构体对象或 struct in6_addr 结构体对象，依据参数 af 而定。函数 inet_ntop()会将参数 src 指向的二进制 IP 地址转换为点分十进制形式的字符串，并将字符串存放在参数 dst所指的缓冲区中</li>
<li>参数 size 指定了该缓冲区的大小。 inet_ntop()在成功时会返回 dst 指针。如果 size 的值太小了，那么将会返回 NULL 并将 errno 设置为 ENOSPC。</li>
</ul>
<p><strong>使用例</strong></p>
<ul>
<li>服务端</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888 <span class="comment">//端口号不能发生冲突,不常用的端口号通常大于 5000</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">char</span> ip_str[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">int</span> sockfd, connfd;</span><br><span class="line"> <span class="keyword">int</span> addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"> <span class="keyword">char</span> recvbuf[<span class="number">512</span>];</span><br><span class="line"> <span class="keyword">int</span> ret;</span><br><span class="line"> <span class="comment">/* 打开套接字，得到套接字描述符 */</span></span><br><span class="line"> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; sockfd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将套接字与指定端口号进行绑定 */</span></span><br><span class="line"> server_addr.sin_family = AF_INET;</span><br><span class="line"> server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"> server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line"> ret = bind(sockfd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line"> close(sockfd);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使服务器进入监听状态 */</span></span><br><span class="line"> ret = listen(sockfd, <span class="number">50</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line"> close(sockfd);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 阻塞等待客户端连接 */</span></span><br><span class="line"> connfd = accept(sockfd, (struct sockaddr *)&amp;client_addr, &amp;addrlen);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; connfd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line"> close(sockfd);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;有客户端接入...\n&quot;</span>);</span><br><span class="line"> inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, ip_str, <span class="keyword">sizeof</span>(ip_str));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;客户端主机的 IP 地址: %s\n&quot;</span>, ip_str);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;客户端进程的端口号: %d\n&quot;</span>, client_addr.sin_port);</span><br><span class="line"> <span class="comment">/* 接收客户端发送过来的数据 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line"> <span class="comment">// 接收缓冲区清零</span></span><br><span class="line"> <span class="built_in">memset</span>(recvbuf, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line"> <span class="comment">// 读数据</span></span><br><span class="line"> ret = recv(connfd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">0</span> &gt;= ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line"> close(connfd);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将读取到的数据以字符串形式打印出来</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;from client: %s\n&quot;</span>, recvbuf);</span><br><span class="line"> <span class="comment">// 如果读取到&quot;exit&quot;则关闭套接字退出程序</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strncmp</span>(<span class="string">&quot;exit&quot;</span>, recvbuf, <span class="number">4</span>)) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;server exit...\n&quot;</span>);</span><br><span class="line"> close(connfd);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 关闭套接字 */</span></span><br><span class="line"> close(sockfd);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>客户端</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8888 <span class="comment">//服务器的端口号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;192.168.1.150&quot;</span> <span class="comment">//服务器的 IP 地址</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"> <span class="keyword">int</span> sockfd;</span><br><span class="line"> <span class="keyword">int</span> ret;</span><br><span class="line"> <span class="comment">/* 打开套接字，得到套接字描述符 */</span></span><br><span class="line"> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; sockfd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 调用 connect 连接远端服务器 */</span></span><br><span class="line"> server_addr.sin_family = AF_INET;</span><br><span class="line"> server_addr.sin_port = htons(SERVER_PORT); <span class="comment">//端口号</span></span><br><span class="line"> inet_pton(AF_INET, SERVER_IP, &amp;server_addr.sin_addr);<span class="comment">//IP 地址</span></span><br><span class="line"> ret = connect(sockfd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"> close(sockfd);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;服务器连接成功...\n\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 向服务器发送数据 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line"> <span class="comment">// 清理缓冲区</span></span><br><span class="line"> <span class="built_in">memset</span>(buf, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"> <span class="comment">// 接收用户输入的字符串数据</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Please enter a string: &quot;</span>);</span><br><span class="line"> fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line"> <span class="comment">// 将用户输入的数据发送给服务器</span></span><br><span class="line"> ret = send(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">0</span> &gt; ret)&#123;</span><br><span class="line"> perror(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//输入了&quot;exit&quot;，退出循环</span></span><br><span class="line"> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strncmp</span>(buf, <span class="string">&quot;exit&quot;</span>, <span class="number">4</span>))</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> close(sockfd);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Linux文件锁"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/26/Linux%E6%96%87%E4%BB%B6%E9%94%81/"
    >Linux文件锁</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/26/Linux%E6%96%87%E4%BB%B6%E9%94%81/" class="article-date">
  <time datetime="2022-01-26T04:24:49.000Z" itemprop="datePublished">2022-01-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux文件锁"><a href="#Linux文件锁" class="headerlink" title="Linux文件锁"></a>Linux文件锁</h1><ul>
<li>对于有些应用程序，进程有时需要确保只有它自己能够对某一文件进行 I/O 操作，在这段时间内不允许 其它进程对该文件进行 I/O 操作。为了向进程提供这种功能，Linux 系统提供了文件锁机制。</li>
<li>譬如进程对文件进行 I/O 操作时，首先对文件进行上锁，将其锁住，然后再进行读写操作；只要进程没有对 文件进行解锁，那么其它的进程将无法对其进行操作；这样就可以保证，文件被锁住期间，只有它（该进程） 可以对其进行读写操作。</li>
</ul>
<h2 id="文件锁的分类"><a href="#文件锁的分类" class="headerlink" title="文件锁的分类"></a>文件锁的分类</h2><h3 id="建议性锁"><a href="#建议性锁" class="headerlink" title="建议性锁"></a>建议性锁</h3><ul>
<li>建议性锁本质上是一种协议，程序访问文件之前，先对文件上锁，上锁成功之后再访问文件，这是建议 性锁的一种用法；但是如果你的程序不管三七二十一，在没有对文件上锁的情况下直接访问文件，也是可以 访问的，并非无法访问文件；如果是这样，那么建议性锁就没有起到任何作用，如果要使得建议性锁起作用， 那么大家就要遵守协议，访问文件之前先对文件上锁。这就好比交通信号灯，规定红灯不能通行，绿灯才可 以通行，但如果你非要在红灯的时候通行，谁也拦不住你，那么后果将会导致发生交通事故；所以必须要大 家共同遵守交通规则，交通信号灯才能起到作用。</li>
</ul>
<h3 id="强制性锁"><a href="#强制性锁" class="headerlink" title="强制性锁"></a>强制性锁</h3><ul>
<li>强制性锁比较好理解，它是一种强制性的要求，如果进程对文件上了强制性锁，其它的进程在没有获取 到文件锁的情况下是无法对文件进行访问的。其本质原因在于，强制性锁会让内核检查每一个 I/O 操作（譬 如 read()、write()），验证调用进程是否是该文件锁的拥有者，如果不是将无法访问文件。当一个文件被上 锁进行写入操作的时候，内核将阻止其它进程对其进行读写操作。采取强制性锁对性能的影响很大，每次进 行读写操作都必须检查文件锁。</li>
</ul>
<h2 id="flock-函数加锁"><a href="#flock-函数加锁" class="headerlink" title="flock()函数加锁"></a>flock()函数加锁</h2><ul>
<li>先来学习系统调用 flock()，使用该函数可以对文件加锁或者解锁，但是 flock()函数只能产生建议性锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> operation)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fd：参数 fd 为文件描述符，指定需要加锁的文件。</p>
</li>
<li><p>operation：参数 operation 指定了操作方式，可以设置为以下值的其中一个：</p>
<ul>
<li>LOCK_SH：在 fd 引用的文件上放置一把共享锁。所谓共享，指的便是多个进程可以拥有对同一 个文件的共享锁，该共享锁可被多个进程同时拥有。</li>
<li>LOCK_EX：在 fd 引用的文件上放置一把排它锁（或叫互斥锁）。所谓互斥，指的便是互斥锁只 能同时被一个进程所拥有。</li>
<li>LOCK_UN：解除文件锁定状态，解锁、释放锁。</li>
<li>LOCK_NB：表示以<strong>非阻塞方式获取锁</strong>。默认情况下，调用 flock()无法获取到文件锁时会阻塞、直 到其它进程释放锁为止，如果不想让程序被阻塞，可以指定 LOCK_NB 标志，如果无法获取到锁 应立刻返回（错误返回，并将 errno 设置为 EWOULDBLOCK），通常与 LOCK_SH 或 LOCK_EX 一起使用，通过位或运算符组合在一起。</li>
</ul>
</li>
<li><p>注意，虽然一个程序对文件加锁之后，另一个程序企图加锁文件会失败，但是另一个程序同样可以打开并且编辑这个文件。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fd = <span class="number">-1</span>; <span class="comment">//文件描述符</span></span><br><span class="line"><span class="comment">/* 信号处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SIGINT != sig)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 解锁 */</span></span><br><span class="line">    flock(fd, LOCK_UN);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程 1: 文件已解锁!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> != argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 以非阻塞方式对文件加锁(排它锁) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == flock(fd, LOCK_EX | LOCK_NB))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;进程 1: 文件加锁失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程 1: 文件加锁成功!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 为 SIGINT 信号注册处理函数 */</span></span><br><span class="line">    signal(SIGINT, sigint_handler);</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一个试图读写文件的程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> != argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 以非阻塞方式对文件加锁(排它锁) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == flock(fd, LOCK_EX | LOCK_NB))</span><br><span class="line">        perror(<span class="string">&quot;进程 2: 文件加锁失败&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程 2: 文件加锁成功!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 写文件 */</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; write(fd, buf, len))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程 2: 写入到文件的字符串&lt;%s&gt;\n&quot;</span>, buf);</span><br><span class="line">    <span class="comment">/* 将文件读写位置移动到文件头 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; lseek(fd, <span class="number">0x0</span>, SEEK_SET))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 读文件 */</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0x0</span>, <span class="keyword">sizeof</span>(buf)); <span class="comment">//清理 buf</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; read(fd, buf, len))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;进程 2: 从文件读取的字符串&lt;%s&gt;\n&quot;</span>, buf);</span><br><span class="line">    <span class="comment">/* 解锁、退出 */</span></span><br><span class="line">    flock(fd, LOCK_UN);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>使用 kill 命令向 testApp1 进程发送编号为 2 的信号，也就是 SIGIO 信号，testApp1 接收到信号之后， 对 infile 文件进行解锁、然后退出；接着再次执行 testApp2 程序，从打印信息可知，这次能够成功对 infile 文件加锁了，读写也是没有问题的。</li>
<li>关于 flock()的几条规则<ul>
<li>同一进程对文件多次加锁<strong>不会导致死锁</strong>。当进程调用 flock()对文件加锁成功，再次调用 flock()对 文件（同一文件描述符）加锁，这样不会导致死锁，<strong>新加的锁会<u>替换</u>旧的锁</strong>。譬如调用 flock()对文 件加共享锁，再次调用 flock()对文件加排它锁，最终文件锁会由共享锁替换为排它锁。</li>
<li>文件关闭的时候，<strong>会自动解锁</strong>。进程调用 flock()对文件加锁，如果在未解锁之前将文件关闭，则会 导致文件锁自动解锁，也就是说，文件锁会在相应的文件描述符被关闭之后自动释放。同理，当一 个进程终止时，它所建立的锁将全部释放。</li>
<li>一个进程不可以对<strong>另一个进程持有</strong>的文件锁进行解锁。</li>
<li>由 fork()创建的子进程不会继承父进程所创建的锁。这意味着，若一个进程对文件加锁成功，然后 该进程调用 fork()创建了子进程，那么对父进程创建的锁而言，子进程被视为另一个进程，虽然<strong>子 进程从父进程继承了其文件描述符，但不能继承文件锁</strong>。这个约束是有道理的，因为锁的作用就是 阻止多个进程同时写同一个文件，<strong>如果子进程通过 fork()继承了父进程的锁，则</strong> <strong>父进程和子进程就 可以同时写同一个文件了</strong>。</li>
<li>除此之外，当一个<strong>文件描述符被复制时</strong>（譬如使用 dup()、dup2()或 fcntl()F_DUPFD 操作），这些通过 复制得到的文件描述符和源文件描述符都会<strong>引用同一个文件锁</strong>，使用<strong>这些文件描述符中的任何一个进行解 锁都可以</strong></li>
</ul>
</li>
</ul>
<h2 id="fcntl-函数加锁"><a href="#fcntl-函数加锁" class="headerlink" title="fcntl()函数加锁"></a>fcntl()函数加锁</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* struct flock *flockptr */</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>与锁相关的 cmd 为 F_SETLK、F_SETLKW、F_GETLK，第三个参数 flockptr 是一个 struct flock 结构体 指针。使用 fcntl()实现文件锁功能与 flock()有两个比较大的区别：</p>
<ul>
<li>flock()仅支持对整个文件进行加锁/解锁；而 fcntl()可以对文件的<strong>某个区域（某部分内容）进行加锁 /解锁，可以精确到某一个字节数据</strong>。</li>
<li>flock()<strong>仅支持建议性锁类型</strong>；而 fcntl()可支持建议性锁和强制性锁两种类型。</li>
</ul>
</li>
<li><p>结构体参数如下</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">short</span> l_type; <span class="comment">/* Type of lock: F_RDLCK,F_WRLCK, F_UNLCK */</span></span><br><span class="line"> <span class="keyword">short</span> l_whence; <span class="comment">/* How to interpret l_start: SEEK_SET, SEEK_CUR, SEEK_END */</span></span><br><span class="line"> <span class="keyword">off_t</span> l_start; <span class="comment">/* Starting offset for lock */</span></span><br><span class="line"> <span class="keyword">off_t</span> l_len; <span class="comment">/* Number of bytes to lock */</span></span><br><span class="line"> <span class="keyword">pid_t</span> l_pid; <span class="comment">/* PID of process blocking our lock(set by F_GETLK and F_OFD_GETLK) */</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>具体说明</p>
<ul>
<li>l_type：所希望的锁类型，可以设置为 F_RDLCK、F_WRLCK 和 F_UNLCK 三种类型之一，F_RDLCK 表示共享性质的读锁，F_WRLCK 表示独占性质的写锁，F_UNLCK 表示解锁一个区域。</li>
<li>l_whence 和 l_start：这两个变量用于指定要加锁或解锁区域的起始字节偏移量，与 2.7 小节所学 的 lseek()函数中的 offset 和 whence 参数相同，这里不再重述，如果忘记了，可以回到 2.7 小节再 看看。</li>
<li>l_len：需要加锁或解锁区域的字节长度。</li>
<li>l_pid：一个 pid，指向一个进程，表示该进程持有的锁能阻塞当前进程，当 cmd=F_GETLK 时有效。</li>
</ul>
</li>
<li><p>几条规则</p>
<ul>
<li>锁区域可以在当前文件末尾处开始或者越过末尾处开始，但是不能在文件起始位置之前开始。</li>
<li>若参数 l_len 设置为 0，表示将锁区域扩大到最大范围，也就是说从锁区域的起始位置开始，到文 件的最大偏移量处（也就是文件末尾）都处于锁区域范围内。而且是动态的，这意味着不管向该文 件追加写了多少数据，它们都处于锁区域范围，起始位置可以是文件的任意位置。</li>
<li>如果我们需要对整个文件加锁，可以将 l_whence 和 l_start 设置为指向文件的起始位置，并且指定 参数 l_len 等于 0。</li>
</ul>
</li>
<li><p>锁的类型</p>
</li>
<li><p>上面我们提到了两种类型的锁，分别为共享性读锁（F_RDLCK）和独占性写锁（F_WRLCK）。基本的 规则与 12.5 小节所介绍的线程同步读写锁很相似，<strong>任意多个进程在一个给定的字节上可以有一把共享的读 锁</strong>，但是<strong>在一个给定的字节上只能有一个进程有一把独占写锁</strong>，进一步而言，如果在一个给定的字节上已经 有一把或多把读锁，则不能在该字节上加写锁；如果在一个字节上<strong>已经有一把独占性写锁，则不能再对它加 任何锁</strong>（包括读锁和写锁）</p>
</li>
</ul>
<p><img src="/../imgs/image-20220126132857197.png" alt="image-20220126132857197"></p>
<ul>
<li><p>如果一个进程对文件的某个区域已经上了一把锁，后来该进程又试图在该区域再加一把锁，那么通常<strong>新 加的锁将替换旧的锁</strong>。譬如，若某一进程在文件的 100<del>200 字节区间有一把写锁，然后又试图在 100</del>200 字 节区间再加一把读锁，那么该请求将会成功执行，原来的写锁会替换为读锁。</p>
</li>
<li><p>当对文件的某一区域加读锁时，调用进程必须对该文件有读权限，譬如 open() 时 flags 参数指定了 O_RDONLY 或 O_RDWR；当对文件的某一区域加写锁时，调用进程必须对该文件有写 权限，譬如 open()时 flags 参数指定了 O_WRONLY 或 O_RDWR。</p>
</li>
<li><p>F_SETLK、F_SETLKW 和 F_GETLK</p>
<ul>
<li> F_GETLK：这种用法一般用于测试，测试调用进程对文件加一把由参数 flockptr 指向的 struct flock 对象所描述的锁是否会加锁成功。如果加锁不成功，意味着该文件的这部分区域已经存在一把锁， 并且由另一进程所持有，并且调用进程加的锁与现有锁之间存在排斥关系，现有锁会阻止调用进程 想要加的锁，并且现有锁的信息将会重写参数 flockptr 指向的对象信息。如果不存在这种情况，也 就是说 flockptr 指向的 struct flock 对象所描述的锁会加锁成功，则除了将 struct flock 对象的 l_type 修改为 F_UNLCK 之外，结构体中的其它信息保持不变。</li>
<li>F_SETLK：对文件添加由 flockptr 指向的 struct flock 对象所描述的锁。譬如试图对文件的某一区 域加读锁（l_type 等于 F_RDLCK）或写锁（l_type 等于 F_WRLCK），如果加锁失败，那么 fcntl() 将立即出错返回，此时将 errno 设置为 EACCES 或 EAGAIN。也可用于清除由 flockptr 指向的 struct  flock 对象所描述的锁（l_type 等于 F_UNLCK）。</li>
<li>F_SETLKW：此命令是 F_SETLK 的阻塞版本（命令名中的 W 表示等待 wait），如果所请求的读 锁或写锁因另一个进程当前已经对所请求区域的某部分进行了加锁，而导致请求失败，那么调用进 程将会进入阻塞状态。只有当请求的锁可用时，进程才会被唤醒。</li>
</ul>
</li>
<li><p>规则</p>
<ul>
<li>文件关闭的时候，会自动解锁。</li>
<li>一个进程不可以对另一个进程持有的文件锁进行解锁。</li>
<li>由 fork()创建的子进程不会继承父进程所创建的锁。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">lock</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="comment">/* 校验传参 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> != argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 对文件加锁 */</span></span><br><span class="line">    lock.l_type = F_WRLCK;    <span class="comment">//独占性写锁</span></span><br><span class="line">    lock.l_whence = SEEK_SET; <span class="comment">//文件头部</span></span><br><span class="line">    lock.l_start = <span class="number">0</span>;         <span class="comment">//偏移量为 0</span></span><br><span class="line">    lock.l_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fcntl(fd, F_SETLK, &amp;lock))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;加锁失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;对文件加锁成功!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 对文件进行写操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; write(fd, buf, <span class="built_in">strlen</span>(buf)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 解锁 */</span></span><br><span class="line">    lock.l_type = F_UNLCK; <span class="comment">//解锁</span></span><br><span class="line">    fcntl(fd, F_SETLK, &amp;lock);</span><br><span class="line">    <span class="comment">/* 退出 */</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>不同区域加锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">wr_lock</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">rd_lock</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* 校验传参 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> != argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开文件 */</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将文件大小截断为 1024 字节 */</span></span><br><span class="line">    ftruncate(fd, <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">/* 对 100~200 字节区间加写锁 */</span></span><br><span class="line">    wr_lock.l_type = F_WRLCK;</span><br><span class="line">    wr_lock.l_whence = SEEK_SET;</span><br><span class="line">    wr_lock.l_start = <span class="number">100</span>;</span><br><span class="line">    wr_lock.l_len = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fcntl(fd, F_SETLK, &amp;wr_lock))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;加写锁失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加写锁成功!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 对 400~500 字节区间加读锁 */</span></span><br><span class="line">    rd_lock.l_type = F_RDLCK;</span><br><span class="line">    rd_lock.l_whence = SEEK_SET;</span><br><span class="line">    rd_lock.l_start = <span class="number">400</span>;</span><br><span class="line">    rd_lock.l_len = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fcntl(fd, F_SETLK, &amp;rd_lock))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;加读锁失败&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;加读锁成功!\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 对文件进行 I/O 操作 */</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">/* 解锁 */</span></span><br><span class="line">    wr_lock.l_type = F_UNLCK; <span class="comment">//写锁解锁</span></span><br><span class="line">    fcntl(fd, F_SETLK, &amp;wr_lock);</span><br><span class="line">    rd_lock.l_type = F_UNLCK; <span class="comment">//读锁解锁</span></span><br><span class="line">    fcntl(fd, F_SETLK, &amp;rd_lock);</span><br><span class="line">    <span class="comment">/* 退出 */</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>多个进程对同一文件的相同区域都可以加读锁，说明读锁是共享性的。由于程序 是放置在后台运行的，测试完毕之后，可以使用 kill 命令将这些进程杀死，或者直接关闭当前终端，重新启 动新的终端。</li>
<li>第一次启动的进程对文件加写锁之后，后面再启动进程对同一文件的相同区域加写 锁发现都会失败，所以由此可知，写锁是独占性的。</li>
</ul>
<p>锁的规则同上面的<code>flock()</code>函数</p>
<p><strong>强制性锁</strong>会直接影响<code>read()</code>和<code>write()</code>函数的操作（失败会报错），在此处略</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Linux高级IO（二）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/25/Linux%E9%AB%98%E7%BA%A7IO%EF%BC%88%E4%BA%8C%EF%BC%89/"
    >Linux高级IO（二）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/25/Linux%E9%AB%98%E7%BA%A7IO%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2022-01-25T05:47:22.000Z" itemprop="datePublished">2022-01-25</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux高级IO（二）"><a href="#Linux高级IO（二）" class="headerlink" title="Linux高级IO（二）"></a>Linux高级IO（二）</h1><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><ul>
<li>在异步 I/O 中，当文件描述符上可以执行 I/O 操作时，进程可以请求内核为自己发送一个信号。之后进程 就可以执行任何其它的任务直到文件描述符可以执行 I/O 操作为止，此时内核会发送信号给进程。</li>
<li>要使用异步 I/O，程序需要按照如下步骤来执行：<ul>
<li>通过指定 O_NONBLOCK 标志使能非阻塞 I/O。</li>
<li>通过指定 O_ASYNC 标志使能异步 I/O。</li>
<li>设置异步 I/O 事件的接收进程。也就是当文件描述符上可执行 I/O 操作时会发送信号通知该进程， 通常将调用进程设置为异步 I/O 事件的接收进程。</li>
<li>为内核发送的通知信号注册一个信号处理函数。默认情况下，异步 I/O 的通知信号是 SIGIO，所以 内核会给进程发送信号 SIGIO。在 8.2 小节中简单地提到过该信号。</li>
<li>以上步骤完成之后，进程就可以执行其它任务了，当 I/O 操作就绪时，内核会向进程发送一个 SIGIO 信号，当进程接收到信号时，会执行预先注册好的信号处理函数，我们就可以在信号处理函数中进 行 I/O 操作。</li>
</ul>
</li>
<li><strong>O_ASYNC 标志</strong><ul>
<li>O_ASYNC 标志可用于使能文件描述符的异步 I/O 事件，当文件描述符可执行 I/O 操作时，内核会向异 步 I/O 事件的接收进程发送 SIGIO 信号（默认情况下）。</li>
<li>在调用 open()时<strong>无法通过</strong>指定 O_ASYNC 标志来使能异步 I/O，但可以<strong>使用 fcntl()函数 添加 O_ASYNC 标志使能异步 I/O</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line">flag = fcntl(<span class="number">0</span>, F_GETFL); <span class="comment">//先获取原来的 flag</span></span><br><span class="line">flag |= O_ASYNC; <span class="comment">//将 O_ASYNC 标志添加到 flag</span></span><br><span class="line">fcntl(fd, F_SETFL, flag); <span class="comment">//重新设置 flag</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>设置异步 I/O 事件的接收进程</strong></p>
<ul>
<li>为文件描述符设置异步 I/O 事件的接收进程，也就是设置异步 I/O 的所有者。同样也是通过 fcntl()函数 进行设置，操作命令 cmd 设置为 F_SETOWN，第三个参数传入接收进程的进程 ID（PID），通常将调用进 程的 PID 传入</li>
<li><code>fcntl(fd, F_SETOWN, getpid());</code></li>
</ul>
</li>
<li><p><strong>注册 SIGIO 信号的处理函数</strong></p>
<ul>
<li>通过 signal()或 sigaction()函数为 SIGIO 信号注册一个信号处理函数，当进程接收到内核发送过来的 SIGIO 信号时，会执行该处理函数，所以我们应该在处理函数当中执行相应的 I/O 操作。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOUSE <span class="meta-string">&quot;/dev/input/event3&quot;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fd;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sigio_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> loops = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (SIGIO != sig)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;鼠标: 成功读取&lt;%d&gt;个字节数据\n&quot;</span>, ret);</span><br><span class="line">    loops--;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt;= loops)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">/* 打开鼠标设备文件&lt;使能非阻塞 I/O&gt; */</span></span><br><span class="line">    fd = open(MOUSE, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 使能异步 I/O */</span></span><br><span class="line">    flag = fcntl(fd, F_GETFL);</span><br><span class="line">    flag |= O_ASYNC;</span><br><span class="line">    fcntl(fd, F_SETFL, flag);</span><br><span class="line">    <span class="comment">/* 设置异步 I/O 的所有者 */</span></span><br><span class="line">    fcntl(fd, F_SETOWN, getpid());</span><br><span class="line">    <span class="comment">/* 为 SIGIO 信号注册信号处理函数 */</span></span><br><span class="line">    signal(SIGIO, sigio_handler);</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="异步IO的优化"><a href="#异步IO的优化" class="headerlink" title="异步IO的优化"></a>异步IO的优化</h2><ul>
<li><p>在一个需要同时检查大量文件描述符（譬如数千个）的 应用程序中，例如某种类型的网络服务端程序，与 select()和 poll()相比，异步 I/O 能够提供显著的性能优势。 之所以如此，原因在于：对于异步 I/O，内核可以“记住”要检查的文件描述符，且仅当这些文件描述符上 可执行 I/O 操作时，内核才会向应用程序发送信号。</p>
</li>
<li><p>问题</p>
<ul>
<li>默认的异步 I/O 通知信号 SIGIO 是非排队信号。SIGIO 信号是标准信号（非实时信号、不可靠信 号），所以它不支持信号排队机制，譬如当前正在执行 SIGIO 信号的处理函数，此时内核又发送 多次 SIGIO 信号给进程，这些信号将会被阻塞，只有当信号处理函数执行完毕之后才会传递给进 程，并且只能传递一次，而其它后续的信号都会丢失。</li>
<li>无法得知文件描述符发生了什么事件。在示例代码 13.3.1 的信号处理函数 sigio_handler()中，直接 调用了 read()函数读取鼠标，而并未判断文件描述符是否处于可读就绪态，事实上，示例代码 13.3.1 这种异步 I/O 方式并未告知应用程序文件描述符上发生了什么事件，是可读取还是可写入亦或者 发生异常等。</li>
</ul>
</li>
<li><p><strong>使用实时信号替换默认信号 SIGIO</strong></p>
</li>
<li><p>SIGIO 作为异步 I/O 通知的默认信号，是一个非实时信号，我们可以设置不使用默认信号，指定一个实 时信号作为异步 I/O 通知信号，如何指定呢？同样也是使用 fcntl()函数进行设置，调用函数时将操作命令 cmd 参数设置为 F_SETSIG，第三个参数 arg 指定一个实时信号编号即可，表示将该信号作为异步 I/O 通知 信号</p>
</li>
<li><p><code>fcntl(fd, F_SETSIG, SIGRTMIN);</code></p>
<ul>
<li>如果第三个参数 arg 设置为 0，则表示指定 SIGIO 信号作为异步 I/O 通知信号，也就是回到了默认状态。</li>
</ul>
</li>
<li><p><strong>使用 sigaction()函数注册信号处理函数</strong></p>
<ul>
<li><p>在应用程序当中需要为<strong>实时信号注册信号处理函数</strong>，使用 <strong>sigaction 函数进行注册</strong>，并为 sa_flags 参数指 定 SA_SIGINFO，表示使用 sa_sigaction 指向的函数作为信号处理函数，而不使用 sa_handler 指向的函数。</p>
</li>
<li><p><code>sigaction</code>函数的原型</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数参数中包括一个 siginfo_t 指针，指向 siginfo_t 类型对象，当触发信号时该对象由内核构建。siginfo_t 结构体中提供了很多信息，我们可以在信号处理函数中使用这些信息，具体定义请参考示例代码 8.4.3，就 对于异步 I/O 事件而言，传递给信号处理函数的 siginfo_t 结构体中与之相关的字段如下</p>
<ul>
<li>si_signo：引发处理函数被调用的信号。这个值与信号处理函数的第一个参数一致。</li>
<li>si_fd：表示发生异步 I/O 事件的文件描述符；</li>
<li>si_code：表示文件描述符 si_fd 发生了什么事件，读就绪态、写就绪态或者是异常事件等。该字段 中可能出现的值以及它们对应的描述信息参见表 13.4.1。</li>
<li>si_band：是一个位掩码，其中包含的值与系统调用 poll()中返回的 revents 字段中的值相同。如表 13.4.1 所示，si_code 中可能出现的值与 si_band 中的位掩码有着一一对应关系。<ul>
<li><img src="/../imgs/image-20220125210615175.png" alt="image-20220125210615175"></li>
</ul>
</li>
</ul>
</li>
<li><p>可以在信号处理函数中通过对比 siginfo_t 结构体的 si_code 变量来<strong>检查文件描述符发 生了什么事件</strong>，以采取<strong>相应的 I/O</strong> 操作。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE <span class="comment">//在源文件开头定义_GNU_SOURCE 宏</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOUSE <span class="meta-string">&quot;/dev/input/mouse0&quot;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fd;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">io_handler</span><span class="params">(<span class="keyword">int</span> sig,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">siginfo_t</span> *info,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">void</span> *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> loops = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (SIGRTMIN != sig)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 判断鼠标是否可读 */</span></span><br><span class="line">    <span class="keyword">if</span> (POLL_IN == info-&gt;si_code)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; ret)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;鼠标: 成功读取&lt;%d&gt;个字节数据\n&quot;</span>, ret);</span><br><span class="line">        loops--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt;= loops)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="comment">/* 打开鼠标设备文件&lt;使能非阻塞 I/O&gt; */</span></span><br><span class="line">    fd = open(MOUSE, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 使能异步 I/O */</span></span><br><span class="line">    flag = fcntl(fd, F_GETFL);</span><br><span class="line">    flag |= O_ASYNC;</span><br><span class="line">    fcntl(fd, F_SETFL, flag);</span><br><span class="line">    <span class="comment">/* 设置异步 I/O 的所有者 */</span></span><br><span class="line">    fcntl(fd, F_SETOWN, getpid());</span><br><span class="line">    <span class="comment">/* 指定实时信号 SIGRTMIN 作为异步 I/O 通知信号 */</span></span><br><span class="line">    fcntl(fd, F_SETSIG, SIGRTMIN);</span><br><span class="line">    <span class="comment">/* 为实时信号 SIGRTMIN 注册信号处理函数 */</span></span><br><span class="line">    act.sa_sigaction = io_handler;</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    sigaction(SIGRTMIN, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>经过了使能异步flag、设置所有者线程、指定实时信号的种类、对sigation的对应的成员指定内容，包括处理函数、flag等等。</li>
<li><img src="/../imgs/image-20220125212351275.png" alt="image-20220125212351275"></li>
</ul>
<h2 id="存储映射I-O"><a href="#存储映射I-O" class="headerlink" title="存储映射I/O"></a>存储映射I/O</h2><ul>
<li><p>存储映射 I/O（memory-mapped I/O）是一种基于内存区域的高级 I/O 操作，它能将一个文件映射到进程 地址空间中的一块内存区域中，当从<strong>这段内存中读数据时，就相当于读文件中的数据</strong>（对文件进行 read 操 作），将<strong>数据写入这段内存时，则相当于将数据直接写入文件中</strong>（对文件进行 write 操作）。这样就可以在 不使用基本 I/O 操作函数 read()和 write()的情况下执行 I/O 操作。</p>
</li>
<li><p>为了实现存储映射 I/O 这一功能，我们需要告诉内核将一个给定的文件映射到进程地址空间中的一块 内存区域中，这由系统调用 **mmap()**来实现。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>addr：参数 addr 用于指定映射到内存区域的起始地址。通常将其设置为 NULL，这表示由系统选择该 映射区的起始地址，这是最常见的设置方式；如果参数 addr 不为 NULL，则表示由自己指定映射区的起始 地址，此函数的返回值是该映射区的起始地址。</p>
</li>
<li><p>length：参数 length 指定映射长度，表示将文件中的多大部分映射到内存区域中，以字节为单位，譬如 length=1024 * 4，表示将文件的 4K 字节大小映射到内存区域中。</p>
</li>
<li><p>offset：文件映射的偏移量，通常将其设置为 0，表示从文件头部开始映射；所以参数 offset 和参数 length 就确定了文件的起始位置和长度，将文件的这部分映射到内存区域中</p>
<ul>
<li><img src="/../imgs/image-20220125213944291.png" alt="image-20220125213944291"></li>
</ul>
</li>
<li><p>fd：文件描述符，指定要映射到内存区域中的文件。</p>
</li>
<li><p>prot：参数 prot 指定了映射区的保护要求，可取值如下：</p>
<ul>
<li>PROT_EXEC：映射区可执行；</li>
<li>PROT_READ：映射区可读；</li>
<li>PROT_WRITE：映射区可写；</li>
<li>PROT_NONE：映射区不可访问。</li>
</ul>
</li>
<li><p>对指定映射区的保护要求不能超过文件 open()时的访问权限，譬 如，文件是以只读权限方式打开的，那么对映射区的不能指定为 PROT_WRITE。</p>
</li>
<li><p>flags：参数 flags 可影响映射区的多种属性，参数 flags 必须要指定以下两种标志之一：</p>
<ul>
<li><p><img src="/../imgs/image-20220125213454172.png" alt="image-20220125213454172"></p>
</li>
<li><p>通常情况下，参数 flags 中只指定了 MAP_SHARED</p>
</li>
</ul>
</li>
<li><p>返回值：成功情况下，函数的返回值便是映射区的起始地址；发生错误时，返回(void *)-1，通常使用 MAP_FAILED 来表示，并且会设置 errno 来指示错误原因。</p>
</li>
<li><p>对于 mmap()函数，参数 <code>addr</code> 和 <code>offset</code> 在不为 NULL 和 0 的情况下，addr 和 offset 的值通常被要求是系 统<strong>页大小的整数倍</strong>，可通过 sysconf()函数获取页大小</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sysconf(_SC_PAGE_SIZE)</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">sysconf(_SC_PAGESIZE)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于参数 length 任需要注意，参数 length 的值不能大于文件大小，即文件被映射的部分不能超出文件。</p>
</li>
<li><p><strong>munmap()解除映射</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>munmap()系统调用解除指定地址范围内的映射，参数 addr 指定待解除映射地址范围的起始地址，它必 须是系统页大小的整数倍；参数 length 是一个非负整数，指定了待解除映射区域的大小（字节数），被解除 映射的区域对应的大小也必须是系统页大小的整数倍，即使参数 length 并不等于系统页大小的整数倍，与 mmap()函数相似。</p>
</li>
<li><p>需要注意的是，当进程终止时也会自动解除映射（如果程序中没有显式调用 munmap()），但<strong>调用 close() 关闭文件时并不会解除映射</strong>。</p>
</li>
<li><p>通常将参数 addr 设置为 mmap()函数的返回值，将参数 length 设置为 mmap()函数的参数 length，表示解除整个由 mmap()函数所创建的映射。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcfd, dstfd;</span><br><span class="line">    <span class="keyword">void</span> *srcaddr;</span><br><span class="line">    <span class="keyword">void</span> *dstaddr;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">3</span> != argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;srcfile&gt; &lt;dstfile&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开源文件 */</span></span><br><span class="line">    srcfd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == srcfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打开目标文件 */</span></span><br><span class="line">    dstfd = open(argv[<span class="number">2</span>], O_RDWR | O_CREAT | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == dstfd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取源文件的大小 */</span></span><br><span class="line">    fstat(srcfd, &amp;sbuf);</span><br><span class="line">    <span class="comment">/* 设置目标文件的大小 */</span></span><br><span class="line">    ftruncate(dstfd, sbuf.st_size);</span><br><span class="line">    <span class="comment">/* 将源文件映射到内存区域中 */</span></span><br><span class="line">    srcaddr = mmap(<span class="literal">NULL</span>, sbuf.st_size,</span><br><span class="line">                   PROT_READ, MAP_SHARED, srcfd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (MAP_FAILED == srcaddr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将目标文件映射到内存区域中 */</span></span><br><span class="line">    dstaddr = mmap(<span class="literal">NULL</span>, sbuf.st_size,</span><br><span class="line">                   PROT_WRITE, MAP_SHARED, dstfd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (MAP_FAILED == dstaddr)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> out3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 将源文件中的内容复制到目标文件中 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(dstaddr, srcaddr, sbuf.st_size);</span><br><span class="line">    <span class="comment">/* 程序退出前清理工作 */</span></span><br><span class="line">out4:</span><br><span class="line">    <span class="comment">/* 解除目标文件映射 */</span></span><br><span class="line">    munmap(dstaddr, sbuf.st_size);</span><br><span class="line">out3:</span><br><span class="line">    <span class="comment">/* 解除源文件映射 */</span></span><br><span class="line">    munmap(srcaddr, sbuf.st_size);</span><br><span class="line">out2:</span><br><span class="line">    <span class="comment">/* 关闭目标文件 */</span></span><br><span class="line">    close(dstfd);</span><br><span class="line">out1:</span><br><span class="line">    <span class="comment">/* 关闭源文件并退出 */</span></span><br><span class="line">    close(srcfd);</span><br><span class="line">    <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当执行程序的时候，将源文件和目标文件传递给应用程序，该程序首先会将源文件和目标文件打开，源 文件以只读方式打开，而目标文件以可读、可写方式打开，如果目标文件不存在则创建它，并且将文件的大 小截断为 0。</p>
</li>
<li><p>然后使用 fstat()函数获取源文件的大小，接着调用 ftruncate()函数设置目标文件的大小与源文件大小保 持一致。</p>
</li>
<li><p>然后对源文件和目标文件分别调用 mmap()，将文件映射到内存当中；对于源文件，调用 mmap()时将参 数 prot 指定为 PROT_READ，表示对它的映射区会进行读取操作；对于目标文件，调用 mmap()时将参数 port 指定为 PROT_WRITE，表示对它的映射区会进行写入操作。最后调用 memcpy()将源文件映射区中的内容复 制到目标文件映射区中，完成文件的复制操作。</p>
</li>
<li><p>使用系统调用 mprotect()可以更改一个现有映射区的保护要求</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数 prot 的取值与 mmap()函数的 prot 参数的一样，mprotect()函数会将指定地址范围的保护要求更改 为参数 prot 所指定的类型，参数 addr 指定该地址范围的起始地址，addr 的值必须是系统页大小的整数倍； 参数 len 指定该地址范围的大小。</li>
<li>写入到文件映射区中的数据也<strong>不会立马刷新至磁盘设备中</strong>，而是会在我们 将数据写入到映射区之后的某个时刻将映射区中的数据写入磁盘中。所以会导致映射区中的内容与磁盘文 件中的内容<strong>不同步</strong>。我们可以调用 msync()函数将映射区中的数据<strong>刷写、更新至磁盘文件中（同步操作）</strong>， 系统调用 msync()类似于 fsync()函数，不过 msync()作用于映射区。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数 addr 和 length 指定了需同步的内存区域的起始地址和大小。对于参数 addr 来说，同样也要求必须 是系统页大小的整数倍，也就是与系统页大小对齐。譬如，调用 msync()时，将 addr 设置为 mmap()函数的 返回值，将 length 设置为 mmap()函数的 length 参数，将对文件的整个映射区进行同步操作。</p>
</li>
<li><p>参数 flags 应指定为 MS_ASYNC 和 MS_SYNC 两个标志之一，除此之外，还可以根据需求选择是否指 定 MS_INVALIDATE 标志，作为一个可选标志。</p>
<ul>
<li>MS_ASYNC：以异步方式进行同步操作。调用 msync()函数之后，并不会等待数据完全写入磁盘之 后才返回。</li>
<li>MS_SYNC：以同步方式进行同步操作。调用 msync()函数之后，需等待数据全部写入磁盘之后才 返回。</li>
<li>MS_INVALIDATE：是一个可选标志，请求使同一文件的其它映射无效（以便可以用刚写入的新 值更新它们）。</li>
</ul>
</li>
<li><p>munmap()函数<strong>并不影响被映射的文件</strong>，也就是说，当调用 munmap()解除映射时<strong>并不会将映射区中的内 容写到磁盘文件中</strong>。如果 mmap()指定了 MAP_SHARED 标志，对于文件的更新，会在我们将数据写入到映 射区之后的某个时刻将映射区中的数据更新到磁盘文件中，由内核根据虚拟存储算法自动进行。</p>
</li>
<li><p>如果 mmap()指定了 MAP_PRIVATE 标志，在解除映射之后，进程对映射区的修改将会丢弃！</p>
</li>
</ul>
<h2 id="普通IO函数和存储映射IO的对比"><a href="#普通IO函数和存储映射IO的对比" class="headerlink" title="普通IO函数和存储映射IO的对比"></a>普通IO函数和存储映射IO的对比</h2><ul>
<li><p>普通IO</p>
</li>
<li><p><img src="/../imgs/image-20220126122116008.png" alt="image-20220126122116008"></p>
</li>
<li><p>存储映射IO</p>
</li>
<li><p><img src="/../imgs/image-20220126122127642.png" alt="image-20220126122127642"></p>
</li>
<li><p>首先非常直观的一点就是，使用存储映射 I/O 减少了数据的复制操作，所以在效率上会比普通 I/O 要 高，其次上面也讲了，普通 I/O 中间涉及到了很多的函数调用过程，这些都会导致普通 I/O 在效率上会比存 储映射 I/O 要低。</p>
</li>
<li><p>应用层与内核 层是不能直接进行交互的，必须要通过操作系统提供的系统调用或库函数来与内核进行数据交互，包括操 作硬件。通过存储映射 I/O 将文件直接映射到应用程序地址空间中的一块内存区域中，也就是映射区；直接 将磁盘文件直接与映射区关联起来，不用调用 read()、write()系统调用，直接对映射区进行读写操作即可操 作磁盘上的文件，而磁盘文件中的数据也可反应到映射区中</p>
</li>
<li><p>映射区就是应用层 与内核层之间的共享内存。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/11/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2023
        <i class="ri-heart-fill heart_icon"></i> FrankZhang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.png" alt="Frank’s blogs"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>