<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/rPi.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/rPi.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/rPi.png">
  <link rel="mask-icon" href="/images/rPi.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"frankzjz219.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Frank&#39;s blogs">
<meta property="og:url" content="https://frankzjz219.github.io/page/10/index.html">
<meta property="og:site_name" content="Frank&#39;s blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="FrankZhang">
<meta property="article:tag" content="C, C++, Leetcode, Linux, 嵌入式, Ununtu, 驱动">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://frankzjz219.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Frank's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Frank's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">永远好奇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/frankzjz219" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/26/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/26/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/" class="post-title-link" itemprop="url">一致性哈希</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-26 19:06:11" itemprop="dateCreated datePublished" datetime="2022-08-26T19:06:11+08:00">2022-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>760</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><ul>
<li><p>哈希函数的输入数据一般是<strong>巨量</strong>的，输出数据的的范围往往是<strong>有限</strong>的</p>
</li>
<li><p>哈希函数的输出存在<strong>均匀性</strong>，也就是无论输入是什么，输入是否接近，输出均匀分布在整个输出域之中。</p>
<h2 id="哈希表处理冲突位置（映射）的方法"><a href="#哈希表处理冲突位置（映射）的方法" class="headerlink" title="哈希表处理冲突位置（映射）的方法"></a>哈希表处理冲突位置（映射）的方法</h2></li>
<li><p>链接法：</p>
<ul>
<li>对于经过哈希函数得到<strong>同一个index</strong>的数据，利用链表（或者类似的形式）将其串联起来，寻找的时候先进行哈希得到index，然后再该index对应的位置逐个遍历链表得到要找的对象</li>
</ul>
</li>
<li><p><em><strong>其他方法</strong></em>参考链接 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26567507/article/details/80167351">参考</a></p>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2></li>
<li><p>用在给服务器分配数据问题减少迁移数据的工作量</p>
</li>
<li><p>一般情况下将输入数据的<code>key</code>值进行哈希，哈希得到的结果对服务器的数量取模，按照取得的结果分配到不同的服务器上，但是此时假如增加或者减少了服务器，就会因为取模的数字变化导致整个系统的哈希取模的数字都需要重新计算和分配，进而整体前迁移，工作量很大</p>
</li>
<li><p>引入一致性哈希得目的是减少上文描述得<em>前移工作量</em></p>
</li>
<li><p><img src="/imgs/a906dd8694b2b5033a83f841abd7919f93a7e4dfb74e15f6a7af6663c9ba82d3.png" alt="图 1">  </p>
</li>
<li><p>将三个机器的特征名称进行哈希，哈希过后将三个机器放在一个由哈希结果范围组成的环上（最大值和最小值头尾相接）。此时得到一个数据，同样将数据进行哈希，哈希得到的结果在环上找距离最近（此处的算法可以更换）的服务器存储该数据，假如数据的哈希值比所有服务器的哈希值都大的话就找哈希值最小的服务器，因为大小首尾相接。</p>
<h3 id="增加机器"><a href="#增加机器" class="headerlink" title="增加机器"></a>增加机器</h3></li>
<li><p><img src="/imgs/c482331ba4e5bc111d2b96bf43bf9e04837530b69657f089fed48fda2b8626e3.png" alt="图 2">  </p>
</li>
<li><p>假如此时需要增加M4，那么只需要将M3和M4之间的数据迁移到M4即可，不需要将所有数据进行重新计算迁移。</p>
</li>
<li><p>潜在问题：</p>
<ul>
<li>一开始的时候因为机器的地址是哈希得到的，未必均衡</li>
<li>增加机器之后可能导致局部机器比较密集，同样负载不均衡</li>
</ul>
</li>
<li><p>解决上述问题的方法：<strong>虚拟节点技术</strong></p>
<ul>
<li><p><img src="/imgs/8e91c4642b1ac4809f2c2adda961253bb18c6d7baaf8e888115f4cc5a4fde64c.png" alt="图 3">  </p>
</li>
<li><p>给每个服务器分配多个用于哈希的序列，每个服务器在环上具有<strong>多个</strong>对应的序列哈希得到的节点位置，<strong>相对均匀</strong>，同时也比较方便虚拟节点之间的数据迁移</p>
</li>
<li><p>不同的机器可以根据机器性能和状态的不同分配<strong>不同数量</strong>的虚拟节点，实现对于负载比例的不同分配。</p>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/24/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/24/%E5%9B%BE%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">图相关算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-24 00:20:38" itemprop="dateCreated datePublished" datetime="2022-08-24T00:20:38+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-16 18:05:19" itemprop="dateModified" datetime="2024-05-16T18:05:19+08:00">2024-05-16</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图对象的定义"><a href="#图对象的定义" class="headerlink" title="图对象的定义"></a>图对象的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">	<span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="边对象的定义"><a href="#边对象的定义" class="headerlink" title="边对象的定义"></a>边对象的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">	<span class="keyword">public</span> Node from;</span><br><span class="line">	<span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> weight, Node from, Node to)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">		<span class="keyword">this</span>.from = from;</span><br><span class="line">		<span class="keyword">this</span>.to = to;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="节点对象的定义"><a href="#节点对象的定义" class="headerlink" title="节点对象的定义"></a>节点对象的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点结构的描述</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> in;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> out;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">	<span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">		in = <span class="number">0</span>;</span><br><span class="line">		out = <span class="number">0</span>;</span><br><span class="line">		nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code01_BFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从node出发，进行宽度优先遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node start)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (start == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		queue.add(start);</span><br><span class="line">		set.add(start);</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">			Node cur = queue.poll();</span><br><span class="line">			System.out.println(cur.value);</span><br><span class="line">			<span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">					set.add(next);</span><br><span class="line">					queue.add(next);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>主要是在添加一个节点的所有相邻节点到队列里的时候使用了一个set结构判断这个节点是否被添加过，防止无限循环的产生<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code02_DFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		stack.add(node);</span><br><span class="line">		set.add(node);</span><br><span class="line">		System.out.println(node.value);</span><br><span class="line">		<span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">			Node cur = stack.pop();</span><br><span class="line">			<span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">					stack.push(cur);</span><br><span class="line">					stack.push(next);</span><br><span class="line">					set.add(next);</span><br><span class="line">					System.out.println(next.value);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用一个栈的数据结构，每从栈中弹出一个节点的时候，遍历该节点的所有邻接点，如果不在已经遍历过的节点的set内，那么先将<strong>节点自身</strong>进栈，然后再将<strong>该邻接节点</strong>进栈<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2></li>
<li>对于一个带权连通无向图G=(V,E)，生成树不同，每棵树的权（<strong>树中所有边上的权值和</strong>）也不同，设R为G的所有生成树的集合，若T为R中权值和最小的生成树，则T称为G的最小生成树（Minimum-Spanning-Tree，MST）<h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2></li>
<li>并查集：具有检查数据结构中的一些节点是否在同一个集合中、以及将不同的集合合并为一个集合的功能的数据结构<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//undirected graph only</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code04_Kruskal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Union-Find Set</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">		<span class="comment">// key 某一个节点， value key节点往上的节点</span></span><br><span class="line">		<span class="keyword">private</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">		<span class="comment">// key 某一个集合的代表节点, value key所在集合的节点个数</span></span><br><span class="line">		<span class="keyword">private</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">			sizeMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(Collection&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">			fatherMap.clear();</span><br><span class="line">			sizeMap.clear();</span><br><span class="line">			<span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">				fatherMap.put(node, node);</span><br><span class="line">				sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> Node <span class="title">findFather</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">			Stack&lt;Node&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">			<span class="keyword">while</span>(n != fatherMap.get(n)) &#123;</span><br><span class="line">				path.add(n);</span><br><span class="line">				n = fatherMap.get(n);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(!path.isEmpty()) &#123;</span><br><span class="line">				fatherMap.put(path.pop(), n);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> findFather(a) == findFather(b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			Node aDai = findFather(a);</span><br><span class="line">			Node bDai = findFather(b);</span><br><span class="line">			<span class="keyword">if</span> (aDai != bDai) &#123;</span><br><span class="line">				<span class="keyword">int</span> aSetSize = sizeMap.get(aDai);</span><br><span class="line">				<span class="keyword">int</span> bSetSize = sizeMap.get(bDai);</span><br><span class="line">				<span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">					fatherMap.put(aDai, bDai);</span><br><span class="line">					sizeMap.put(bDai, aSetSize + bSetSize);</span><br><span class="line">					sizeMap.remove(aDai);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					fatherMap.put(bDai, aDai);</span><br><span class="line">					sizeMap.put(aDai, aSetSize + bSetSize);</span><br><span class="line">					sizeMap.remove(bDai);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">kruskalMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">		UnionFind unionFind = <span class="keyword">new</span> UnionFind();</span><br><span class="line">		unionFind.makeSets(graph.nodes.values());</span><br><span class="line">		<span class="comment">// 从小的边到大的边，依次弹出，小根堆！</span></span><br><span class="line">		PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">		<span class="keyword">for</span> (Edge edge : graph.edges) &#123; <span class="comment">// M 条边</span></span><br><span class="line">			priorityQueue.add(edge);  <span class="comment">// O(logM)</span></span><br><span class="line">		&#125;</span><br><span class="line">		Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123; <span class="comment">// M 条边</span></span><br><span class="line">			Edge edge = priorityQueue.poll(); <span class="comment">// O(logM)</span></span><br><span class="line">			<span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="comment">// O(1)</span></span><br><span class="line">				result.add(edge);</span><br><span class="line">				unionFind.union(edge.from, edge.to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>findfFather函数是当一个节点具有多级的父亲的时候找到最高级别的父亲，并且修改一路上所有节点的父亲为最高级的父亲</li>
<li>算法的思路是先按照权值将图中所有的边都放入小根堆中，将图中所有节点放入并查集中独立存在，然后从堆中依次弹出边，假如边链接的两端不是同一个集合，那么将边放入结果中，同时在并查集中合并两个集合，直到无可合并为止。<h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// undirected graph only</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code05_Prim</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">primMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 解锁的边进入小根堆</span></span><br><span class="line">		PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 哪些点被解锁出来了</span></span><br><span class="line">		HashSet&lt;Node&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 依次挑选的的边在result里</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="comment">// 随便挑了一个点</span></span><br><span class="line">			<span class="comment">// node 是开始点</span></span><br><span class="line">			<span class="keyword">if</span> (!nodeSet.contains(node)) &#123;</span><br><span class="line">				nodeSet.add(node);</span><br><span class="line">				<span class="keyword">for</span> (Edge edge : node.edges) &#123; <span class="comment">// 由一个点，解锁所有相连的边</span></span><br><span class="line">					priorityQueue.add(edge);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">					Edge edge = priorityQueue.poll(); <span class="comment">// 弹出解锁的边中，最小的边</span></span><br><span class="line">					Node toNode = edge.to; <span class="comment">// 可能的一个新的点</span></span><br><span class="line">					<span class="keyword">if</span> (!nodeSet.contains(toNode)) &#123; <span class="comment">// 不含有的时候，就是新的点</span></span><br><span class="line">						nodeSet.add(toNode);</span><br><span class="line">						result.add(edge);</span><br><span class="line">						<span class="keyword">for</span> (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">							priorityQueue.add(nextEdge);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// break;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请保证graph是连通图</span></span><br><span class="line">	<span class="comment">// graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路</span></span><br><span class="line">	<span class="comment">// 返回值是最小连通图的路径之和</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = graph.length;</span><br><span class="line">		<span class="keyword">int</span>[] distances = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">		<span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">		visit[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			distances[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> minPath = Integer.MAX_VALUE;</span><br><span class="line">			<span class="keyword">int</span> minIndex = -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!visit[j] &amp;&amp; distances[j] &lt; minPath) &#123;</span><br><span class="line">					minPath = distances[j];</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (minIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> sum;</span><br><span class="line">			&#125;</span><br><span class="line">			visit[minIndex] = <span class="keyword">true</span>;</span><br><span class="line">			sum += minPath;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!visit[j] &amp;&amp; distances[j] &gt; graph[minIndex][j]) &#123;</span><br><span class="line">					distances[j] = graph[minIndex][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>prim算法主要用到一个存储边用的小根堆和一个记录哪些点被解锁的set</li>
<li>首先在graph中随便选择一个点，将这个点加入记录解锁的点的集合，然后将这个<strong>点的所有边</strong>放入优先级队列中，然后开始while循环，每次从优先级队列中弹出一个权值最小的边，假如这个边指向的节点<strong>不在</strong>前面的set中的话就将这个边指向的节点放入点set中，将这条边放入结果中，然后将<strong>该节点延伸出的所有边</strong>放入优先级队列中。<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2></li>
<li>该算法主要是找到指定起始点到图上剩余所有点的最近距离<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> class16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no negative weight</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code06_Dijkstra</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra1</span><span class="params">(Node from)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    distanceMap.put(from, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 打过对号的点</span></span><br><span class="line">    HashSet&lt;Node&gt; selectedNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    <span class="keyword">while</span> (minNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//  原始点  -&gt;  minNode(跳转点)   最小距离distance</span></span><br><span class="line">        <span class="keyword">int</span> distance = distanceMap.get(minNode);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : minNode.edges) &#123;</span><br><span class="line">            Node toNode = edge.to;</span><br><span class="line">            <span class="keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;</span><br><span class="line">                distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// toNode </span></span><br><span class="line">                distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selectedNodes.add(minNode);</span><br><span class="line">        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distanceMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMinDistanceAndUnselectedNode</span><span class="params">(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;</span><br><span class="line">    Node minNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">        Node node = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">            minNode = node;</span><br><span class="line">            minDistance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node node;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.distance = distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>算法主要依赖一个记录到对应节点最近距离的哈希表和一个记录某个节点是否已经被锁定的set</li>
<li>在初始时刻将起始点到起始点放入哈希表，并且将其距离设置为0。</li>
<li>然后的while循环每次都对找出的当前<strong>尚未被锁定</strong>而且在哈希表中到起始位置距离最小的点指向的所有尚未被锁定的节点的距离进行重算，假如被指向的节点之前的距离小于从该点出发到被指向的点的距离，将被指向点的距离更新为被选中的点出发的距离。（假如被指向的点<strong>不存在</strong>于哈希表中的话认为被指向的点的距离为<strong>正无穷</strong>，同样添加该点的距离条目进行更新）。然后将当前选中的点锁定，也就是假如被锁定的点的set中，然后找到当前未被锁定而且从总出发点开始距离最短的点，再次重复循环。</li>
</ul>
<h2 id="卡码网-29-安排超市（第一期模拟笔试）"><a href="#卡码网-29-安排超市（第一期模拟笔试）" class="headerlink" title="卡码网 29. 安排超市（第一期模拟笔试）"></a>卡码网 29. 安排超市（第一期模拟笔试）</h2><ul>
<li>此题先用bfs找到每个分立的区域，假如某个独立的区域里具有住户，则需要设置超市，超市尽可能的少</li>
<li>然后寻找到每个住户综合距离最小的超市，实际上可以从每个住户出发bfs遍历所在的区域，bfs每前进一层，意味着从住户出发到这个位置的距离+1，由此可以得出住户出发到这个区域每个位置的距离</li>
<li>对每个住户执行上述操作然后累加，就可以找出从每个位置出发到每个住户距离之和</li>
<li>找出每个区域中距离之和最小的位置即可作为超市的位置</li>
<li>注意bfs的时候需要<strong>一遇到某个点就在<code>visited</code>数组中标记这个位置</strong>，而<em>不是</em>从队列中弹出的时候再标记这个位置，否则会导致这个位置<strong>入队多次</strong>，使得算法超时<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set&lt;pair&lt;int, int&gt;&gt; houses;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;vector&lt;pair&lt;short, short&gt;&gt;&gt; regions;</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; visited;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">short</span>&gt;&gt; m;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dist;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">short</span>&gt;&gt; region;</span><br><span class="line"><span class="comment">// vector&lt;vector&lt;bool&gt;&gt; visitedDis;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs4Reg</span><span class="params">(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> n, <span class="keyword">int</span> reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x0, y0&#125;);</span><br><span class="line">    region[x0][y0] = reg;</span><br><span class="line">    visited[x0][y0] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> x = tmp.first;</span><br><span class="line">        <span class="keyword">int</span> y = tmp.second;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(m[x][y] == 1)houses.insert(&#123;x, y&#125;);</span></span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; !visited[x<span class="number">-1</span>][y] &amp;&amp; m[x<span class="number">-1</span>][y]&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            region[x<span class="number">-1</span>][y] = reg;</span><br><span class="line">            visited[x<span class="number">-1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x<span class="number">-1</span>, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;<span class="number">0</span> &amp;&amp; !visited[x][y<span class="number">-1</span>] &amp;&amp; m[x][y<span class="number">-1</span>]&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            region[x][y<span class="number">-1</span>] = reg;</span><br><span class="line">            visited[x][y<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x, y<span class="number">-1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;n<span class="number">-1</span> &amp;&amp; !visited[x+<span class="number">1</span>][y] &amp;&amp; m[x+<span class="number">1</span>][y]&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            region[x+<span class="number">1</span>][y] = reg;</span><br><span class="line">            visited[x+<span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x+<span class="number">1</span>, y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;n<span class="number">-1</span> &amp;&amp; !visited[x][y+<span class="number">1</span>] &amp;&amp; m[x][y+<span class="number">1</span>]&lt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            region[x][y+<span class="number">1</span>] = reg;</span><br><span class="line">            visited[x][y+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;x, y+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disFromHouse</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">    visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> curDis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;v; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> x = tmp.first;</span><br><span class="line">            <span class="keyword">int</span> y = tmp.second;</span><br><span class="line">            dist[x][y] += curDis;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; !visited[x<span class="number">-1</span>][y] &amp;&amp; m[x<span class="number">-1</span>][y]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x<span class="number">-1</span>, y&#125;);</span><br><span class="line">                visited[x<span class="number">-1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;<span class="number">0</span> &amp;&amp; !visited[x][y<span class="number">-1</span>] &amp;&amp; m[x][y<span class="number">-1</span>]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y<span class="number">-1</span>&#125;);</span><br><span class="line">                visited[x][y<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;n<span class="number">-1</span> &amp;&amp; !visited[x+<span class="number">1</span>][y] &amp;&amp; m[x+<span class="number">1</span>][y]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x+<span class="number">1</span>, y&#125;);</span><br><span class="line">                visited[x+<span class="number">1</span>][y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;n<span class="number">-1</span> &amp;&amp; !visited[x][y+<span class="number">1</span>] &amp;&amp; m[x][y+<span class="number">1</span>]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y+<span class="number">1</span>&#125;);</span><br><span class="line">                visited[x][y+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++curDis;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    visited = vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    m = vector&lt;vector&lt;<span class="keyword">short</span>&gt;&gt;(n, vector&lt;<span class="keyword">short</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    dist = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    region = vector&lt;vector&lt;<span class="keyword">short</span>&gt;&gt;(n, vector&lt;<span class="keyword">short</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// visitedDis = vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(n, false));</span></span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row:m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:row)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tmp;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (tmp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: i = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">/* code */</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>: i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: i = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> regCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i][j] &amp;&amp; m[i][j]&lt;<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">bfs4Reg</span>(i, j, n, regCnt++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sumOfDist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minDist = INT_MAX;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">hasHouse</span><span class="params">(regCnt, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                visited = vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">                <span class="built_in">disFromHouse</span>(i, j, n);</span><br><span class="line">                hasHouse[region[i][j]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">regMin</span><span class="params">(regCnt, INT_MAX)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][j]&gt;<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            regMin[region[i][j]] = <span class="built_in">min</span>(regMin[region[i][j]], dist[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> disSUm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> marketCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;regCnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hasHouse[i])</span><br><span class="line">        &#123;</span><br><span class="line">            disSUm+=regMin[i];</span><br><span class="line">            ++marketCnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;marketCnt&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt; disSUm &lt;&lt;endl;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;regions.size()&lt;&lt;&#x27; &#x27;&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="牛客美团2024秋招第一场第三题"><a href="#牛客美团2024秋招第一场第三题" class="headerlink" title="牛客美团2024秋招第一场第三题"></a>牛客美团2024秋招第一场第三题</h2><ul>
<li>小美拿到了一棵树，每个节点有一个权值。初始每个节点都是白色。<ul>
<li>小美有若干次操作，每次操作可以选择两个相邻的节点，如果它们都是白色且权值的乘积是完全平方数，小美就可以把这两个节点同时染红。</li>
<li>小美想知道，自己最多可以染红多少个节点？</li>
</ul>
</li>
<li>此题的关键是防止重复经过同一个节点，因此需要一个<code>used</code>数组，经过的时候设置为true，经过之后设置为false</li>
<li>此外就是回溯法寻找，注意一个节点有<code>标红当前节点</code>和<code>不标红当前节点</code>两种情况<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;* to;</span><br><span class="line"><span class="keyword">int</span>* arr;</span><br><span class="line"><span class="keyword">int</span>* dp;</span><br><span class="line"><span class="keyword">int</span>* dpf;</span><br><span class="line"><span class="keyword">bool</span>* red;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span>* used;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSq</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (x*x != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">traversal</span><span class="params">(<span class="keyword">int</span> beg, <span class="keyword">bool</span> able)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[beg])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(able &amp;&amp; dp[beg]&gt;=<span class="number">0</span>)<span class="keyword">return</span> dp[beg];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!able &amp;&amp; dpf[beg]&gt;=<span class="number">0</span>)<span class="keyword">return</span> dpf[beg];</span><br><span class="line">    used[beg] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxRet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : to[beg])</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=<span class="built_in">traversal</span>(i, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!able)</span><br><span class="line">    &#123;</span><br><span class="line">        dpf[beg] = sum;</span><br><span class="line">        used[beg] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    maxRet = sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : to[beg])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i] &amp;&amp; <span class="built_in">isSq</span>(arr[beg]*arr[i]) &amp;&amp; i != beg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// int iSum = 0;</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27;|&#x27;&lt;&lt;beg&lt;&lt;endl;</span></span><br><span class="line">            maxRet = <span class="built_in">max</span>(maxRet, sum+<span class="number">2</span>-<span class="built_in">traversal</span>(i, <span class="literal">true</span>)+<span class="built_in">traversal</span>(i, <span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[beg] = maxRet;</span><br><span class="line">    used[beg] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> maxRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;isSq(92*19)&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">    to = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;[n];</span><br><span class="line">    arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dpf = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    red = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    used = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="built_in">memset</span>(used, <span class="number">0</span> ,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>)*n);</span><br><span class="line">    <span class="built_in">memset</span>(red, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">bool</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="number">-1</span>;</span><br><span class="line">        dpf[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        to[u<span class="number">-1</span>].<span class="built_in">push_back</span>(v<span class="number">-1</span>);</span><br><span class="line">        to[v<span class="number">-1</span>].<span class="built_in">push_back</span>(u<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">traversal</span>(<span class="number">0</span>, <span class="literal">true</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64 位输出请用 printf(&quot;%lld&quot;)</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">排序算法总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-23 20:12:15" itemprop="dateCreated datePublished" datetime="2022-08-23T20:12:15+08:00">2022-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-27 15:48:27" itemprop="dateModified" datetime="2024-04-27T15:48:27+08:00">2024-04-27</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://github.com/algorithmzuo">zuochengyun参考链接</a></p>
<h2 id="时间复杂度的计算"><a href="#时间复杂度的计算" class="headerlink" title="时间复杂度的计算"></a>时间复杂度的计算</h2><ul>
<li><img src="/imgs/84e153d22a3de18ea0b798a365d4cc8db510526eedc7622eff3621eeb6a91838.png" alt="图 1">  <h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2></li>
<li>数组中相同的元素在排序前后的相对次序有没有变化？没有就是稳定的。</li>
<li>语言为java，但是因为与C++类似，所以没有专门更改</li>
<li>交换函数<ul>
<li>位运算的交换函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = a^b;</span><br><span class="line">b = a^b;</span><br><span class="line">c = a^b;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>普通交换函数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">	arr[j] = arr[i];</span><br><span class="line">	arr[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> N = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> minValueIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">			minValueIndex = arr[j] &lt; arr[minValueIndex] ? j : minValueIndex;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr, i, minValueIndex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度O(N^2)， 空间复杂度O(1)，<em>不</em>稳定</li>
<li>思路：大循环确定每次排序的第一个位置，每次确定一个数字，确定的方法是从还未确定的范围里选出一个最小的数字，将这个数字与排序的第一个位置原来的数字交换位置，然后确定该位置的数字，将排序的起始位置前移一个<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> N = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> end = N - <span class="number">1</span>; end &gt;= <span class="number">0</span>; end--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> second = <span class="number">1</span>; second &lt;= end; second++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[second - <span class="number">1</span>] &gt; arr[second]) &#123;</span><br><span class="line">				swap(arr, second - <span class="number">1</span>, second);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度O(N^2)，空间复杂度O(1)，稳定</li>
<li>首先从数组的第一个到最后一个元素执行一次冒泡，冒泡的具体行为是假如数组下表前一个位置的数字比下表位置的数字大的话，交换这两个数字，然后一次冒泡结束之后将冒泡行为的后边界前移一。<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> N = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">1</span>; end &lt; N; end++) &#123;</span><br><span class="line">		<span class="keyword">int</span> newNumIndex = end;</span><br><span class="line">		<span class="keyword">while</span> (newNumIndex - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[newNumIndex - <span class="number">1</span>] &gt; arr[newNumIndex]) &#123;</span><br><span class="line">			swap(arr, newNumIndex - <span class="number">1</span>, newNumIndex);</span><br><span class="line">			newNumIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> N = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">1</span>; end &lt; N; end++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> pre = end - <span class="number">1</span>; pre &gt;= <span class="number">0</span> &amp;&amp; arr[pre] &gt; arr[pre + <span class="number">1</span>]; pre--) &#123;</span><br><span class="line">			swap(arr, pre, pre + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>思路是从第二个元素开始，假如该元素比前一个元素小的话，就将这个元素向前移动，直到前一个元素不比这个元素小为止（类似于打扑克起牌的时候将大牌插入到前面）。然后将插入元素的起始位置向后移动一个。</li>
<li>时间复杂度O(N^2)，空间复杂度O(1)，稳定<h2 id="归并排序-2023-10-30更新"><a href="#归并排序-2023-10-30更新" class="headerlink" title="归并排序 2023-10-30更新"></a>归并排序 2023-10-30更新</h2></li>
<li>leetcode<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; ret = nums;</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret = <span class="built_in">merge</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(R-L&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(vec[L]);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;vec[L]&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; leftVec = <span class="built_in">merge</span>(vec, L, L+(R-L)/<span class="number">2</span>);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; rightVec = <span class="built_in">merge</span>(vec, L+(R-L)/<span class="number">2</span>+<span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">int</span> indL=<span class="number">0</span>, indR= <span class="number">0</span>, ind = <span class="number">0</span>; </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(leftVec.size()+rightVec.size())</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(indL&lt;leftVec.<span class="built_in">size</span>() &amp;&amp; indR&lt;rightVec.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res[ind++] = leftVec[indL]&lt;rightVec[indR]?leftVec[indL++]:rightVec[indR++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(indL&lt;leftVec.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res[ind++] = leftVec[indL++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(indR&lt;rightVec.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res[ind++] = rightVec[indR++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度O(N*log(N))空间复杂度O(N)，稳定</li>
<li>思路就是将数组分为左右两部分，然后对左边和右边分别递归执行，执行之后回溯到这一层的时候，左右两个数组已经是<strong>各自有序</strong>的了，然后将两个数组进行合并（merge），合并操作就是将两个数组的下表设置为各自最前，然后将两个下标位置对应的数字中较小的一个放入总的数组中，该数组的下标前进一位。假如执行到最后有一个数组的下标到达了最后，就将这个数组整个衔接在总的数组末尾（需要用到额外空间）。<h2 id="链表归并排序-2023-10-30"><a href="#链表归并排序-2023-10-30" class="headerlink" title="链表归并排序 2023-10-30"></a>链表归并排序 2023-10-30</h2></li>
<li>leetcode<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, ListNode*&gt; m;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        <span class="keyword">while</span>(tail-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span>(head, tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* h, ListNode* tail)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(h-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(h-&gt;next == tail)</span><br><span class="line">        &#123;</span><br><span class="line">            h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">merge</span>(h, tail);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = h, *fast = h;</span><br><span class="line">        <span class="keyword">while</span>(fast!=tail)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=tail)</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* h2 = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">split</span>(h, slow), <span class="built_in">split</span>(h2, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* h1, ListNode* h2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1 == <span class="literal">NULL</span> || h2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> h1?h1:h2;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* vHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* ret = vHead;</span><br><span class="line">        <span class="keyword">while</span>(h1!=<span class="literal">NULL</span>&amp;&amp;h2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h1-&gt;val&lt;h2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                vHead -&gt; next = h1;</span><br><span class="line">                h1 = h1-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                vHead -&gt; next = h2;</span><br><span class="line">                h2 = h2-&gt;next;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            vHead = vHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(h1!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vHead-&gt;next = h1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(h2!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vHead-&gt;next = h2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="链表归并排序的内存生命周期问题"><a href="#链表归并排序的内存生命周期问题" class="headerlink" title="链表归并排序的内存生命周期问题"></a>链表归并排序的内存生命周期问题</h3></li>
<li>链表排序的时候假如不食用一个外部的头节点的话，会可能遇到报错</li>
<li><img src="/imgs/f79ad1d7fe2b573e5a41667c002d880eb9cbca026de0e5cd6b5d84235a7dee81.png" alt="picture 0">  <ul>
<li>提示一个指针指向NULL，不可被操作了</li>
<li>在整个过程中最好手动创建一个节点的next指向头节点，使得系统指向链表的指针不丢失，防止空间被回收</li>
<li>比如如下多个链表合并的问题<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](ListNode*&amp; a, ListNode*&amp; b)&#123;<span class="keyword">return</span> a-&gt;val&gt;b-&gt;val;&#125;;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = lists.<span class="built_in">begin</span>(); it!=lists.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* cur = *it;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(cur);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;cur-&gt;val&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* head = pq.<span class="built_in">top</span>();</span><br><span class="line">        <span class="comment">// cout&lt;&lt;head-&gt;val;</span></span><br><span class="line">        ListNode* ret = head;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            head-&gt;next = pq.<span class="built_in">top</span>();</span><br><span class="line">            <span class="comment">// cout&lt;&lt;head-&gt;next-&gt;val;</span></span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        ListNode* tmp = ret;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;tmp-&gt;val&lt;&lt;endl;</span><br><span class="line">            tmp = tmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>但是实际上归并多个有序数组的时候只需要在一开始<strong>遍历每个数组的第一个元素</strong>，将其添加到优先级队列中，等到合并的时候从优先级队列中<strong>弹出某个元素的时候，再将其后继的数字添加到队列中即可</strong>，<strong>不需要</strong>在一开始就把所有的节点都加入优先级队列<h2 id="快速排序-2023-10-30更新"><a href="#快速排序-2023-10-30更新" class="headerlink" title="快速排序 2023-10-30更新"></a>快速排序 2023-10-30更新</h2></li>
<li>递归版本(leetcode)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; ret = nums;</span></span><br><span class="line">        <span class="built_in">sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(R-L&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> randInd = <span class="built_in">rand</span>()%(R-L)+L;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;vec[R]&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">swap</span>(vec, R, randInd);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans = <span class="built_in">split</span>(vec, L, R);</span><br><span class="line">        <span class="built_in">sort</span>(vec, L, ans[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">sort</span>(vec, ans[<span class="number">1</span>], R);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">split</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> less, more;</span><br><span class="line">        less = L<span class="number">-1</span>;</span><br><span class="line">        more = R;</span><br><span class="line">        <span class="comment">// int flag = R;</span></span><br><span class="line">        <span class="keyword">while</span>(L&lt;more)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[L] &lt; vec[R])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(vec, ++less, L++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vec[L] == vec[R])</span><br><span class="line">            &#123;</span><br><span class="line">                ++L;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(vec, --more, L);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(vec, more, R);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret = &#123;less, more+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;vec[a]&lt;&lt;&#x27; &#x27;&lt;&lt;vec[b]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> temp = vec[a];</span><br><span class="line">        vec[a] = vec[b];</span><br><span class="line">        vec[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度O(Nlog(N))，空间复杂度O(log(N))，</li>
<li>荷兰国旗问题：将整个数组分为三个部分，左边的部分比给定的flag小，中间的部分等于flag，右边的部分大于flag。（选择最右为分割标志）<ul>
<li>其中的less是小于区的右边界，more是大于区的左边界</li>
<li>index位置是等于区的右边一个位置，less右边一个到index-1的值（包括边界）与分割值相等</li>
<li>假如index位置的数字和分割标志相等，直接index++</li>
<li>假如index位置的数字比标志小，那么index位置的数字与小于区的左边界右边第一个数字交换，index和小于区的右边界各自++，相当于小于区推动等于区右移</li>
<li>假如index位置的数字比标志大，那么将index位置的数字与大于区左边界的第一个数字交换，index不动，大于区的左边界左移一个位置。</li>
<li>遍历结束之后，将数组最右边位置的数字与大于区左边界位置的数字进行交换（因为开始时候取的标志是最右的数字）</li>
</ul>
</li>
<li>递归的时候，先调用一个分割函数（就是前面描述的荷兰国旗），然后将开始到小于区右边界和大于区左边界到数组结束的位置分别递归调用分割即可。<h2 id="堆排序-2023-10-30更新"><a href="#堆排序-2023-10-30更新" class="headerlink" title="堆排序 2023-10-30更新"></a>堆排序 2023-10-30更新</h2></li>
<li>leetcode<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从后向前逐个元素向下运动，建造大根堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heapDown</span>(nums, i, nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums, <span class="number">0</span>, i);</span><br><span class="line">            <span class="built_in">heapDown</span>(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向下</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapDown</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big;</span><br><span class="line">        <span class="keyword">while</span>(index*<span class="number">2</span>+<span class="number">1</span>&lt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index*<span class="number">2</span>+<span class="number">2</span>&gt;=size)</span><br><span class="line">            &#123;</span><br><span class="line">                big = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                big = arr[index*<span class="number">2</span>+<span class="number">1</span>] &gt; arr[index*<span class="number">2</span>+<span class="number">2</span>]?index*<span class="number">2</span>+<span class="number">1</span>:index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;arr[big])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, index, big);</span><br><span class="line">                index = big;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapUp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(((index<span class="number">-1</span>)/<span class="number">2</span>)&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[(index<span class="number">-1</span>)/<span class="number">2</span>]&gt;arr[index])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(arr, (index<span class="number">-1</span>)/<span class="number">2</span>, index);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index = (index<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度O(Nlog(N))，空间复杂度O(1)，不稳定</li>
<li><code>heapInsert</code>是堆插入函数，将插入的数字向上看是否在需要的位置上</li>
<li><code>heapify</code>是将数组中某个位置的数字向下移动，直到需要的位置（向下交换的时候与两个孩子中较大的那个交换）</li>
<li>建堆的操作是从倒数第二个元素开始直到数组的第一个元素，执行向下调整函数，然后将整个数组的最后一个元素与第一个元素交换，执行向下调整函数，然后将数组的倒数第二个元素与第一个交换，执行向下调整，如此循环到数组的第二个元素与第一个元素交换并且调整结束。</li>
</ul>
<h2 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMaxHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMaxHeap</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="keyword">int</span>[limit];</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">        heapSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heapSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heapSize == limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heapSize == limit) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;heap is full&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        heap[heapSize] = value;</span><br><span class="line">        <span class="comment">// value heapSize</span></span><br><span class="line">        heapInsert(heap, heapSize++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户此时，让你返回最大值，并且在大根堆中，把最大值删掉</span></span><br><span class="line">    <span class="comment">// 剩下的数，依然保持大根堆组织</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = heap[<span class="number">0</span>];</span><br><span class="line">        swap(heap, <span class="number">0</span>, --heapSize);</span><br><span class="line">        heapify(heap, <span class="number">0</span>, heapSize);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新加进来的数，现在停在了index位置，请依次往上移动，</span></span><br><span class="line">    <span class="comment">// 移动到0位置，或者干不掉自己的父亲了，停！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// [index] [index-1]/2</span></span><br><span class="line">        <span class="comment">// index == 0</span></span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从index位置，往下看，不断的下沉</span></span><br><span class="line">    <span class="comment">// 停：较大的孩子都不再比index位置的数大；已经没孩子了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) &#123; <span class="comment">// 如果有左孩子，有没有右孩子，可能有可能没有！</span></span><br><span class="line">            <span class="comment">// 把较大孩子的下标，给largest</span></span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// index和较大孩子，要互换</span></span><br><span class="line">            swap(arr, largest, index);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>向堆插入数字的方法就是将<strong>堆的尺寸+1，然后从被插入数字开始上溯直到不比父亲大</strong></li>
<li>用户从堆顶弹出的方法是<strong>弹出之后将堆尺寸-1，然后将堆最后一个元素复制到以前堆顶的位置</strong>，然后执行heapify，也就是将该元素下沉直到不比儿子小为止</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/16/Cubic%E6%8F%92%E5%80%BC%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/16/Cubic%E6%8F%92%E5%80%BC%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">Cubic插值代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-16 14:49:50 / 修改时间：14:53:38" itemprop="dateCreated datePublished" datetime="2022-08-16T14:49:50+08:00">2022-08-16</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一维Cubic插值代码"><a href="#一维Cubic插值代码" class="headerlink" title="一维Cubic插值代码"></a>一维Cubic插值代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cubicCalc</span><span class="params">(<span class="keyword">double</span> xs[<span class="number">4</span>], <span class="keyword">double</span> ys[<span class="number">4</span>], <span class="keyword">double</span> xInput)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 旧方法</span></span><br><span class="line">    <span class="comment">// return p[1] + 0.5 * x*(p[2] - p[0] + x * (2.0*p[0] - 5.0*p[1] + 4.0*p[2] - p[3] + x * (3.0*(p[1] - p[2]) + p[3] - p[0])));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">double</span>* H,*A,*B,*C,*D,*Z,*F,*X,*Y;</span><br><span class="line">    <span class="keyword">double</span> dbOutY;</span><br><span class="line">    X = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];   </span><br><span class="line">    Y = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];   </span><br><span class="line"></span><br><span class="line">    A = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];   </span><br><span class="line">    B = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];   </span><br><span class="line">    C = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];   </span><br><span class="line">    D = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];   </span><br><span class="line">    H = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];   </span><br><span class="line">    <span class="built_in">memcpy</span>(X, xs, <span class="number">4</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(Y, ys, <span class="number">4</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> M = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> i,P,L;   </span><br><span class="line">    <span class="comment">// 生成Spline</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=N;i++)   </span><br><span class="line">    &#123;   </span><br><span class="line">        H[i<span class="number">-1</span>]=X[i]-X[i<span class="number">-1</span>];   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    L=N<span class="number">-1</span>;   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L;i++)   </span><br><span class="line">    &#123;   </span><br><span class="line">        A[i]=H[i<span class="number">-1</span>]/(H[i<span class="number">-1</span>]+H[i]);   </span><br><span class="line">        B[i]=<span class="number">3</span>*((<span class="number">1</span>-A[i])*(Y[i]-Y[i<span class="number">-1</span>])/H[i<span class="number">-1</span>]+A[i]*(Y[i+<span class="number">1</span>]-Y[i])/H[i]);   </span><br><span class="line">    &#125;   </span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">1</span>;   </span><br><span class="line">    A[N]=<span class="number">0</span>;   </span><br><span class="line">    B[<span class="number">0</span>]=<span class="number">3</span>*(Y[<span class="number">1</span>]-Y[<span class="number">0</span>])/H[<span class="number">0</span>];   </span><br><span class="line">    B[N]=<span class="number">3</span>*(Y[N]-Y[N<span class="number">-1</span>])/H[N<span class="number">-1</span>];   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N;i++)   </span><br><span class="line">    &#123;   </span><br><span class="line">        D[i]=<span class="number">2</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=N;i++)   </span><br><span class="line">    &#123;   </span><br><span class="line">        C[i]=<span class="number">1</span>-A[i];   </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    P=N;   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=P;i++)   </span><br><span class="line">    &#123;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (  <span class="built_in">fabs</span>(D[i]) &lt;= <span class="number">0.000001</span> )                                  </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">            <span class="comment">//    MessageBox(0,&quot;�޽�&quot;,&quot;��ʾ,MB_OK);   </span></span><br><span class="line">            <span class="comment">//break;   </span></span><br><span class="line">        &#125;   </span><br><span class="line">        A[i<span class="number">-1</span>]=A[i<span class="number">-1</span>]/D[i<span class="number">-1</span>];   </span><br><span class="line">        B[i<span class="number">-1</span>]=B[i<span class="number">-1</span>]/D[i<span class="number">-1</span>];   </span><br><span class="line">        D[i]=A[i<span class="number">-1</span>]*(-C[i])+D[i];   </span><br><span class="line">        B[i]=-C[i]*B[i<span class="number">-1</span>]+B[i];   </span><br><span class="line">    &#125;   </span><br><span class="line">    B[P]=B[P]/D[P];   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=P;i++)   </span><br><span class="line">    &#123;   </span><br><span class="line">        B[P-i]=B[P-i]-A[P-i]*B[P-i+<span class="number">1</span>];   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 生成Spline结束</span></span><br><span class="line">    <span class="comment">// 获得Y坐标</span></span><br><span class="line">    <span class="keyword">double</span> E,E1,K,K1,H1;   </span><br><span class="line">    <span class="keyword">int</span> j ;    </span><br><span class="line">    <span class="keyword">if</span>(xInput&lt;X[<span class="number">0</span>])   </span><br><span class="line">    &#123;   </span><br><span class="line">        j = <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xInput &gt; X[N])   </span><br><span class="line">    &#123;   </span><br><span class="line">        j = N<span class="number">-1</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=N;j++)   </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(xInput&lt;=X[j])   </span><br><span class="line">            &#123;   </span><br><span class="line">                j=j<span class="number">-1</span>;   </span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////////   </span></span><br><span class="line">    E=X[j+<span class="number">1</span>]-xInput;   </span><br><span class="line">    E1=E*E;   </span><br><span class="line">    K=xInput-X[j];   </span><br><span class="line">    K1=K*K;   </span><br><span class="line">    H1=H[j]*H[j];   </span><br><span class="line"></span><br><span class="line">    dbOutY=(<span class="number">3</span>*E1<span class="number">-2</span>*E1*E/H[j])*Y[j]+(<span class="number">3</span>*K1<span class="number">-2</span>*K1*K/H[j])*Y[j+<span class="number">1</span>];   </span><br><span class="line">    dbOutY=dbOutY+(H[j]*E1-E1*E)*B[j]-(H[j]*K1-K1*K)*B[j+<span class="number">1</span>];   </span><br><span class="line">    dbOutY=dbOutY/H1;   </span><br><span class="line">    <span class="keyword">return</span> dbOutY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维插值"><a href="#二维插值" class="headerlink" title="二维插值"></a>二维插值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bicubicInterpolate</span><span class="params">(<span class="keyword">double</span>* xs, <span class="keyword">double</span>* ys, <span class="keyword">double</span> p[<span class="number">4</span>][<span class="number">4</span>], <span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> arr[<span class="number">4</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="built_in">cubicCalc</span>(xs, p[<span class="number">0</span>], y);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="built_in">cubicCalc</span>(xs, p[<span class="number">1</span>], y);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="built_in">cubicCalc</span>(xs, p[<span class="number">2</span>], y);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="built_in">cubicCalc</span>(xs, p[<span class="number">3</span>], y);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cubicCalc</span>(ys, arr, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码中的<code>xs</code>是描述二维矩阵中取样点的X坐标的集合（从小到大）</li>
<li><code>ys</code>是上述矩阵中取样点的y坐标的集合</li>
<li>二位插值的思路实际上就是<strong>先在一维上</strong>完成插值然后利用<strong>一维插值的结果向量</strong>再进行<strong>正交方向</strong>上的<strong>一维插值</strong></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/15/C-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/15/C-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">C++二级指针和二维数组（不使用Vector）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-15 00:01:25 / 修改时间：00:15:34" itemprop="dateCreated datePublished" datetime="2022-08-15T00:01:25+08:00">2022-08-15</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>不要将二级指针和二维数组混为一谈，二维数组再指针作为起始地址的基础上必须还知道第二维度的长度才可以，因为实际上的数组索引操作是<code>i*&lt;第二维度大小&gt; + j</code><h2 id="动态二维数组的创建和销毁-不使用Vector"><a href="#动态二维数组的创建和销毁-不使用Vector" class="headerlink" title="动态二维数组的创建和销毁(不使用Vector)"></a>动态二维数组的创建和销毁(不使用Vector)</h2></li>
<li>创建<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> **dataMat;</span><br><span class="line">dataMat = <span class="keyword">new</span> <span class="keyword">double</span>* [x_size];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;xSize;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dataMat[i] = <span class="keyword">new</span> <span class="keyword">double</span>[ySize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/wordwarwordwar/article/details/52558583">参考链接</a></li>
<li>释放二维数组<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;数组第一维的数量&gt;;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> dataMat[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> dataMat;</span><br></pre></td></tr></table></figure></li>
<li>先逐个释放数组的行，然后再释放整个数组<h2 id="动态二维数组的传参"><a href="#动态二维数组的传参" class="headerlink" title="动态二维数组的传参"></a>动态二维数组的传参</h2></li>
<li>对于正常创建的二维数组（不是使用上文的方法创建的动态数组）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：传递数组，注意第二维必须标明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">3</span>],<span class="keyword">int</span> iRows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;iRows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;arr[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当作指针数组传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> (*arr)[<span class="number">3</span>],<span class="keyword">int</span> iRows)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;iRows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;arr[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接传递一级指针（强制类型转换）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">(<span class="keyword">int</span>*arr,<span class="keyword">int</span> iRows,<span class="keyword">int</span> iCols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;iRows;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*(arr+i*iRows+j)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">fun1</span>(a,<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">fun2</span>(a,<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//此处必须进行强制类型转换，因为a是二维数组，而需要传入的是指针</span></span><br><span class="line">    <span class="comment">//所以必须强制转换成指针，如果a是一维数组则不必进行强制类型转换</span></span><br><span class="line">    <span class="comment">//为什么一维数组不用强制转换而二维数组必须转换，此问题还没解决，期待大牛！</span></span><br><span class="line">    <span class="built_in">fun3</span>((<span class="keyword">int</span>*)a,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>假如预先<strong>不知道数组的第二维度</strong>是多少的话，还是只能使用强制类型转换为<strong>一级指针</strong>的方法传递。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43036419/article/details/110490025">参考链接</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/08/%E5%9F%BA%E4%BA%8EWSL%E5%BC%80%E5%8F%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/%E5%9F%BA%E4%BA%8EWSL%E5%BC%80%E5%8F%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">基于WSL开发内核模块</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-08 23:10:15" itemprop="dateCreated datePublished" datetime="2022-08-08T23:10:15+08:00">2022-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-10 18:56:42" itemprop="dateModified" datetime="2022-08-10T18:56:42+08:00">2022-08-10</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="WSL内核更换为自定义版本（解决微软安装的内核版本源码找不到的问题）"><a href="#WSL内核更换为自定义版本（解决微软安装的内核版本源码找不到的问题）" class="headerlink" title="WSL内核更换为自定义版本（解决微软安装的内核版本源码找不到的问题）"></a>WSL内核更换为自定义版本（解决微软安装的内核版本源码找不到的问题）</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46161993/article/details/109062992">编译自定义内核参考连接</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chubbykkk/article/details/125216332">替换自定义内核参考</a></li>
<li>效果<ul>
<li><img src="/imgs/d543dbfb866f2ea29a9c8841d6d6100514d0bef1c8278ed300c480e03ac57786.png" alt="图 1">  </li>
<li>注意，<strong>config-wsl</strong>文件中的<code>CONFIG_LOCALVERSION=&quot;-microsoft-wsl&quot;</code>是<strong>可以修改</strong>的<h2 id="模块的安装和卸载"><a href="#模块的安装和卸载" class="headerlink" title="模块的安装和卸载"></a>模块的安装和卸载</h2></li>
</ul>
</li>
<li>安装：<code>sudo insmod &lt;模块文件名&gt;</code></li>
<li>卸载：<code>rmmod &lt;模块文件名&gt;</code></li>
<li>查看模块信息 <code>modinfo &lt;模块文件名&gt;</code></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268363827">参考链接</a></li>
<li>打开系统日志可见效果;</li>
<li><img src="/imgs/01d831157a75cf187c848e60646f401dc4a953698b903fe4d961239b81c4f0da.png" alt="图 2">  <h2 id="在-proc下创建文件并且通过读写该文件实现与内核的交互"><a href="#在-proc下创建文件并且通过读写该文件实现与内核的交互" class="headerlink" title="在/proc下创建文件并且通过读写该文件实现与内核的交互"></a>在/proc下创建文件并且通过读写该文件实现与内核的交互</h2></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Ph-one/p/5530320.html">参考链接</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/486960022">参考链接</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2ddd32527367">参考连接</a></li>
<li>上述参考链接由一些错误之处，比如需要include <code>#include &lt;linux/uaccess.h&gt;</code><ul>
<li><code>proc_ops</code>的结构体ing不是<code>file_operations</code>，而是自己的结构<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">procOps</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">    .proc_open = demo_open,</span><br><span class="line">    .proc_write = demo_set,</span><br><span class="line">    <span class="comment">// .read = seq_read,</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>create_proc_entry</code>函数往往找不到需要替换成<code>proc_create</code>函数</li>
<li><code>single_open</code>实际上是<code>simple_open</code>等等</li>
<li>需要自己通过查看相应的头文件进行修正<h2 id="添加内核服务器并连接"><a href="#添加内核服务器并连接" class="headerlink" title="添加内核服务器并连接"></a>添加内核服务器并连接</h2></li>
<li><a target="_blank" rel="noopener" href="http://blog.chinaunix.net/uid-29043620-id-5843468.html">参考链接</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freesion.com/article/7378816741/">参考链接</a></li>
<li>基本方法与创建Socket类似，用户需要自己定义一个内核端口号用于跟用户程序通信，用户程序只要跟相同端口号通信即可。</li>
</ul>
<h2 id="内核线程的创建"><a href="#内核线程的创建" class="headerlink" title="内核线程的创建"></a>内核线程的创建</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Ph-one/p/6077787.html">参考链接</a></li>
<li>主要是<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">kthread_create</span><span class="params">(<span class="keyword">int</span> (*threadfn)(<span class="keyword">void</span> *data),</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">const</span> <span class="keyword">char</span> namefmt[], ...)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>和<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wake_up_process</span><span class="params">(struct task_struct *tsk)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>两个函数</li>
<li>因为使用<code>kthread_create</code>创建线程之后<strong>并不会立即开始执行</strong>，需要通过<code>wake_up_process</code>函数使其开始执行才可以。</li>
</ul>
<h2 id="内核互斥锁等"><a href="#内核互斥锁等" class="headerlink" title="内核互斥锁等"></a>内核互斥锁等</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.lmlphp.com/user/60011/article/item/607287/">参考链接</a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mutex.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>加锁<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span><span class="params">(struct mutex *lock)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>解锁<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_unlock</span><span class="params">(struct mutex *lock)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="内核动态内存分配"><a href="#内核动态内存分配" class="headerlink" title="内核动态内存分配"></a>内核动态内存分配</h2></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/W_shaolin/article/details/121070583">参考链接</a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="内核延时"><a href="#内核延时" class="headerlink" title="内核延时"></a>内核延时</h2></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liangzc1124/article/details/121756964">参考链接</a></li>
</ul>
<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/frankzhang0219/linuxKernelServer">仓库链接</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/08/07/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%A8%E7%90%86%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/07/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%A8%E7%90%86%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/" class="post-title-link" itemprop="url">C语言实现BP神经网络的推理以及反向传播</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-08-07 23:04:51 / 修改时间：23:27:30" itemprop="dateCreated datePublished" datetime="2022-08-07T23:04:51+08:00">2022-08-07</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C语言实现BP神经网络的推理以及反向传播"><a href="#C语言实现BP神经网络的推理以及反向传播" class="headerlink" title="C语言实现BP神经网络的推理以及反向传播"></a>C语言实现BP神经网络的推理以及反向传播</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li>头文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BPNETWORK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPNETWORK_H</span></span><br><span class="line"><span class="comment">//所需头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) Sigmoid(x)<span class="comment">//激活函数设定</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f_(x) Sigmoidf(x)<span class="comment">//导函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span>* ws;<span class="comment">//权重矩阵</span></span><br><span class="line">    <span class="keyword">double</span>* bs;<span class="comment">//偏置数组</span></span><br><span class="line">    <span class="keyword">double</span>* os;<span class="comment">//输出数组</span></span><br><span class="line">    <span class="keyword">double</span>* ss;<span class="comment">//误差(总误差关于加权和的偏导)</span></span><br><span class="line">&#125; Layer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> lns;<span class="comment">//层数</span></span><br><span class="line">    <span class="keyword">int</span>* ns;<span class="comment">//每层神经元的数量</span></span><br><span class="line">    <span class="keyword">double</span>* is;<span class="comment">//神经网络输入</span></span><br><span class="line">    <span class="keyword">double</span>* ts;<span class="comment">//理想输出</span></span><br><span class="line">    Layer* las;<span class="comment">//神经网络各个层(不包括输入层)</span></span><br><span class="line">    <span class="keyword">double</span> ln;<span class="comment">//学习率</span></span><br><span class="line">&#125;BPNetWork;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建神经网络</span></span><br><span class="line"><span class="function">BPNetWork* <span class="title">BPCreate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> len,<span class="keyword">double</span> ln)</span></span>;</span><br><span class="line"><span class="comment">//运行一次神经网络</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunOnce</span><span class="params">(BPNetWork* network)</span></span>;</span><br><span class="line"><span class="comment">//载入训练集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadIn</span><span class="params">(BPNetWork* network, <span class="keyword">double</span>* input, <span class="keyword">double</span>* putout)</span></span>;</span><br><span class="line"><span class="comment">//反向传播一次(训练一次)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrainOnce</span><span class="params">(BPNetWork* network)</span></span>;</span><br><span class="line"><span class="comment">//输出总误差</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ETotal</span><span class="params">(BPNetWork* network)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sigmoid激活函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sigmoid(x)  (1 / (1 + exp(-(x))))</span></span><br><span class="line"><span class="comment">//sigmoid激活函数的导函数（用反函数的形式表示）,输入为sigmoid输出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sigmoidf(f)  ((f) * (1 - (f)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tanh(x) ((2 / (1 + exp(-2 * (x))))-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tanhf(f) ((1+(f))*(1-(f)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>.c文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;BPNetWork.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//神经网络的层数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS network-&gt;lns</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入层神经元的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INNS network-&gt;ns[0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入层的第a个输入</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INS(a) network-&gt;is[a-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第a个理想输出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAS(a) network-&gt;ts[a-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出层神经元的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OUTNS network-&gt;ns[LS-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第n层神经元的数量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NS(n) network-&gt;ns[n-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第n层第a个神经元的第p个权重</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WF(n,a,p) network-&gt;las[n-2].ws[(p-1)+(a-1)*NS(n-1)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第n层的第a个神经元的偏置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BF(n,a) network-&gt;las[n-2].bs[a-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第n层第a个神经元的输出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OF(n,a) network-&gt;las[n-2].os[a-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第n层第a个神经元的误差</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SF(n,a) network-&gt;las[n-2].ss[a-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//学习率</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LN network-&gt;ln</span></span><br><span class="line"></span><br><span class="line"><span class="function">BPNetWork* <span class="title">BPCreate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> len,<span class="keyword">double</span> ln)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BPNetWork* network = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BPNetWork));</span><br><span class="line">    network-&gt;lns = len;</span><br><span class="line">    network-&gt;ns = <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    network-&gt;ln = ln;</span><br><span class="line">    <span class="built_in">memcpy</span>(network-&gt;ns, nums, len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// nums传入的是每层的神经元数目，将其拷贝到储存每层神经元数量的ns</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    network-&gt;is = <span class="built_in">malloc</span>(nums[<span class="number">0</span>] * <span class="keyword">sizeof</span>(<span class="keyword">double</span>)); <span class="comment">// 神经网络输入</span></span><br><span class="line">    network-&gt;las = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Layer) * (len - <span class="number">1</span>)); <span class="comment">// 神经网络各个层</span></span><br><span class="line">    network-&gt;ts = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>) * nums[len - <span class="number">1</span>]); <span class="comment">// 神经网络理想输出</span></span><br><span class="line">    srand(&amp;network);<span class="comment">//用networkd的内存地址做为随机数种子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; len - <span class="number">1</span>; p++) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastnum = nums[p];<span class="comment">//上一层的神经元数量</span></span><br><span class="line">        <span class="keyword">int</span> num = nums[p + <span class="number">1</span>];<span class="comment">//当前层的神经元数量（从第二层开始）</span></span><br><span class="line">        network-&gt;las[p].bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>) * num); <span class="comment">//偏置数组</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        network-&gt;las[p].ws = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>) * num * lastnum); <span class="comment">//权重矩阵（大小是本层与上一层的节点数量的乘积）</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        network-&gt;las[p].os = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>) * num); <span class="comment">//输出数组</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        network-&gt;las[p].ss = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>) * num); <span class="comment">//误差</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> pp = <span class="number">0</span>; pp &lt; num; pp++) &#123;</span><br><span class="line">            <span class="comment">//这里rand()/2.0的意思是把整数除整数转换为浮点数除整数</span></span><br><span class="line">            <span class="comment">//如果是整数除整数,输出则为带余的商</span></span><br><span class="line">            network-&gt;las[p].bs[pp] = rand() / <span class="number">2.0</span> / RAND_MAX; <span class="comment">//偏置矩阵初始化随机数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ppp = <span class="number">0</span>; ppp &lt; lastnum; ppp++) &#123;</span><br><span class="line">                network-&gt;las[p].ws[ppp + pp * lastnum] = rand() / <span class="number">2.0</span> / RAND_MAX; <span class="comment">//权重矩阵初始化随机数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> network;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunOnce</span><span class="params">(BPNetWork* network)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算输入层到第二层</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= NS(<span class="number">2</span>); a++) &#123;</span><br><span class="line">        <span class="keyword">double</span> net = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span>* o = &amp;OF(<span class="number">2</span>,a);<span class="comment">// 第2层的输出值指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> aa = <span class="number">1</span>; aa &lt;= INNS; aa++) &#123;</span><br><span class="line">            <span class="comment">// 和是向量积</span></span><br><span class="line">            net += INS(aa) * WF(<span class="number">2</span>, a, aa);<span class="comment">//输入层的某个输入*第一个全连接层中相应的权重*第一个全连接层的神经元数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        *o = f(net + BF(<span class="number">2</span>,a)); <span class="comment">//加偏置计算最终结果，然后乘激活函数，写入第二层的输出数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">2</span>; n &lt;= LS<span class="number">-1</span>; n++) &#123; <span class="comment">//LS是层数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= NS(n + <span class="number">1</span>); a++) &#123;<span class="comment">//NS是对应层神经元的数量，循环内容是针对下一层的每个神经元</span></span><br><span class="line">            <span class="keyword">double</span> net = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">double</span>* o = &amp;OF(n+<span class="number">1</span>,a);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> aa = <span class="number">1</span>; aa &lt;= NS(n); aa++) &#123; <span class="comment">// 计算向量积</span></span><br><span class="line">                <span class="keyword">double</span> oo = OF(n, aa); <span class="comment">// 上一层某个神经元的输出</span></span><br><span class="line">                <span class="keyword">double</span>* ww = &amp;WF(n + <span class="number">1</span>, a, aa); <span class="comment">// 第a个和第aa个的权重</span></span><br><span class="line">                net += oo * (*ww); <span class="comment">// 和是向量积</span></span><br><span class="line">            &#125;</span><br><span class="line">            *o = f(net + BF(n + <span class="number">1</span>, a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TrainOnce</span><span class="params">(BPNetWork* network)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算输出层的误差函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">1</span>; a &lt;= OUTNS; a++) &#123;</span><br><span class="line">        <span class="keyword">double</span>* s = &amp;SF(LS,a);<span class="comment">//获取第a个神经元的误差</span></span><br><span class="line">        <span class="keyword">double</span>* b = &amp;BF(LS, a);<span class="comment">//获取第a个神经元的偏置</span></span><br><span class="line">        <span class="keyword">double</span> o = OF(LS, a);<span class="comment">//获取第a个神经元的输出</span></span><br><span class="line">        *s = (<span class="number">2.0</span> / OUTNS) * (o - TAS(a))* f_(o); <span class="comment">// 2/输出层元素数量*（某个神经元的输出-该位置的理想输出）* 斜率</span></span><br><span class="line">        *b = *b - LN * (*s); <span class="comment">//更新偏置</span></span><br><span class="line">        <span class="comment">//更新权重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> aa = <span class="number">1</span>; aa &lt;=NS(LS<span class="number">-1</span>) ; aa++) &#123;</span><br><span class="line">            <span class="keyword">double</span>* w = &amp;WF(LS, a, aa); <span class="comment">// 获得最后一层权重矩阵的权重</span></span><br><span class="line">            *w = *w - LN * (*s) * OF(LS<span class="number">-1</span>, aa);  <span class="comment">// 权重减去  学习率*上面计算出的s*上一层该神经元的输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算隐藏层的误差</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = LS<span class="number">-1</span>; a &gt; <span class="number">2</span>; a--) &#123;</span><br><span class="line">        <span class="comment">//开始计算第a层每个神经元的误差</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= NS(a); n++) &#123;<span class="comment">//当前层</span></span><br><span class="line">            <span class="keyword">double</span>* s = &amp;SF(a, n);<span class="comment">//获取第a个神经元的误差</span></span><br><span class="line">            *s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">double</span>* b = &amp;BF(a, n);<span class="comment">//获取第a个神经元的偏置</span></span><br><span class="line">            <span class="keyword">double</span> o = OF(a, n);<span class="comment">//获取第a个神经元的输出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> nn = <span class="number">1</span>; nn &lt;= NS(a+<span class="number">1</span>); nn++) &#123;<span class="comment">//下一层</span></span><br><span class="line">                <span class="keyword">double</span> lw = WF(a + <span class="number">1</span>, nn, n);<span class="comment">//获取下一层到当前神经元的权重</span></span><br><span class="line">                <span class="keyword">double</span> ls = SF(a + <span class="number">1</span>, nn);<span class="comment">//获取下一层第nn个神经元的误差</span></span><br><span class="line">                *s += ls * lw * f_(o); <span class="comment">// 权重*误差*激活函数斜率，和是向量积</span></span><br><span class="line">            &#125;</span><br><span class="line">            *b = *b - LN * (*s);<span class="comment">//更新偏置</span></span><br><span class="line">            <span class="comment">//更新权重</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> nn = <span class="number">1</span>; nn &lt;= NS(a - <span class="number">1</span>); nn++) &#123;<span class="comment">//上一层</span></span><br><span class="line">                <span class="keyword">double</span>* w = &amp;WF(a, n, nn); <span class="comment">// 更新上一层到这一层的权重矩阵</span></span><br><span class="line">                *w = *w - LN * (*s) *OF(a - <span class="number">1</span>, nn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算第2层的误差函数（输入层到第一隐藏层）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= NS(<span class="number">2</span>); n++) &#123;<span class="comment">//当前层</span></span><br><span class="line">        <span class="keyword">double</span>* s = &amp;SF(<span class="number">2</span>, n);<span class="comment">//获取第a个神经元的误差</span></span><br><span class="line">        *s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span>* b = &amp;BF(<span class="number">2</span>, n);<span class="comment">//获取第a个神经元的偏置</span></span><br><span class="line">        <span class="keyword">double</span> o = OF(<span class="number">2</span>, n);<span class="comment">//获取第a个神经元的输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nn = <span class="number">1</span>; nn &lt;= NS(<span class="number">3</span>); nn++) &#123;<span class="comment">//下一层</span></span><br><span class="line">            <span class="keyword">double</span> lw = WF(<span class="number">3</span>, nn, n);<span class="comment">//获取下一层到当前神经元的权重</span></span><br><span class="line">            <span class="keyword">double</span> ls = SF(<span class="number">3</span>, nn);<span class="comment">//获取下一层第nn个神经元的误差</span></span><br><span class="line">            *s += ls * lw * f_(o);</span><br><span class="line">        &#125;</span><br><span class="line">        *b = *b - LN * (*s);<span class="comment">//更新偏置</span></span><br><span class="line">        <span class="comment">//更新权重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nn = <span class="number">1</span>; nn &lt;= INNS; nn++) &#123;<span class="comment">//上一层</span></span><br><span class="line">            <span class="keyword">double</span>* w = &amp;WF(<span class="number">2</span>, n, nn);</span><br><span class="line">            *w = *w - LN * (*s) * INS(nn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadIn</span><span class="params">(BPNetWork* network,<span class="keyword">double</span>* input,<span class="keyword">double</span>* putout)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(network-&gt;is, input, INNS*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(network-&gt;ts, putout, OUTNS*<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">1</span> &#125;;<span class="comment">//4层神经元,数量分别为1,20,20,1</span></span><br><span class="line">    <span class="keyword">double</span> in[<span class="number">1</span>] = &#123; <span class="number">0.9</span> &#125;;<span class="comment">//训练样本输入1</span></span><br><span class="line">    <span class="keyword">double</span> in1[<span class="number">1</span>] = &#123; <span class="number">0.1</span> &#125;;<span class="comment">//训练样本输入2</span></span><br><span class="line">    <span class="keyword">double</span> in2[<span class="number">1</span>] = &#123; <span class="number">0.5</span> &#125;;<span class="comment">//训练样本输入3</span></span><br><span class="line">    <span class="keyword">double</span> out[<span class="number">1</span>] = &#123; <span class="number">0.1</span> &#125;;<span class="comment">//理想输出</span></span><br><span class="line">    <span class="comment">//神经网络训练目标:</span></span><br><span class="line">    <span class="comment">//输入任意值,输出0.1</span></span><br><span class="line">    BPNetWork* network = BPCreate(a, <span class="number">4</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1000</span>;<span class="comment">//训练1000次</span></span><br><span class="line">    <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">        LoadIn(network, in, out);</span><br><span class="line">        RunOnce(network);</span><br><span class="line">        TrainOnce(network);</span><br><span class="line">        LoadIn(network, in1, out);</span><br><span class="line">        RunOnce(network);</span><br><span class="line">        TrainOnce(network);</span><br><span class="line">        LoadIn(network, in2, out);</span><br><span class="line">        RunOnce(network);</span><br><span class="line">        TrainOnce(network);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//训练完后来一波测试</span></span><br><span class="line">    <span class="keyword">double</span> t[<span class="number">1</span>] = &#123; <span class="number">0.7</span> &#125;;<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">double</span> o[<span class="number">1</span>] = &#123; <span class="number">0.2</span> &#125;;<span class="comment">//凑数</span></span><br><span class="line">    LoadIn(network, t, o);</span><br><span class="line">    RunOnce(network);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g\n&quot;</span>, ETotal(network));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g&quot;</span>, OF(<span class="number">4</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><h3 id="正向"><a href="#正向" class="headerlink" title="正向"></a>正向</h3><ul>
<li>正向推理的计算过程是某层的某个节点的输出数值等于<strong>该层上一层</strong>的某个节点的输出×<strong>这个节点到该层待求的节点的权重</strong>， 如上对上一层<strong>每个节点</strong>计算一遍并<strong>求和</strong>，然后加上该层该节点的偏置，并且带入激活函数计算得到这层这个节点的输出</li>
<li><img src="/imgs/f90abed083088d4195ae18b30301ed39ea70dce182200ea6df9ee6df85a66d72.png" alt="图 1">  <h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3></li>
<li>反向传播的计算对于输出层到上一层的权重更新而言就是<strong>上一层到这一层某节点的权重</strong>减去输出层某节点的实际输出和理想输出的差×激活函数的导数×系数×学习率×<strong>上一层对应节点的输出</strong></li>
<li>对于中间层的计算，某个节点的误差等于下一层某节点到该节点的权重×下一层对应节点的误差×该节点激活函数的斜率，如上计算求和得到该节点的误差，然后对于上一层每个节点到这一个节点的权重，更新方法为减去学习率×该节点的误差（前文计算的）×上一层对应节点的输出</li>
<li><img src="/imgs/cb70a13bd33f56aa5a0522be2fccb8da78edbb49b0b66a2aa0d411cbe4f02952.png" alt="图 2">  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/07/27/%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AEnfs%E8%B8%A9%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/27/%E5%BC%80%E5%8F%91%E6%9D%BF%E9%85%8D%E7%BD%AEnfs%E8%B8%A9%E5%9D%91/" class="post-title-link" itemprop="url">开发板配置nfs踩坑</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-27 13:38:52" itemprop="dateCreated datePublished" datetime="2022-07-27T13:38:52+08:00">2022-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-28 22:43:02" itemprop="dateModified" datetime="2022-07-28T22:43:02+08:00">2022-07-28</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="开发板配置nfs踩坑"><a href="#开发板配置nfs踩坑" class="headerlink" title="开发板配置nfs踩坑"></a>开发板配置nfs踩坑</h1><h2 id="配置好nfs服务器路径等之后重启nfs服务的时候可能无法重启遇到错误"><a href="#配置好nfs服务器路径等之后重启nfs服务的时候可能无法重启遇到错误" class="headerlink" title="配置好nfs服务器路径等之后重启nfs服务的时候可能无法重启遇到错误"></a>配置好nfs服务器路径等之后重启nfs服务的时候可能无法重启遇到错误</h2><ul>
<li><img src="/imgs/1b64ed91879caed772df196df38cbd0e5638597e292ef9ddd9505a4126295e86.png" alt="图 1">  </li>
<li>此时需要执行命令<code>sudo service rpcbind start</code></li>
<li>然后再执行<code>sudo /etc/init.d/nfs-kernel-server restart</code><h2 id="从Uboot启动Linux可能ping不通WSL的问题"><a href="#从Uboot启动Linux可能ping不通WSL的问题" class="headerlink" title="从Uboot启动Linux可能ping不通WSL的问题"></a>从Uboot启动Linux可能ping不通WSL的问题</h2></li>
<li>开发板Linux端使用命令<code>ifconfig eth0 172.20.98.200 netmask 255.255.240.0</code>，配置ip地址和子网掩码，配置到与WSL再<strong>同一个子网之下</strong>即可ping通<h2 id="Uboot可以通过tftp下载内核和设备树但是无法用nfs下载文件系统的问题"><a href="#Uboot可以通过tftp下载内核和设备树但是无法用nfs下载文件系统的问题" class="headerlink" title="Uboot可以通过tftp下载内核和设备树但是无法用nfs下载文件系统的问题"></a>Uboot可以通过tftp下载内核和设备树但是无法用nfs下载文件系统的问题</h2></li>
<li>使用WSL<strong>安装旧版（比如18.04）</strong>的Ubuntu</li>
<li>将Ubuntu移动到D盘（假如C盘空间不足）<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45700350/article/details/125227040">参考链接</a></li>
<li>安装好之后安装完nfs服务之后，将服务的配置文件<code>/etc/default/nfs-kernel-server</code>文件进行修改如下<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  <span class="comment"># Number of servers to start up</span></span><br><span class="line">RPCNFSDCOUNT=<span class="string">&quot;-V 2 8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Runtime priority of server (see nice(1))</span></span><br><span class="line">RPCNFSDPRIORITY=0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Options for rpc.mountd.</span></span><br><span class="line"><span class="comment"># If you have a port-based firewall, you might want to set up</span></span><br><span class="line"><span class="comment"># a fixed port here using the --port option. For more information,</span></span><br><span class="line"><span class="comment"># see rpc.mountd(8) or http://wiki.debian.org/SecuringNFS</span></span><br><span class="line"><span class="comment"># To disable NFSv4 on the server, specify &#x27;--no-nfs-version 4&#x27; here</span></span><br><span class="line">RPCMOUNTDOPTS=<span class="string">&quot;-V 2 --manage-gids&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do you want to start the svcgssd daemon? It is only required for Kerberos</span></span><br><span class="line"><span class="comment"># exports. Valid alternatives are &quot;yes&quot; and &quot;no&quot;; the default is &quot;no&quot;.</span></span><br><span class="line">NEED_SVCGSSD=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Options for rpc.svcgssd.</span></span><br><span class="line">RPCSVCGSSDOPTS=<span class="string">&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span></span><br><span class="line">RPCNFSDOPTS=<span class="string">&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>然后<strong>重启WSL虚拟机</strong>，然后重启tftp、xinetd、rpcbind、nfs服务**</li>
<li>注意重启之后WSL所处的<strong>网段、子网掩码、网关</strong>等都可能改变，，所以一定要使用WSL的<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig &lt;网卡号（比如eth0）&gt; &lt;指定的IP地址&gt;</span><br></pre></td></tr></table></figure>
设置WSL系统的IP地址到同一个网段下，假如重启之后<strong>开发板ping不通虚拟机</strong>的话还需要重新按照之前的博客配置虚拟机网络与开发板的桥接</li>
<li>成功结果如图</li>
<li><img src="/imgs/f3d2319d4773d96e9331fba91ad296b376fd2e876dedefe74e05bd8bc1ae205b.png" alt="图 2">  </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/07/27/%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%9A%E8%BF%87%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%9C%AC%E6%9C%BAWSL%E8%99%9A%E6%8B%9F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/27/%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E6%9D%BF%E9%80%9A%E8%BF%87%E7%BD%91%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%9C%AC%E6%9C%BAWSL%E8%99%9A%E6%8B%9F%E6%9C%BA/" class="post-title-link" itemprop="url">配置开发板通过网线连接本机WSL虚拟机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-27 11:55:00 / 修改时间：12:09:14" itemprop="dateCreated datePublished" datetime="2022-07-27T11:55:00+08:00">2022-07-27</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>593</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="配置开发板通过网线连接本机WSL虚拟机"><a href="#配置开发板通过网线连接本机WSL虚拟机" class="headerlink" title="配置开发板通过网线连接本机WSL虚拟机"></a>配置开发板通过网线连接本机WSL虚拟机</h1><ul>
<li><p>开发板先正常启动到Linux系统方便调试</p>
</li>
<li><p>开发板用上面的网线接口连接到计算机的网口</p>
</li>
<li><p>此时在计算机Windows端命令行输入<code>ipconfig</code>可以看到“以太网”具有相应的IP地址等信息</p>
</li>
<li><p>打开WSL虚拟机</p>
</li>
<li><p>在WSL虚拟机使用<code>ifconfig</code>命令查看虚拟机的网络配置，IP地址，子网掩码，广播地址等等</p>
</li>
<li><p><img src="/imgs/61f4265dbfff438355aad4fbe7486a2eafda4b901f1dc691ab19f9d533f457b0.png" alt="图 1">  </p>
</li>
<li><p>虚拟机使用<code>netstat -rn</code>命令查看网关</p>
</li>
<li><p><img src="/imgs/4c7645d1ddf70738ba0b2481e06e64ba824a9cf41d4df016ae1d27d57c2c3747.png" alt="图 2">  </p>
</li>
<li><p>看到内核路由表的第一条的Gateway就是网关信息</p>
</li>
<li><p><strong>此时WSL处在NAT模式，没有开启桥接</strong></p>
</li>
<li><p>使用命令<code>Get-NetAdapter</code>查看网络设备</p>
</li>
<li><p>使用命令<code>Set-VMSwitch WSL -NetAdapterName &lt;桥接到的网卡名称&gt;</code>桥接WSL与以太网，如下(直接输入中文“以太网”即可)</p>
</li>
<li><p><img src="/imgs/ec8dfe21ae9cf0d454518137d0a9b8c4ac8759f610575c1012027702b0fbc280.png" alt="图 3">  </p>
</li>
<li><p>复位开发板，按下键盘打断Uboot启动Linux</p>
</li>
<li><p>使用Uboot的如下命令设置网络并保存环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenv ipaddr &lt;与WSL虚拟机在同一子网下的另一个IP地址&gt;</span><br><span class="line">setenv gatewayip &lt;WSL虚拟机上看到的网关&gt;</span><br><span class="line">setenv netmask &lt;WSL虚拟机看到的子网掩码&gt;</span><br><span class="line">setenv serverip &lt;WSL虚拟机上ifconfig看到的IP地址&gt;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure></li>
<li><p>然后尝试ping WSL虚拟机IP（也就是在WSL中ifconfig看到的IP）</p>
</li>
<li><p><img src="/imgs/5aa9ff0c921acd969021449f60b49a85e3d9597b1ed0c42f285dac9fb217856c.png" alt="图 4">  </p>
</li>
<li><p>然后开始使用tftp传输Linux内核</p>
</li>
<li><p><img src="/imgs/7aca547914f9f4056cbb698df2d99ecef6131cf615739af5b4c324fce75ade36.png" alt="图 5">  </p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://frankzjz219.github.io/2022/07/26/%E9%85%8D%E7%BD%AEWSL2%E4%B8%BA%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8E%9F%E6%9D%A5%E6%98%AFNAT%E6%A8%A1%E5%BC%8F%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar1.jpg">
      <meta itemprop="name" content="FrankZhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/26/%E9%85%8D%E7%BD%AEWSL2%E4%B8%BA%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8E%9F%E6%9D%A5%E6%98%AFNAT%E6%A8%A1%E5%BC%8F%EF%BC%89/" class="post-title-link" itemprop="url">配置WSL2为桥接模式（原来是NAT模式）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-26 10:07:19" itemprop="dateCreated datePublished" datetime="2022-07-26T10:07:19+08:00">2022-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-06 00:26:49" itemprop="dateModified" datetime="2023-09-06T00:26:49+08:00">2023-09-06</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="配置WSL2为桥接模式（原来是NAT模式）"><a href="#配置WSL2为桥接模式（原来是NAT模式）" class="headerlink" title="配置WSL2为桥接模式（原来是NAT模式）"></a>配置WSL2为桥接模式（原来是NAT模式）</h1><ul>
<li><p>配置为<strong>桥接模式</strong>之后局域网中的设备就可以<strong>直接访问WSL</strong>，不需要借助电脑的端口转发</p>
</li>
<li><p>首先在命令行（具有<strong>管理员权限</strong>）中输入<code>Get-NetAdapter</code>，查看电脑的网卡情况（此时可能看不到WSL的虚拟网卡）</p>
</li>
<li><p><img src="/imgs/2a1e4199284bb6f34b17e59acd90a47457a8270692ad41ad95f55a44156d3789.png" alt="图 1">  </p>
</li>
<li><p>然后使用命令<code>Set-VMSwitch WSL -NetAdapterName &lt;桥接到的网卡名称&gt;</code>，将其中的尖括号部分替换为需要桥接到的网卡，比如<strong>WLAN</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-VMSwitch WSL -NetAdapterName WLAN</span><br></pre></td></tr></table></figure></li>
<li><p>然后再次使用<code>Get-NetAdapter</code>，输出如下</p>
</li>
<li><p><img src="/imgs/8ace140dd419539ff686b785950ad0bdf57c82012717a7bac6b33975b722d621.png" alt="图 2">  </p>
</li>
<li><p>可见增加了基于Hyper-V的WSL虚拟网卡</p>
</li>
<li><p>然后使用Windows的<code>ipconfig</code>查询计算机的网关等信息，同时在设置中查看计算机的DNS等信息，然后使用这些信息配置WSL的网络</p>
</li>
<li><p><img src="/imgs/10c4b7c405b29480c2d8b5b872eb6d84c2b5755f0cde537de5765af517962dcf.png" alt="图 4">  </p>
</li>
<li><p><img src="/imgs/90b8d5543f1531f630d77bea20a2c514681f8a4be4d7bd5f90f017df9811201e.png" alt="图 5">  </p>
</li>
<li><p>使用如下命令配置WSL的网络（WSL中）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo ip addr del $(ip addr show eth0 | grep <span class="string">&#x27;inet\b&#x27;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | head -n 1) dev eth0</span><br><span class="line">sudo ip addr add &lt;需要设置的IP地址&gt;/24 broadcast &lt;局域网广播地址（一般是网络号.网络号.网络号.255）&gt; dev eth0</span><br><span class="line">sudo ip route add 0.0.0.0/0 via &lt;默认网关&gt; dev eth0</span><br></pre></td></tr></table></figure></li>
<li><p>然后WSL<code>ping</code>百度可以ping通</p>
</li>
<li><p><img src="/imgs/211a40fcd4e0364e16eff2edf904fa5feb73b3093a1105796ae967d2c1965262.png" alt="图 6">  </p>
</li>
<li><p>Windows<code>ping</code>WSL的IP也可以<code>ping</code>通</p>
</li>
<li><p><img src="/imgs/4742d27c3fd93d8907e7b0a501ac471f5c9876026ba066418a1faec43a047045.png" alt="图 7">  </p>
</li>
<li><p>参考链接 </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/488442403">知乎</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chubbykkk/article/details/125216708">csdn</a></li>
</ul>
</li>
<li><p><strong>注意这样实际上是整个电脑通过WSL的网卡在上网，使用的就是主机的IP地址</strong></p>
<h2 id="更改WSL为桥接模式之后远程显示的问题"><a href="#更改WSL为桥接模式之后远程显示的问题" class="headerlink" title="更改WSL为桥接模式之后远程显示的问题"></a>更改WSL为桥接模式之后远程显示的问题</h2></li>
<li><p>因为更改WSL为桥接模式之后，WSL变为局域网下与Windows平级的设备，所以需要重新配置<code>.bashrc</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>找到这一行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=&lt;IP地址&gt;:0</span><br></pre></td></tr></table></figure></li>
<li><p>将这一行中尖括号的部分修改为<strong>计算机在局域网中的IP地址</strong>然后即可继续使用WSL桌面（比如<code>startxfce4</code>）</p>
</li>
<li><p><img src="/imgs/6ceb41155c3d371a919243c79169702e60f5b5bd66864aba5360198b3dc84a3d.png" alt="图 8">  </p>
<h2 id="修改DNS服务器"><a href="#修改DNS服务器" class="headerlink" title="修改DNS服务器"></a>修改DNS服务器</h2><p>您可以通过以下步骤在WSL中设置DNS服务器：</p>
</li>
<li><p>启动WSL，进入目录，创建<code>wsl.conf</code>文件。例如，您可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/../../etc</span><br><span class="line">sudo vim wsl.conf</span><br><span class="line">sudo touch wsl.conf</span><br></pre></td></tr></table></figure></li>
<li><p>将这些行添加到wsl.conf中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateResolvConf=false</span><br></pre></td></tr></table></figure></li>
<li><p>退出WSL，关闭WSL。您可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure></li>
<li><p>此时，由于有了wsl.conf，run/resolvconf应该不再存在，并且将不再被创建。</p>
</li>
<li><p>删除现有的符号链接文件。例如，您可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/../../etc</span><br><span class="line">sudo rm resolv.conf</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个新的resolv.conf文件。例如，您可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim resolv.conf</span><br><span class="line">sudo touch resolv.conf</span><br></pre></td></tr></table></figure></li>
<li><p>将自己的DNS添加到resolv.conf中。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure></li>
<li><p>其中<code>8.8.8.8</code>是您想要使用的DNS服务器地址。</p>
</li>
<li><p>重启WSL。您可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure></li>
<li><p>再次启动WSL</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FrankZhang"
      src="/images/avatar1.jpg">
  <p class="site-author-name" itemprop="name">FrankZhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">175</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FrankZhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">629k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">19:04</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
