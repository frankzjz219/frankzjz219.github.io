<!DOCTYPE html>


<html lang="Chinese">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Frank’s blogs</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/FLogo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/bkgPic.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Frank’s blogs</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['包含但不限于Linux编程', '算法题总结', 'C/C++/python等开发'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">包含但不限于Linux编程、C/C++开发、算法题等等。</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Linux线程（二）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/22/Linux%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"
    >Linux线程（二）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/22/Linux%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2022-01-22T04:15:28.000Z" itemprop="datePublished">2022-01-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux线程（二）"><a href="#Linux线程（二）" class="headerlink" title="Linux线程（二）"></a>Linux线程（二）</h1><h2 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h2><ul>
<li>默认情况下，当线程终止时，其它线程可以通过调用 pthread_join()获取其返回状态、回收线程资源，有 时，程序员<strong>并不关心线程的返回状态，只是希望系统在线程终止时能够自动回收线程资源并将其移除</strong>。在这 种情况下，可以调用 pthread_detach()将指定线程进行分离，也就是分离线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>线程分离自己</li>
<li><code>pthread_detach(pthread_self());</code></li>
<li>一旦线程处于分离状态，<strong>就不能再使用 <code>pthread_join()</code>来获取其终止状态</strong>，此过程是不可逆的，一旦处于 分离状态之后便不能再恢复到之前的状态。处于<strong>分离状态的线程，当其终止后，能够自动回收线程资源</strong>。</li>
</ul>
<h2 id="注册线程清理处理函数"><a href="#注册线程清理处理函数" class="headerlink" title="注册线程清理处理函数"></a>注册线程清理处理函数</h2><ul>
<li>当线程退出时也可以这样做，当线程终止退出时，去执行这样的处理函数， 我们把这个称为线程清理函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当线程执行以下动作时，清理函数栈中的清理函数才会被执行：</p>
<ul>
<li>线程调用 pthread_exit()退出时；</li>
<li>线程响应取消请求时； </li>
<li>用非 0 参数调用 pthread_cleanup_pop()</li>
</ul>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><ul>
<li>在 Linux 下，使用 pthread_attr_t 数据类型定义线程的所有属性</li>
</ul>
<h3 id="线程栈属性"><a href="#线程栈属性" class="headerlink" title="线程栈属性"></a>线程栈属性</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> **stackaddr, <span class="keyword">size_t</span> *stacksize)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="分离状态属性"><a href="#分离状态属性" class="headerlink" title="分离状态属性"></a>分离状态属性</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​    具体略</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul>
<li>当我们编写的程序是一个多线程应用程序时，就不得不考虑到线程安全的问题，确保我们编写的程序是 一个线程安全（thread-safe）的多线程应用程序，什么是线程安全以及如何保证线程安全？带着这些问题， 本小节将讨论线程安全相关的话题。</li>
</ul>
<h3 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h3><ul>
<li>进程中创建的每个线程都有自己的栈地址空间，将其称为线程栈。譬如主线程调用 pthread_create()创建 了一个新的线程，那么这个新的线程有它自己独立的栈地址空间、而主线程也有它自己独立的栈地址空间。 在创建一个新的线程时，可以配置线程栈的大小以及起始地址，当然在大部分情况 下，保持默认即可！</li>
<li>然每个线程都有自己的栈地址空间，那么每个线程<strong>运行过程中所定义的自动变量（局部变量）都是分 配在自己的线程栈中</strong>的，它们<strong>不会相互干扰</strong></li>
</ul>
<h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><ul>
<li>单线程程序只有一条执行流（一个线程就是一条执行流），贯穿程序始终；而对于 多线程程序而言，同一进程却存在多条独立、并发的执行流。</li>
<li>进程中执行流的数量除了与线程有关之外，与<strong>信号处理</strong>也有关联。因为信号是异步的，进程可能会在其 运行过程中的任何时间点收到信号，进而跳转、执行信号处理函数，从而在一个单线程进程（包含信号处理） 中形成了两条（即主程序和信号处理函数）独立的执行流。</li>
<li>如果一个函数被同一进程的多个不同的执行流同时调用，每次函数 调用总是能产生正确的结果（或者叫产生预期的结果），把这样的函数就称为可重入函数。<strong>实质上也就是该函数被多个执行流并发/并行调用</strong></li>
</ul>
<p><strong>绝对可重入函数的特点</strong></p>
<ul>
<li>函数内所使用到的变量均为局部变量，换句话说，该函数内的操作的内存地址均为本地栈地址</li>
<li> 函数参数和返回值均是值类型</li>
<li>函数内调用的其它函数也均是绝对可重入函数</li>
</ul>
<p>很多的 C 库函数有两个版本：可重入版本和不可重入版本，可重入版本函数其名称后面加上了“_r”， 用于表明该函数是一个可重入函数；而不可重入版本函数其名称后面没有“_r”，前面章节内容中也已经遇 到过很多次了，譬如 <code>asctime()</code>/<code>asctime_r()</code>、<code>ctime()</code>/<code>ctime_r()</code>、<code>localtime()</code>/<code>localtime_r()</code>等。</p>
<ul>
<li>一个函数具有<strong>引用类型</strong>的函数，<strong>传入了一个指针</strong>，并在函数内部读写该指针所指向的内存地址，该函 数是一个可重入函数，但同样需要满足一定的条件；如果多个执行流同时调用该函数时，所传入的指针是<strong>共 享变量的地址，那么在这种情况，最终可能得不到预期的结果</strong>；因为在这种情况下，函数 func()所读写的便是<strong>多个执行流的共享数据</strong>，会出现数据不一致的情况，所以是不安全的。</li>
<li>但如果每个执行流所传入的指针是其本地变量（局部变量）对应的地址，那就是没有问题的，所以呢， 这个函数就是一个带条件的可重入函数。</li>
</ul>
<h2 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h2><ul>
<li>一个函数被多个线程（其实也是多个执行流，但是不包括由信号处理函数所产生的执行流）同时调用 时，它总会一直产生正确的结果，把这样的函数称为线程安全函数。线程安全函数包括可重入函数，可重入 函数是线程安全函数的一个真子集，也就是说可重入函数一定是线程安全函数，但线程安全函数不一定是 可重入函数</li>
</ul>
<h3 id="用来保证线程安全的函数"><a href="#用来保证线程安全的函数" class="headerlink" title="用来保证线程安全的函数"></a>用来保证线程安全的函数</h3><ul>
<li>在多线程编程环境下，有些代码段只需要执行一次</li>
<li>  <code>pthread_once()</code>函数保证函数只执行一次</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init_routine)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>once_control：这是一个 pthread_once_t 类型指针，在调用 pthread_once()函数之前，我们<strong>需要定义了一 个 pthread_once_t 类型的静态变量</strong>，调用 pthread_once()时参数 once_control 指向该变量。<strong>通常在定义变量时会使用 PTHREAD_ONCE_INIT 宏对其进行初始化</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>init_routine：一个函数指针，参数init_routine所指向的函数就是要求只能被执行一次的代码段， pthread_once()函数内部会调用 init_routine()，即使 pthread_once()函数会被多次执行，但它能保证 init_routine() 仅被执行一次。</p>
</li>
<li><p>返回值：调用成功返回 0；失败则返回错误编码以指示错误原因。</p>
</li>
<li><p>如果在一个线程调用 pthread_once()时，另外一个线程也调用了 pthread_once，则该线程将<strong>会被阻塞等待</strong>，直到第一个完成初始化后返回。换言之，当调用 pthread_once 成功返回时，调用总是能够肯定所有的状态已经初始化完成了。</p>
</li>
</ul>
<h3 id="线程特有数据"><a href="#线程特有数据" class="headerlink" title="线程特有数据"></a>线程特有数据</h3><ul>
<li><p>线程特有数据也称为线程私有数据，简单点说，就是<strong>为每个调用线程分别维护一份变量的副本（copy）</strong>， 每个线程通过特有数据键（key）访问时，这个<strong>特有数据键都会获取到本线程绑定的变量副本</strong>。这样就可以 <strong>避免变量成为多个线程间的共享数据</strong>。</p>
</li>
<li><p>线程特有数据的核心思想其实非常简单，就是<strong>为每一个调用线程（调用某函数的线程，该函数就是我们 要通过线程特有数据将其实现为线程安全的函数）分配属于该线程的私有数据区</strong>，为每个调用线程分别维 护一份变量的副本。</p>
</li>
<li><p><strong>pthread_key_create()函数</strong>。在为线程分配私有数据区之前，需要调用 pthread_key_create()函数创建一个特有数据键（key）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*))</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>key：调用该函数会创建一个特有数据键，并通过参数 key 所指向的缓冲区返回给调用者，参数 key 是 一个 pthread_key_t 类型的指针，可以把 pthread_key_t 称为 key 类型。调用 pthread_key_create()之前，需要 定义一个 pthread_key_t 类型变量，调用 pthread_key_create()时参数 key 指向 pthread_key_t 类型变量。</li>
<li>destructor：参数 destructor 是一个函数指针，指向一个自定义的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destructor</span><span class="params">(<span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 <code>pthread_key_create()</code>函数允许调用者指定一个<strong>自定义的解构函数</strong>（类似于 C++中的析构函数），使用参数 destructor 指向该函数；该函数通常用于<strong>释放与特有数据键关联的线程私有数据区占用的内存空间</strong>， 当使用线程特有数据的线程终止时，destructor()函数会被自动调用。</li>
<li>返回值：成功返回 0；失败将返回一个错误编号以指示错误原因，返回的错误编号其实就是全局变量 errno，可以使用诸如 strerror()函数查看其错误字符串信息。</li>
</ul>
<p>调用 pthread_key_create()函数创建特有数据键（key）后通常需要为调用线程分配私有数据缓冲区，譬 如通过 malloc()（或类似函数）申请堆内存，每个调用线程分配一次，且只会在线程初次调用此函数时分配。为线程分配私有数据缓冲区之后，通常需要调用 pthread_setspecific()函数，pthread_setspecific()函数其实完成 了这样的操作：首先保存指向线程私有数据缓冲区的指针，并将其与特有数据键以及当前调用线程关联起 来</p>
<ul>
<li><strong>pthread_setspecific()函数</strong></li>
<li>调用 <code>pthread_key_create()</code> 函数创建特有数据键（key）后通常需要为调用线程分配私有数据缓冲区，譬如通过<code>malloc()</code>（或类似函数）申请堆内存，每个调用线程分配一次，且只会在线程初次调用此函数时分配。 为线程分配私有数据缓冲区之后，通常需要调用 <code>pthread_setspecific()</code>函数，<code>pthread_setspecific()</code>函数其实完成了这样的操作：<strong>首先保存指向线程私有数据缓冲区的指针，并将其与特有数据键以及当前调用线程关联起来</strong>；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>key：pthread_key_t 类型变量，参数 key 应赋值为调用 <code>pthread_key_create()</code>函数时创建的特有数据键， 也就是 <code>pthread_key_create()</code>函数的参数 key 所指向的 <code>pthread_key_t</code>变量。</li>
<li>value：参数 value 是一个 void 类型的指针，指向<strong>由调用者分配的一块内存</strong>，<strong>作为线程的私有数据缓冲 区</strong>，当线程终止时，会<strong>自动调用</strong>参数 <strong>key 指定的特有数据键对应的解构函数</strong>来释放这一块动态申请的内存 空间。</li>
<li>返回值：调用成功返回 0；失败将返回一个错误编码，可以使用诸如<code>strerror()</code>函数查看其错误字符串信 息。</li>
</ul>
<p>调用 pthread_setspecific()函数将线程私有数据缓冲区与调用线程以及特有数据键关联之后，便可以使用<br>pthread_getspecific()函数来获取调用线程的私有数据区了。</p>
<ul>
<li><strong>pthread_getspecific()函数</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pthread_getspecific()</code>函数应返回当前调用线程关联到特有数据键的私有数据缓冲区，<strong>返回值是一个指针</strong>， 指向该缓冲区。如果当前调用线程<strong>并没有设置</strong>线程私有数据缓冲区与特有数据键进行关联，则<strong>返回值应为 NULL</strong>，函数中可以利用这一点来判断当前调用线程是否为初次调用该函数，如果是初次调用，则必须为该 线程分配私有数据缓冲区。</li>
</ul>
<p>如果需要删除一个特有数据键（key）可以使用函数 pthread_key_delete()， pthread_key_delete()函数删除先前由 pthread_key_create()创建的键</p>
<ul>
<li><strong>pthread_key_delete()函数</strong></li>
<li>需要删除一个特有数据键（key）可以使用函数 pthread_key_delete()， pthread_key_delete()函数删除先前由 pthread_key_create()创建的键</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 <code>pthread_key_delete()</code>函数将释放参数 key 指定的特有数据键，可以供下一次调用 <code>pthread_key_create()</code> 时使用；调用 <code>pthread_key_delete()</code>时，它并不将查当前是否有线程正在使用该键所关联的线程私有数据缓冲 区，所以它并不会触发键的解构函数，也就不会释放键关联的线程私有数据区占用的内存资源，并且调用 <code>pthread_key_delete()</code>后，当线程终止时也不再执行键的解构函数。</li>
<li>调用的条件<ul>
<li><strong>所有线程已经释放了私有数据区</strong>（显式调用解构函数或线程终止）。</li>
<li>参数 key 指定的特有数据键将不再使用。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERROR_LEN 256</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_once_t</span> once = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> strerror_key;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destructor</span><span class="params">(<span class="keyword">void</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(buf); <span class="comment">//释放内存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_key</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 创建一个键(key)，并且绑定键的解构函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_key_create(&amp;strerror_key, destructor))</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment"> * 对 strerror 函数重写</span></span><br><span class="line"><span class="comment"> * 使其变成为一个线程安全函数</span></span><br><span class="line"><span class="comment"> ******************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="comment">/* 创建一个键(只执行一次 create_key) */</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_once(&amp;once, create_key))</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 获取 */</span></span><br><span class="line">    buf = pthread_getspecific(strerror_key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == buf)</span><br><span class="line">    &#123;                                <span class="comment">//首次调用 my_strerror 函数，则需给调用线程分配线程私有数据</span></span><br><span class="line">        buf = <span class="built_in">malloc</span>(MAX_ERROR_LEN); <span class="comment">//分配内存</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == buf)</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* 保存缓冲区地址,与键、线程关联起来 */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_setspecific(strerror_key, buf))</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (errnum &lt; <span class="number">0</span> || errnum &gt;= _sys_nerr || <span class="literal">NULL</span> == _sys_errlist[errnum])</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">&quot;Unknown error %d&quot;</span>, errnum);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[errnum], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//终止字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步是调用 pthread_once()，以确保只会执行一次 create_key()函数，而在 create_key()函数中便是调用 pthread_key_create()创建了一个键、并绑定了相应的解构函数 destructor()，解构 函数用于释放与键关联的所有线程私有数据所占的内存空间。</li>
<li>函数 strerror()调用 pthread_getspecific()以<strong>获取该调用线程与键相关联的私有数据缓冲区地址</strong>，如 果返回为 NULL，则表明该线程是首次调用 strerror()函数，因为函数会调用 malloc()为其分配一个新的私有 数据缓冲区，并调用 pthread_setspecific()来保存缓冲区地址、并与键与该调用线程建立关联。如果 pthread_getspecific()函数的返回值并不等于 NULL，那么该值将指向以存在的私有数据缓冲区，此缓冲区由之前对 strerror()的调用所分配。</li>
</ul>
<p><strong>使用例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> p_key;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeBuf</span><span class="params">(<span class="keyword">void</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_setspecific(p_key, &amp;a);</span><br><span class="line">    <span class="keyword">int</span>* ptr = (<span class="keyword">int</span>*)pthread_getspecific(p_key);</span><br><span class="line">    <span class="comment">//*ptr += 1;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, str, p_key);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    *ptr += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, str, *ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pa, pb;</span><br><span class="line"></span><br><span class="line">    pthread_key_create(&amp;p_key, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pa, <span class="literal">NULL</span>, func, <span class="string">&quot;thread1:&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;pb, <span class="literal">NULL</span>, func, <span class="string">&quot;thread2:&quot;</span>);</span><br><span class="line">    pthread_join(pa, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程使用同一个key访问同一个全局变量，出现了线程不安全情况</p>
<p><img src="/../imgs/image-20220123144524240.png" alt="image-20220123144524240"></p>
<p>假如是使用两个不同的key：</p>
<p>代码更改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeBuf</span><span class="params">(<span class="keyword">void</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pthread_once_t val = PTHREAD_ONCE_INIT;</span></span><br><span class="line">    <span class="keyword">pthread_key_t</span> p_key;</span><br><span class="line">    pthread_key_create(&amp;p_key, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_setspecific(p_key, &amp;a);</span><br><span class="line">    <span class="keyword">int</span>* ptr = (<span class="keyword">int</span>*)pthread_getspecific(p_key);</span><br><span class="line">    <span class="comment">//*ptr += 1;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(key) %d\n&quot;</span>, str, p_key);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    *ptr += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, str, *ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pa, pb;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pa, <span class="literal">NULL</span>, func, <span class="string">&quot;thread1:&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;pb, <span class="literal">NULL</span>, func, <span class="string">&quot;thread2:&quot;</span>);</span><br><span class="line">    pthread_join(pa, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20220123144850517.png" alt="image-20220123144850517"></p>
<p>效果类似</p>
<p><strong>但是对于同一个key，不同的线程set不同的内存位置，再在<u>不同</u>的线程中用<u>同样的key</u>调用get得到的是<u>各自的变量空间</u></strong></p>
<p>如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeBuf</span><span class="params">(<span class="keyword">void</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_once_t</span> val = PTHREAD_ONCE_INIT;</span><br><span class="line">    <span class="keyword">pthread_key_t</span> p_key;</span><br><span class="line">    pthread_key_create(&amp;p_key, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_setspecific(p_key, str);</span><br><span class="line">    <span class="keyword">char</span>* ptr = pthread_getspecific(p_key);</span><br><span class="line">    <span class="comment">//*ptr += 1;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(key) %d\n&quot;</span>, str, p_key);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> i = ptr[<span class="number">6</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, ptr, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pa, pb;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;pa, <span class="literal">NULL</span>, func, <span class="string">&quot;thread1:&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;pb, <span class="literal">NULL</span>, func, <span class="string">&quot;thread2:&quot;</span>);</span><br><span class="line">    pthread_join(pa, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(pb, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20220123145927573.png" alt="image-20220123145927573"></p>
<h3 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h3><ul>
<li><p>通常情况下，程序中定义的全局变量是进程中所有线程共享的，所有线程都可以访问这些全局变量；而 线程局部存储在定义全局或静态变量时，使用__thread 修饰符修饰变量，此时，<strong>每个线程都会拥有一份对该 变量的拷贝</strong>。线程局部存储中的变量将<strong>一直存在，直至线程终止</strong>，届时会<strong>自动释放这一存储</strong>。</p>
</li>
<li><p>要创建线程局部变量，只需简单地在全 局或静态变量的声明中包含__thread 修饰符即可！</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __thread <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>如果变量声明中使用了关键字 static 或 extern，那么关键字__thread 必须紧随其后。</li>
<li>与一般的全局或静态变量申明一眼，线程局部变量在申明时可设置一个初始值。</li>
<li>可以使用 C 语言取值操作符（&amp;）来获取线程局部变量的地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> __thread <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Child Thread\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;子线程: buf (%p) = %s&quot;</span>, buf, buf);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Main Thread\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* 创建子线程 */</span></span><br><span class="line">    <span class="keyword">if</span> (ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_start, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 等待回收子线程 */</span></span><br><span class="line">    <span class="keyword">if</span> (ret = pthread_join(tid, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程: buf (%p) = %s&quot;</span>, buf, buf);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20220123185312283.png" alt="image-20220123185312283"></p>
<p>可见主线程和子线程的buf<strong>不是同一个东西</strong></p>
<h3 id="多线程信号处理"><a href="#多线程信号处理" class="headerlink" title="多线程信号处理"></a>多线程信号处理</h3><p>信号模型在一些方面是属于进程层面（由进程中的所有线程线程共享）的，而在另一些方面是属于单个 线程层面的</p>
<ul>
<li><p>信号的系统默认行为是属于进程层面。每一个信号都有其对应的系统默认动作， 当进程中的任一线程收到任何一个未经处理（忽略或捕获）的信号时，会执行该信号的默认操作， 信号的默认操作通常是停止或终止进程。</p>
</li>
<li><p>信号处理函数属于进程层面。进程中的所有线程共享程序中所注册的信号处理函数；</p>
</li>
<li><p>信号的发送既可针对整个进程，也可针对某个特定的线程。在满足以下三个条件中的任意一个时， 信号的发送针对的是某个线程</p>
<ul>
<li>产生了硬件异常相关信号，譬如 SIGBUS、SIGFPE、SIGILL 和 SIGSEGV 信号；这些硬件异 常信号在某个线程执行指令的过程中产生，也就是说这些硬件异常信号是由某个线程所引起； 那么在这种情况下，系统会将信号发送给该线程。</li>
<li>当线程试图对已断开的管道进行写操作时所产生的 SIGPIPE 信号；</li>
<li>由函数 pthread_kill()或 pthread_sigqueue()所发出的信号，稍后介绍这两个函数；这些函数允许 线程向同一进程下的其它线程发送一个指定的信号。</li>
</ul>
</li>
<li><p>当一个多线程进程接收到一个信号时，且该信号绑定了信号处理函数时，内核会<strong>任选一个线程来接 收</strong>这个信号，意味着由该线程接收信号并调用信号处理函数对其进行处理，并不是每个线程都会接 收到该信号并调用信号处理函数</p>
</li>
<li><p>信号掩码其实是属于线程层面的，也就是说信号掩码是针对每个线程而言。8.9 小节向大家介绍了 信号掩码的概念，并介绍了 sigprocmask()函数，通过 sigprocmask()可以设置进程的信号掩码，事实 上，信号掩码是并不是针对整个进程来说，而是针对线程，<strong>对于一个多线程应用程序来说，并不存 在一个作用于整个进程范围内的信号掩码</strong>（管理进程中的所有线程）；那么在多线程环境下，各个 线程可以调用 pthread_sigmask()函数来设置它们各自的信号掩码，譬如设置线程可以接收哪些信号、 不接收哪些信号，各线程可独立阻止或放行各种信号。</p>
</li>
<li><p>针对整个进程所挂起的信号，以及针对每个线程所挂起的信号，内核都会分别进行维护、记录。 8.11.1 小节介绍到，调用 sigpending()会返回进程中所有被挂起的信号，事实上，sigpending()会返 回针对整个进程所挂起的信号，以及针对每个线程所挂起的信号的并集。</p>
</li>
<li><p>其他内容略</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-C语言函数指针"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/22/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"
    >C语言函数指针</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/22/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="article-date">
  <time datetime="2022-01-22T02:17:18.000Z" itemprop="datePublished">2022-01-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="C语言函数指针"><a href="#C语言函数指针" class="headerlink" title="C语言函数指针"></a>C语言函数指针</h1><ul>
<li>函数指针是指向函数的指针变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;返回值类型&gt; (*函数指针名称)(&lt;输入参数类型&gt;,...)</span><br></pre></td></tr></table></figure>

<ul>
<li>回调函数使用例：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_array</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">size_t</span> arraySize, <span class="keyword">int</span> (*getNextValue)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = getNextValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传参：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">populate_array(myarray, <span class="number">10</span>, getNextRandomValue);</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Linux线程（一）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/21/Linux%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"
    >Linux线程（一）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/21/Linux%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2022-01-21T15:46:10.000Z" itemprop="datePublished">2022-01-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="inux线程（一）"><a href="#inux线程（一）" class="headerlink" title="inux线程（一）"></a>inux线程（一）</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><ul>
<li>线程是参与系统调度的最小单位。它被包含在进程之中，是进程中的实际运行单位。一个线程指的是进 程中一个单一顺序的控制流（或者说是执行路线、执行流），一个进程中可以创建多个线程，多个线程实现 并发运行，每个线程执行不同的任务。譬如某应用程序设计了两个需要并发运行的任务 task1 和 task2，可将 两个不同的任务分别放置在两个线程中。</li>
</ul>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><ul>
<li>当一个程序启动时，就有一个进程被操作系统（OS）创建，与此同时一个线程也立刻运行，该线程通 常叫做程序的主线程（Main Thread），因为它是程序一开始时就运行的线程。应用程序都是以 main()做为 入口开始运行的，所以 main()函数就是主线程的入口函数，main()函数所执行的任务就是主线程需要执行的 任务。</li>
<li>所以由此可知，任何一个进程都包含一个主线程，只有主线程的进程称为单线程进程，譬如前面章节内 容中所编写的所有应用程序都是单线程程序，它们只有主线程；既然有单线程进程，那自然就存在多线程进 程，所谓多线程指的是除了主线程以外，还包含其它的线程，其它线程通常由主线程来创建（调用 pthread_create 创建一个新的线程），那么创建的新线程就是主线程的子线程。<ul>
<li>其它新的线程（也就是子线程）是由主线程创建的；</li>
<li>主线程通常会在最后结束运行，执行各种清理工作，譬如回收各个子线程。</li>
</ul>
</li>
</ul>
<h3 id="线程vs进程"><a href="#线程vs进程" class="headerlink" title="线程vs进程"></a>线程vs进程</h3><ul>
<li>进程间切换开销大。多个进程同时运行（指宏观上同时运行，无特别说明，均指宏观上），微观上 依然是轮流切换运行，进程间切换开销远大于同一进程的多个线程间切换的开销，通常对于一些中 小型应用程序来说不划算。</li>
<li>进程间通信较为麻烦。每个进程都在各自的地址空间中、相互独立、隔离，处在于不同的地址空间 中，因此相互通信较为麻烦，在上一章节给大家有所介绍。</li>
<li>同一进程的多个线程间切换开销比较小。</li>
<li>同一进程的多个线程间通信容易。它们共享了进程的地址空间，所以它们都是在同一个地址空间 中，通信容易。</li>
<li>线程创建的速度远大于进程创建的速度。</li>
<li>多线程在多核处理器上更有优势！</li>
</ul>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ul>
<li><p>并行指的是可以并排/并列执行多个任务，这样的系统，它通常有多个执行单 元，所以可以实现并行运行，譬如并行运行 task1、task2、task3。</p>
</li>
<li><p><img src="/../imgs/image-20220121235908536.png" alt="image-20220121235908536"></p>
</li>
<li><p>并行运行并不一定要同时开始运行、同时结束运行</p>
</li>
<li><p>并发强调的是一种时分复用，与串行的区别在于，它不必等待上一个任务完成之后 在做下一个任务，可以打断当前执行的任务切换执行下一个任何，这就是时分复用。在同一个执行单元上， 将时间分解成不同的片段（时间片），每个任务执行一段时间，时间一到则切换执行下一个任务，依次这样 轮训（交叉/交替执行），这就是并发运行。</p>
</li>
<li><p><img src="/../imgs/image-20220122000512605.png" alt="image-20220122000512605"></p>
</li>
<li><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接电话，这就说明你不支持并发也不支持并 行，仅仅<strong>只是串行</strong>。</p>
</li>
<li><p>你吃饭吃到一半，电话来了，你停下吃饭去接了电话，电话接完后继续吃饭，这说明你支持<strong>并发</strong>。</p>
</li>
<li><p>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你<strong>支持并行</strong>。</p>
</li>
<li><p>计算机处理器运行速度是非常快的，在单个处理核心虽然以并发方式运行着系统中的线程（微观上交替 /交叉方式运行不同的线程），但在宏观上所表现出来的效果是同时运行着系统中的所有线程，因为处理器 的运算速度太快了，交替轮训一次所花费的时间在宏观上几乎是可以忽略不计的，所以<strong>表示出来的效果就 是同时运行着所有线程。</strong></p>
</li>
</ul>
<h2 id="进程ID"><a href="#进程ID" class="headerlink" title="进程ID"></a>进程ID</h2><ul>
<li><p>每个线程也有其对应的标识，称为线程 ID。进程 ID 在整个系统 中是唯一的，但线程 ID 不同，线程 ID <strong>只有在它所属的进程上下文中才有意义</strong>。</p>
</li>
<li><p>一个线程可通过库函数 pthread_self()来获取自己的线程 ID</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>该函数调用总是成功，返回当前线程的线程 ID</li>
<li>可以使用 pthread_equal()函数来检查两个线程 ID 是否相等</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br><span class="line"><span class="comment">//如果两个线程 ID t1 和 t2 相等，则 pthread_equal()返回一个非零值；否则返回 0。</span></span><br></pre></td></tr></table></figure>

<p>在 Linux 系统中，使 用无符号长整型（unsigned long int）来表示 <code>pthread_t </code>数据类型</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li>主线程可以使用库函数 <code>pthread_create()</code>负责创建一个新的线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>thread：pthread_t 类型指针，当 pthread_create()成功返回时，新创建的线程的线程 ID 会保存在参数 thread 所指向的内存中，后续的线程相关函数会使用该标识来引用此线程。</p>
</li>
<li><p>attr：pthread_attr_t 类型指针，指向 pthread_attr_t 类型的缓冲区，pthread_attr_t 数据类型定义了线程的 各种属性，关于线程属性将会在 11.8 小节介绍。如果将参数 attr 设置为 NULL，那么表示将线程的所有属 性设置为默认值，以此创建新线程。</p>
</li>
<li><p>start_routine：<strong>参数 start_routine 是一个函数指针，指向一个函数</strong>，新创建的线程从 start_routine()函数 开始运行，该函数返回值类型为void *，并且该函数的参数只有一个void *，其实这个参数就是pthread_create() 函数的第四个参数 arg。如果需要向 start_routine()传递的参数有一个以上，那么需要把这些参数放到一个结 构体中，然后把这个结构体对象的地址作为 arg 参数传入。</p>
</li>
<li><p>arg：传递给 start_routine()函数的参数。一般情况下，需要将 arg 指向一个全局或堆变量，意思就是说 在线程的生命周期中，该 arg 指向的对象必须存在，否则如果线程中访问了该对象将会出现错误。当然也可 将参数 arg 设置为 NULL，表示不需要传入参数给 start_routine()函数。</p>
</li>
<li><p>返回值：<strong>成功返回 0；失败时将返回一个错误号</strong>，并且参数 thread 指向的内容是<strong>不确定</strong>的。</p>
</li>
<li><p>线程创建成功，新线程就会加入到系统调度队列中，获取到 CPU 之后就会立马从 start_routine()函数开 始运行该线程的任务；调用 pthread_create()函数后，通常我们无法确定系统接着会调度哪一个线程来使用 CPU 资源</p>
</li>
</ul>
<p>在编译含有<code>pthread</code>的库函数的文件的时候，需要通过gcc的<code>-l</code>选项指定链接库，比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -o 文件名 文件名.c -lpthread</span><br></pre></td></tr></table></figure>

<p>应用举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">new_thread_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新线程: 进程 ID&lt;%d&gt; 线程 ID&lt;%lu&gt;\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程: 进程 ID&lt;%d&gt; 线程 ID&lt;%lu&gt;\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="/../imgs/image-20220122104651258.png" alt="image-20220122104651258"></p>
<ul>
<li>主线程休眠了 1 秒钟，原因在于，<strong>如果主线程不进行休眠，它就可能会立马退出，这样可能会导致新创 建的线程还没有机会运行，整个进程就结束了</strong>。</li>
</ul>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><ul>
<li>线程的 start 函数执行 return 语句并返回指定值，返回值就是线程的退出码；</li>
<li>线程调用 <code>pthread_exit()</code>函数；</li>
<li>调用 <code>pthread_cancel()</code>取消线程（将在 11.6 小节介绍）；</li>
</ul>
<p>如果进程中的任意线程调用 <code>exit()</code>、<code>_exit()</code>或者<code>_Exit()</code>，那么将会导致<strong>整个进程终止</strong>，这里需要注意！</p>
<ul>
<li><code>pthread_exit()</code>函数将终止调用它的线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数 retval 的数据类型为 void *，指定了线程的返回值、也就是线程的退出码，该返回值可由另一个线 程通过调用 pthread_join()来获取；同理，如果线程是在 start 函数中执行 return 语句终止，那么 return 的返 回值也是可以通过 pthread_join()来获取的。</p>
</li>
<li><p>调用 pthread_exit()相当于在线程的 start 函数中执行 return 语句，不同之处在于，可在线程 start 函数所 调用的任意函数中调用 pthread_exit()来终止线程。如果<strong>主线程调用了 <code>pthread_exit()</code>，那么主线程也会终止</strong>， 但<strong>其它线程依然正常运行</strong>，直到进程中的<strong>所有线程终止才会使得进程终止</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">new_thread_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新线程: 进程 ID&lt;%d&gt; 线程 ID&lt;%lu&gt;\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;主线程: 进程 ID&lt;%d&gt; 线程 ID&lt;%lu&gt;\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，将上一个程序中的所有<code>return</code>都改成<code>pthread_exit(NULL)</code>之后，程序会话<strong>并没有在主线程停止之后停止，而是等待子线程停止之后才停止</strong></li>
</ul>
<p>输出为</p>
<p><img src="/../imgs/image-20220122110519433.png" alt="image-20220122110519433"></p>
<h2 id="回收线程"><a href="#回收线程" class="headerlink" title="回收线程"></a>回收线程</h2><ul>
<li>调用 <code>pthread_join()</code>函数来阻塞等待线程的终止， 并获取线程的退出码，回收线程资源（类似于多进程中的<code>wait()</code>函数）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>thread：pthread_join()等待指定线程的终止，通过参数 thread（线程 ID）指定需要等待的线程；</p>
</li>
<li><p>retval：如果参数 retval 不为 NULL，则 pthread_join()将目标线程的退出状态（即目标线程通过 pthread_exit()退出时指定的返回值或者在线程 start 函数中执行 return 语句对应的返回值）<strong>复制到*retval 所指 向的内存区域</strong>；如果目标线程被 pthread_cancel()取消，则将 PTHREAD_CANCELED 放在*retval 中。如果对 目标线程的终止状态不感兴趣，则可将参数 retval 设置为 NULL。</p>
</li>
<li><p>返回值：成功返回 0；失败将返回错误码。</p>
</li>
<li><p>调用 pthread_join()函数将会以<strong>阻塞的形式</strong>等待指定的线程终止，如果该<strong>线程已经终止，则 pthread_join() 立刻返回</strong>。如果多个线程同时尝试调用 pthread_join()等待指定线程的终止，那么结果将是不确定的。</p>
</li>
<li><p>若线程并未分离（detached，将在 11.6.1 小节介绍），则必须使用 pthread_join()来等待线程终止，回收 线程资源；如果线程终止后，其它线程没有调用 pthread_join()函数来回收该线程，那么该线程将<strong>变成僵尸线程</strong>，与僵尸进程的概念相类似；同样，僵尸线程除了浪费系统资源外，若僵尸线程积累过多，那么会导致应 用程序无法创建新的线程。</p>
</li>
<li><p>如果进程中存在着僵尸线程并未得到回收，当进程终止之后，<strong>进程会被其父进程回收，所以僵尸 线程同样也会被回收。</strong></p>
</li>
</ul>
<p><strong>进程还具有以下特点</strong></p>
<ul>
<li><p>线程之间关系是<strong>对等</strong>的。进程中的<strong>任意线程均可调用 pthread_join()函数来等待另一个线程的终止</strong>。 譬如，如果线程 A 创建了线程 B，线程 B 再创建线程 C，那么线程 A 可以调用 pthread_join()等待 线程 C 的终止，线程 C 也可以调用 pthread_join()等待线程 A 的终止；这与进程间层次关系不同， <strong>父进程如果使用 fork()创建了子进程，那么它也是唯一能够对子进程调用 wait()的进程，线程之间 不存在这样的关系</strong>。</p>
</li>
<li><p>不能以非阻塞的方式调用 pthread_join()。对于<strong>进程</strong>，调用 waitpid()既可以实现阻塞方式等待、也可 以实现非阻塞方式等待。</p>
</li>
</ul>
<h2 id="取消线程"><a href="#取消线程" class="headerlink" title="取消线程"></a>取消线程</h2><ul>
<li>有时候，在程序设计需求当中，需要向一个线程发送一个请求，要求它立刻退出，我们把这种操作称为 取消线程，也就是向指定的线程发送一个请求，要求其立刻终止、退出。譬如，一组线程正在执行一个运算， 一旦某个线程检测到错误发生，需要其它线程退出，取消线程这项功能就派上用场了。</li>
<li>调用 pthread_cancel()库函数向一个指定的线程发送取消请求</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>发出取消请求之后，函数 pthread_cancel()立即返回，不会等待目标线程的退出。默认情况下，目标线程 也会立刻退出</li>
<li>线程可以设置自己不被取消或者控制如何被取消</li>
</ul>
<p>使用例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">new_thread_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新线程--running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">/* 创建新线程 */</span></span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, new_thread_start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 向新线程发送取消请求 */</span></span><br><span class="line">    ret = pthread_cancel(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_cancel error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 等待新线程终止 */</span></span><br><span class="line">    ret = pthread_join(tid, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新线程终止, code=%ld\n&quot;</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20220122120358618.png" alt="image-20220122120358618"></p>
<ul>
<li>由打印结果可知，当主线程发送取消请求之后，<strong>新线程便退出了</strong>，而且退出码为<code>-1</code>，也就是 <code>PTHREAD_CANCELED</code>。</li>
</ul>
<h3 id="线程控制自己被取消的时候的行为"><a href="#线程控制自己被取消的时候的行为" class="headerlink" title="线程控制自己被取消的时候的行为"></a>线程控制自己被取消的时候的行为</h3><ul>
<li>默认情况下，线程是响应其它线程发送过来的取消请求的，响应请求然后退出线程。当然，线程可以选 择不被取消或者控制如何被取消，通过 pthread_setcancelstate()和 pthread_setcanceltype()来设置线程的取消性 状态和类型。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstate</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> *oldstate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><p>PTHREAD_CANCEL_ENABLE：线程可以取消，这是新创建的线程取消性状态的默认值，所以 新建线程以及主线程默认都是可以取消的。</p>
</li>
<li><p>PTHREAD_CANCEL_DISABLE：线程不可被取消，如果此类线程接收到取消请求，则会将请求 挂起，直至线程的取消性状态变为 PTHREAD_CANCEL_ENABLE。</p>
</li>
<li><p>pthread_setcanceltype()函数执行的设置取消性类型和获取旧类型操作，这两步是一个原子操作。</p>
</li>
<li><p>参数 type 必须是以下值之一：</p>
<ul>
<li>PTHREAD_CANCEL_DEFERRED：取消请求到来时，线程还是继续运行，取消请求被挂起，直 到线程到达某个取消点（cancellation point，将在 11.6.3 小节介绍）为止，这是所有新建线程包括 主线程默认的取消性类型。</li>
<li>PTHREAD_CANCEL_ASYNCHRONOUS：可能会在任何时间点（也许是立即取消，但不一定） 取消线程，这种取消性类型应用场景很少，不再介绍！</li>
</ul>
</li>
<li><p>取消点：</p>
<ul>
<li>取消点其实就是一系列函数，当执行到这些函数的时候，才会真正响应取消请 求，这些函数就是取消点；在没有出现取消点时，取消请求是无法得到处理的，究其原因在于<strong>系统认为，但 没有到达取消点时，线程此时正在执行的工作是不能被停止的，正在执行关键代码</strong>，此时终止线程将可能会 导致出现意想不到的异常发生。</li>
</ul>
</li>
<li><p>检测线程的可取消性</p>
<ul>
<li><code> pthread_testcancel(void);</code>，头文件同上</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Linux进程间通信简介"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/21/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/"
    >Linux进程间通信简介</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/21/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/" class="article-date">
  <time datetime="2022-01-21T15:36:06.000Z" itemprop="datePublished">2022-01-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux进程间通信简介"><a href="#Linux进程间通信简介" class="headerlink" title="Linux进程间通信简介"></a>Linux进程间通信简介</h1><h2 id="管道和-FIFO"><a href="#管道和-FIFO" class="headerlink" title="管道和 FIFO"></a>管道和 FIFO</h2><ul>
<li>管道是 UNIX 系统上最古老的 IPC 方法，它在 20 世纪 70 年代早期 UNIX 的第三个版本上就出现了。 把一个进程连接到另一个进程的数据流称为管道，管道被抽象成一个文件，5.1 小节曾提及过管道文件（pipe） 这样一种文件类型。<ul>
<li>普通管道 pipe：通常有两种限制，一是单工，数据只能单向传输；二是只能在父子或者兄弟进程间 使用；</li>
<li>流管道 s_pipe：去除了普通管道的第一种限制，为半双工，可以双向传输；只能在父子或兄弟进程 间使用；</li>
<li>有名管道 name_pipe（FIFO）：去除了普通管道的第二种限制，并且允许在不相关（不是父子或兄 弟关系）的进程间进行通讯。</li>
</ul>
</li>
<li>普通管道可用于具有亲缘关系的进程间通信，并且数据只能单向传输，如果要实现双向传输，则必须要 使用两个管道；而流管道去除了普通管道的第一种限制，可以半双工的方式实现双向传输，但也只能在具有 亲缘关系的进程间通信；而有名管道（FIFO）则同时突破了普通管道的两种限制，即可实现双向传输、又能 在非亲缘关系的进程间通信。</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ul>
<li>通知接收信号的进程有某种事件发生，所以可 用于进程间通信；除了用于进程间通信之外，进程还可以发送信号给进程本身。</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul>
<li>消息队列是消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少、管 道只能承载无格式字节流以及缓冲区大小受限等缺陷。消息队列包括 POSIX 消息队列和 System V 消息队 列。</li>
<li>消息队列是 UNIX 下不同进程之间实现共享资源的一种机制，UNIX 允许不同进程将格式化的数据流以 消息队列形式发送给任意进程，有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读 走队列中的消息。</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><ul>
<li>信号量是一个计数器，与其它进程间通信方式不大相同，它主要用于控制多个进程间或一个进程内的多 个线程间对共享资源的访问，相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同 时，进程也可以修改该标志，除了用于共享资源的访问控制外，还可用于进程同步。</li>
<li>它常作为一种锁机制，防止某进程在访问资源时其它进程也访问该资源，因此，主要作为进程间以及同 一个进程内不同线程之间的同步手段。Linux 提供了一组精心设计的信号量接口来对信号量进行操作，它们 声明在头文件 sys/sem.h 中。</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><ul>
<li>共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但其它的多个进程 都可以访问，使得多个进程可以访问同一块内存空间。共享内存是最快的 IPC 方式，它是针对其它进程间 通信方式运行效率低而专门设计的，它往往与其它通信机制，譬如结合信号量来使用，以实现进程间的同步 和通信。</li>
</ul>
<h2 id="套接字（Socket）"><a href="#套接字（Socket）" class="headerlink" title="套接字（Socket）"></a>套接字（Socket）</h2><ul>
<li>Socket 是一种 IPC 方法，是基于网络的 IPC 方法，允许位于同一主机（计算机）或使用网络连接起来 的不同主机上的应用程序之间交换数据，说白了就是网络通信，在提高篇章节内容中将会向大家介绍 Linux 系统下的网络编程。<ul>
<li>各个应用程序创建一个 socket。socket 是一个允许通信的“设备”，两个应用程序都需要用到它。</li>
<li>服务器将自己的 socket 绑定到一个众所周知的地址（名称）上使得客户端能够定位到它的位置。</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-linux进程（二）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/21/linux%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"
    >linux进程（二）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/21/linux%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2022-01-21T13:13:28.000Z" itemprop="datePublished">2022-01-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux进程（二）"><a href="#Linux进程（二）" class="headerlink" title="Linux进程（二）"></a>Linux进程（二）</h1><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul>
<li>Linux 系统下进程通常存在 6 种不同的状态，分为：就绪态、运行态、僵尸态、可中断睡眠状态（浅度 睡眠）、不可中断睡眠状态（深度睡眠）以及暂停态。<ul>
<li>就绪态（Ready）：指该进程<strong>满足被 CPU 调度的所有条件但此时并没有被调度执行</strong>，只要得到 CPU 就能够直接运行；意味着该进程已经准备好被 CPU 执行，当一个进程的时间片到达，操作系统调 度程序会从就绪态链表中调度一个进程；</li>
<li>运行态：指该进程当前正在被 CPU 调度运行，处于就绪态的进程得到 CPU 调度就会进入运行态；</li>
<li>僵尸态：僵尸态进程其实指的就是僵尸进程，指该进程已经结束、但其父进程还未给它“收尸”；</li>
<li>可中断睡眠状态：可中断睡眠也称为浅度睡眠，表示睡的不够“死”，还可以被唤醒，一般来说可 以通过信号来唤醒；</li>
<li>不可中断睡眠状态：不可中断睡眠称为深度睡眠，深度睡眠无法被信号唤醒，只能等待相应的条件 成立才能结束睡眠状态。把浅度睡眠和深度睡眠统称为等待态（或者叫阻塞态），表示进程处于一 种等待状态，等待某种条件成立之后便会进入到就绪态；所以，处于等待态的进程是无法参与进程 系统调度的。</li>
<li>暂停态：暂停并不是进程的终止，表示进程暂停运行，一般可通过信号将进程暂停，譬如 SIGSTOP 信号；处于暂停态的进程是可以恢复进入到就绪态的，譬如收到 SIGCONT 信号。</li>
</ul>
</li>
</ul>
<p><img src="/../imgs/image-20220121212212609.png" alt="image-20220121212212609"></p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><ul>
<li><p>每个进程除了有一个进程 ID、父进程 ID 之外，还有一个进程组 ID，用于标识该进程属于哪一个进程 组，进程组是一个或多个进程的集合，这些进程并不是孤立的，它们彼此之间或者存在父子、兄弟关系，或 者在功能上有联系。</p>
</li>
<li><p>Linux 系统设计进程组实质上是为了方便对进程进行管理。假设为了完成一个任务，需要并发运行 100 个进程，但当处于某种场景时需要终止这 100 个进程，若没有进程组就需要一个一个去终止，这样非常麻烦 且容易出现一些问题；有了进程组的概念之后，就可以将这 100 个进程设置为一个进程组，这些进程共享一 个进程组 ID，这样一来，终止这 100 个进程只需要终止该进程组即可。</p>
</li>
<li><p>进程组的特性</p>
<ul>
<li>每个进程必定属于某一个进程组、且只能属于一个进程组；</li>
<li>每一个进程组有一个组长进程，组长进程的 ID 就等于进程组 ID；</li>
<li>在组长进程的 ID 前面加上一个负号即是操作进程组；</li>
<li>组长进程不能再创建新的进程组；</li>
<li>只要进程组中还存在一个进程，则该进程组就存在，这与其组长进程是否终止无关；</li>
<li>一个进程组可以包含一个或多个进程，进程组的生命周期从被创建开始，到其内所有进程终止或离 开该进程组；</li>
<li>默认情况下，新创建的进程会继承父进程的进程组 ID。</li>
</ul>
</li>
<li><p>通过系统调用 getpgrp()或 getpgid()可以获取进程对应的进程组 ID</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;<span class="comment">//对应的线程的进程组ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用系统调用 setpgid()或 setpgrp()可以加入一个现有的进程组或创建一个新的进程组</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>setpgid()函数将参数 pid 指定的进程的进程组 ID 设置为参数 gpid。如果这两个参数相等（pid==gpid）， 则由 pid 指定的进程变成为进程组的组长进程，创建了一个新的进程；如果参数 pid <strong>等于 0，则使用调用者 的进程 ID</strong>；另外，<strong>如果参数 gpid 等于 0，则创建一个新的进程组，由参数 pid 指定的进程作为进程组组长 进程</strong>。</li>
<li>setpgrp()函数等价于 setpgid(0, 0)。</li>
<li>一个进程只能为<strong>它自己或它的子进程设置进程组 ID</strong>，在它的子进程<strong>调用 exec 函数后，它就不能更改该 子进程的进程组 ID 了</strong>。</li>
</ul>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul>
<li><p>会话是一个或多个进程组的集合</p>
</li>
<li><p><img src="/../imgs/image-20220121213639860.png" alt="image-20220121213639860"></p>
</li>
<li><p>一个会话可包含一个或多个进程组，但只能有一个前台进程组，其它的是后台进程组；每个会话都有一 个会话首领（leader），即创建会话的进程。</p>
</li>
<li><p>一个会话可以有控制终端、也可没有控制终端，在有控制终端的情况下也只能连接一个控制终端，这通常是登录到其上的终端设备（在终端登录情况下）或伪终端设备 （譬如通过 SSH 协议网络登录），一个会话中的进程组可被分为一个前台进程组以及一个或多个后台进程 组。</p>
</li>
<li><p>会话的首领进程连接一个终端之后，该终端就成为会话的控制终端，与控制终端建立连接的会话首领进 程被称为控制进程；产生在终端上的输入和信号将发送给会话的前台进程组中的所有进程，譬如 Ctrl + C（产 生 SIGINT 信号）、Ctrl + Z（产生 SIGTSTP 信号）、Ctrl + \（产生 SIGQUIT 信号）等等</p>
</li>
<li><p>一个进程组由组长进程的 ID 标识，而对于会话来说，<strong>会话的首领进程的进程组 ID 将作为该会话的标 识</strong>，也就是会话 ID（sid），在默认情况下，新创建的进程会继承父进程的会话 ID。通过系统调用 <code>getsid()</code>可 以获取进程的会话 ID</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用系统调用 setsid()可以创建一个会话，其函数原型如下所示</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果调用者进程<strong>不是进程组的组长进程</strong>，调用 setsid()<strong>将创建一个新的会话</strong>，<strong>调用者进程是新会话的首 领进程</strong>，同样也是一个新的进程组的组长进程，调用 setsid()创建的会话将没有控制终端。</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><ul>
<li><p>守护进程（Daemon）也称为精灵进程，是运行在后台的一种特殊进程，它独立于控制终端并且周期性 地执行某种任务或等待处理某些事情的发生</p>
</li>
<li><p><strong>长期运行。</strong>守护进程是一种生存期很长的一种进程，它们一般在系统启动时开始运行，除非强行终 止，否则直到系统关机都会保持运行。与守护进程相比，普通进程都是在用户登录或运行程序时创 建，在运行结束或用户注销时终止，但守护进程不受用户登录注销的影响，它们将会一直运行着、 直到系统关机。</p>
</li>
<li><p><strong>与控制终端脱离</strong>。在 Linux 中，系统与用户交互的界面称为终端，<strong>每一个从终端开始运行的进程都 会依附于这个终端</strong>，这是上一小节给大家介绍的控制终端，也就是会话的控制终端。当<strong>控制终端被 关闭的时候，该会话就会退出</strong>，由<strong>控制终端运行的所有进程都会被终止</strong>，这使得普通进程都是和运 行该进程的终端相绑定的；但守护进程能突破这种限制，它脱离终端并且在后台运行，脱离终端的 目的是为了避免进程在运行的过程中的信息在终端显示并且进程也不会被任何终端所产生的信息 所打断。</p>
</li>
<li><p>守护进程 Daemon，通常简称为 d，一般进程名后面带有 d 就表示它是一个守护进程。</p>
</li>
</ul>
<p><strong>创建守护进程的步骤</strong></p>
<ul>
<li>创建子进程、终止父进程<ul>
<li>父进程调用 fork()创建子进程，然后父进程使用 exit()退出，这样做实现了下面几点。第一，如果该守护 进程是作为一条简单地 shell 命令启动，那么父进程终止会让 shell 认为这条命令已经执行完毕。第二，虽然 子进程继承了父进程的进程组ID，但它有自己独立的进程ID，这保证了子进程不是一个进程组的组长进程， 这是下面将要调用 setsid 函数的先决条件！</li>
</ul>
</li>
<li>子进程调用 setsid 创建会话<ul>
<li>这步是关键，在子进程中调用上一小节给大家介绍的 setsid()函数创建新的会话，由于之前子进程并不 是进程组的组长进程，所以调用 setsid()会使得子进程创建一个新的会话，子进程成为新会话的首领进程， 同样也创建了新的进程组、子进程成为组长进程，此时创建的会话将没有控制终端。所以这里调用 setsid 有 三个作用：让子进程摆脱原会话的控制、让子进程摆脱原进程组的控制和让子进程摆脱原控制终端的控制。 在调用 fork 函数时，子进程继承了父进程的会话、进程组、控制终端等，虽然父进程退出了，但原先 的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。<strong>setsid 函数能够 使子进程完全独立出来，从而脱离所有其他进程的控制</strong>。</li>
</ul>
</li>
<li>将工作目录更改为根目录<ul>
<li>子进程是继承了父进程的当前工作目录，由于在进程运行中，当前目录所在的文件系统是不能卸载的， 这对以后使用会造成很多的麻烦。因此通常的做法是让“/”作为守护进程的当前目录，当然也可以指定其 它目录来作为守护进程的工作目录。</li>
</ul>
</li>
<li>重设文件权限掩码 umask<ul>
<li>文件权限掩码 umask 用于对新建文件的权限位进行屏蔽，在 5.5.5 小节中有介绍。由于使用 fork 函数新 建的子进程继承了父进程的文件权限掩码，这就给子进程使用文件带来了诸多的麻烦。因此，把文件权限掩 码设置为 0，确保子进程有最大操作权限、这样可以大大增强该守护进程的灵活性。设置文件权限掩码的函 数是 umask，通常的使用方法为 umask(0)。</li>
</ul>
</li>
<li>关闭不再需要的文件描述符<ul>
<li>子进程继承了父进程的所有文件描述符，这些被打开的文件可能永远不会被守护进程（此时守护进程指 的就是子进程，父进程退出、子进程成为守护进程）读或写，但它们一样消耗系统资源，可能导致所在的文 件系统无法卸载，所以必须关闭这些文件，这使得守护进程不再持有从其父进程继承过来的任何文件描述 符。</li>
</ul>
</li>
<li>将文件描述符号为 0、1、2 定位到/dev/null<ul>
<li>将守护进程的标准输入、标准输出以及标准错误重定向到/dev/null，这使得守护进程的输出无处显示、 也无处从交互式用户那里接收输入。</li>
</ul>
</li>
<li>其它：忽略 SIGCHLD 信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/* 创建子进程 */</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; pid)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; pid) <span class="comment">//父进</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);      <span class="comment">//直接退出</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> *子进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/* 1.创建新的会话、脱离控制终端 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; setsid())</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 2.设置当前工作目录为根目录 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; chdir(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 3.重设文件权限掩码 umask */</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 4.关闭所有文件描述符 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sysconf(_SC_OPEN_MAX); i++)</span><br><span class="line">        close(i);</span><br><span class="line">    <span class="comment">/* 5.将文件描述符号为 0、1、2 定位到/dev/null */</span></span><br><span class="line">    open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    dup(<span class="number">0</span>);</span><br><span class="line">    dup(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 6.忽略 SIGCHLD 信号 */</span></span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="comment">/* 正式进入到守护进程 */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;守护进程运行中......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20220121223837693.png" alt="image-20220121223837693"></p>
<ul>
<li><p>可见没有输出，因为输出已经重定向到<code>dev/null</code>了</p>
</li>
<li><p>在<code>ps -ajx</code>中看到这个进程</p>
</li>
<li><p><img src="/../imgs/image-20220121224001123.png" alt="image-20220121224001123"></p>
</li>
<li><p>这个进程可以用<code>kill pid</code>停止</p>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li>对于有些程序设计来说，程序只能被执行一次，只要该程序没有结束，就无法 再次运行，我们把这种情况称为单例模式运行，多次同时运行并没有意义、甚至还会带来错误！。</li>
</ul>
<p><strong>方法：</strong></p>
<ul>
<li>通过一个特定的文件存在与否进行判断（进程开始的时候新建一个文件，结束的时候删除）</li>
<li>文件锁<ul>
<li>当程序启动之后，首先打开该文件，调用 open 时一般使用 <code>O_WRONLY | O_CREAT </code>标志，当文件不存在则创建该文件，然后尝试去获取文件锁，若是成功，则将程序 的进程号（PID）写入到该文件中，写入后不要关闭文件或解锁（释放文件锁），保证进程一直持有该文件 锁；若是程序获取锁失败，代表程序已经被运行、则退出本次启动。</li>
<li>通过系统调用 <code>flock()</code>、<code>fcntl()</code>或库函数 <code>lockf()</code>均可实现对文件进行上锁，本小节我们以系统调用flock()为例，系统调用 <code>flock() </code>产生的是咨询锁（建议性锁）、并不能产生强制性锁</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_FILE <span class="meta-string">&quot;./testApp.pid&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="comment">/* 打开 lock 文件，如果文件不存在则创建 */</span></span><br><span class="line">    fd = open(LOCK_FILE, O_WRONLY | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 以非阻塞方式获取文件锁 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == flock(fd, LOCK_EX | LOCK_NB))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;不能重复执行该程序!\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;程序运行中...&quot;</span>);</span><br><span class="line">    ftruncate(fd, <span class="number">0</span>); <span class="comment">//将文件长度截断为 0</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d\n&quot;</span>, getpid());</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str)); <span class="comment">//写入 pid</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../imgs/image-20220121225414970.png" alt="image-20220121225414970"></p>
<ul>
<li>首先打开一个特定的文件，这里只是举例，以当前目录下的 testApp.pid 文件作为特定文件， 以 O_WRONLY | O_CREAT 方式打开，如果文件不存在则创建该文件；打开文件之后<strong>使用 flock 尝试获取文 件锁</strong>，调用 flock()时指定了<strong>互斥锁标志 LOCK_NB</strong>，意味着<strong>同时只能有一个进程拥有该锁</strong>，如果获取锁失败， 表示该程序已经启动了，无需再次执行，然后退出；如果获取锁成功，将进程的 PID 写入到该文件中，<strong>当程 序退出时，会自动解锁、关闭文件</strong>。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-linux进程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/21/linux%E8%BF%9B%E7%A8%8B/"
    >linux进程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/21/linux%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2022-01-21T05:26:22.000Z" itemprop="datePublished">2022-01-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h1><ul>
<li>main传参</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li><p>进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后 它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。</p>
</li>
<li><p>Linux 系统下的每一个进程都有一个进程号（processID，简称 PID），进程号是一个正数，用于唯一标 识系统中的某一个进程。在 Ubuntu 系统下执行 **<code>ps -aux </code>**命令可以查到系统中进程相关的一些信息，包括每个进程 的进程号</p>
</li>
<li><p><img src="/../imgs/image-20220121134232404.png" alt="image-20220121134232404"></p>
</li>
<li><p>通过系统调用 getpid()来获取<strong>本进程</strong>的进程号</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以使用 getppid()系统调用获取父进程的进程号</li>
</ul>
<h2 id="进程的环境变量"><a href="#进程的环境变量" class="headerlink" title="进程的环境变量"></a>进程的环境变量</h2><ul>
<li><p>每一个进程都有一组与其相关的环境变量，这些环境变量以字符串形式存储在一个字符串数组列表中， 把这个数组称为环境列表。其中每个字符串都是以<strong>“名称=值（name=value）”</strong>形式定义</p>
</li>
<li><p>在 shell 终端下可以使用 env 命令查看到 shell 进程的所有环境变量</p>
</li>
<li><p>使用 export 命令还可以添加一个新的环境变量或删除一个环境变量</p>
<ul>
<li><code>export LINUX_APP=123456</code></li>
</ul>
</li>
<li><p>使用”export -n LINUX_APP”命令则可以删除 LINUX_APP 环境变量</p>
<ul>
<li><code>export -n LINUX_APP</code></li>
</ul>
</li>
</ul>
<p>环境变量存放在一个字符串数组中，在应用程序中，通过 environ 变量指向它，environ 是一个全局变 量，在我们的应用程序中只需申明它即可使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ; <span class="comment">// 申明外部全局变量 environ</span></span><br></pre></td></tr></table></figure>

<p>如果只想要<strong>获取某个指定的环境变量</strong>，可以使用库函数 getenv()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不应该去修改其返回的字符串，修改该字符串意味着修改了环境变量对应的值</p>
</li>
<li><p><strong>添加/修改</strong>环境变量</p>
</li>
<li><p>putenv()函数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​            string：参数 string 是一个字符串指针，指向 name=value 形式的字符串。 </p>
<p>​            返回值：成功返回 0；失败将返回非 0 值，并设置 errno。</p>
<ul>
<li>setenv()函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​            name：需要添加或修改的环境变量名称。 </p>
<p>​            value：环境变量的值。 </p>
<p>​            overwrite：若参数 name 标识的环境变量已经存在，在参数 overwrite 为 0 的情况下，setenv()函数将不 改变现有环境变量的值，也就是说本次调用没有产生任何影响；如果参数 overwrite 的值为非 0，若参数 name 标识的环境变量已经存在，则覆盖，不存在则表示添加新的环境变量。</p>
<p>​             返回值：成功返回 0；失败将返回-1，并设置 errno。</p>
<p>​        setenv()函数为<strong>形如 name=value 的字符串</strong>分配一块内存缓冲区，并将参数 name 和参数 value 所指向的 字符串复制到此缓冲区中，以此来创建一个新的环境变量</p>
<ul>
<li>除了上面给大家介绍的函数之外，我们还可以通过一种更简单地方式向进程环境变量表中添加环境变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME=value ./app</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在执行程序的时候，<strong>在其路径前面添加环境变量，以 name=value 的形式添加</strong>，如果是<strong>多个</strong>环境变量， 则在./app 前面放置多对 name=value 即可，以<strong>空格分隔</strong>。</p>
</li>
<li><p>清除环境变量：</p>
<ul>
<li><code>environ = NULL;</code>或者</li>
<li>使用stdlib中的<code>int clearenv(void);</code></li>
</ul>
</li>
</ul>
<h3 id="环境变量的作用"><a href="#环境变量的作用" class="headerlink" title="环境变量的作用"></a>环境变量的作用</h3><ul>
<li>环境变量常见的用途之一是在 shell 中，每一个环境变量都有它所表示的含义，譬如 HOME 环境变量表 示用户的家目录，USER 环境变量表示当前用户名，SHELL 环境变量表示 shell 解析器名称，PWD 环境变 量表示当前所在目录等，在我们自己的应用程序当中，也可以使用进程的环境变量。</li>
</ul>
<h2 id="进程的内存布置"><a href="#进程的内存布置" class="headerlink" title="进程的内存布置"></a>进程的内存布置</h2><ul>
<li><p><strong>正文段。</strong>也可称为代码段，这是 CPU 执行的机器语言指令部分，文本段具有只读属性，以防止程 序由于意外而修改其指令；正文段是可以共享的，即使在多个进程间也可同时运行同一段程序。</p>
</li>
<li><p><strong>初始化数据段。</strong>通常将此段称为数据段，包含了显式初始化的全局变量和静态变量，当程序加载到 内存中时，从可执行文件中读取这些变量的值。</p>
</li>
<li><p><strong>未初始化数据段</strong>。包含了<strong>未进行显式初始化的全局变量和静态变量</strong>，通常将此段称为 bss 段，这一 名词来源于早期汇编程序中的一个操作符，意思是“由符号开始的块”（block started by symbol）， 在程序开始执行之前，系统会将本段内所有内存初始化为 0，可执行文件并没有为 bss 段变量分配 存储空间，在可执行文件中只需记录 bss 段的位置及其所需大小，直到程序运行时，由加载器来分 配这一段内存空间。</p>
</li>
<li><p><strong>栈。</strong>函数内的<strong>局部变量</strong>以及每次函数调用时所需保存的信息都放在此段中，每次调用函数时，函数 传递的实参以及函数返回值等也都存放在栈中。栈是一个动态增长和收缩的段，由栈帧组成，系统 会为每个当前调用的函数分配一个栈帧，栈帧中存储了函数的局部变量（所谓自动变量）、实参和 返回值。</p>
</li>
<li><p><strong>堆</strong>。可在运行时<strong>动态进行内存分配</strong>的一块区域，譬如使用 **malloc()**分配的内存空间，就是从系统堆 内存中申请分配的。</p>
</li>
<li><p><img src="/../imgs/image-20220121141423676.png" alt="image-20220121141423676"></p>
</li>
</ul>
<h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><ul>
<li><p>在 32 位系统中，每个进程的逻辑地址空间均为 4GB，这 4GB 的内存空间按照 3:1 的比例 进行分配，其中用户进程享有 3G 的空间，而内核独自享有剩下的 1G 空间，如下所示：</p>
</li>
<li><p><img src="/../imgs/image-20220121141526808.png" alt="image-20220121141526808"></p>
</li>
<li><p>学习过驱动开发的读者对“虚拟地址”这个概念应该并不陌生，虚拟地址会通过硬件 <strong>MMU（内存管理 单元）</strong>映射到实际的物理地址空间中，建立虚拟地址到物理地址的映射关系后，对虚拟地址的读写操作实际 上就是对物理地址的读写操作，MMU 会将物理地址“翻译”为对应的物理地址</p>
<ul>
<li>虚拟地址解决的问题</li>
<li><strong>内存使用效率低</strong>。内存空间不足时，就需要将其它程序暂时拷贝到硬盘中，然后将新的程序装入内 存。然而由于大量的数据装入装出，内存的使用效率就会非常低。（实际上不会真正给程序分配所有的空间，程序用到的时候才会分配空间）</li>
<li>进程地址<strong>空间不隔离</strong>。由于程序是直接访问物理内存的，所以每一个进程都可以修改其它进程的 内存数据，甚至修改内核地址空间中的数据，所以有些恶意程序可以随意修改别的进程，就会造成 一些破坏，系统不安全、不稳定。</li>
<li>无法<strong>确定程序的链接地址</strong>。程序运行时，链接地址和运行地址必须一致，否则程序无法运行！因为 程序代码加载到内存的地址是由系统随机分配的，是无法预知的，所以程序的运行地址在编译程序 时是无法确认的。</li>
<li>在某些应用场合下，两个或者更多进程能够共享内存。因为每个进程都有自己的映射表，可以让不 同进程的虚拟地址空间映射到相同的物理地址空间中。通常，共享内存可用于实现进程间通信。</li>
<li>便于实现内存保护机制。譬如在多个进程共享内存时，允许每个进程对内存采取不同的保护措施， 例如，一个进程可能以只读方式访问内存，而另一进程则能够以可读可写的方式访问。</li>
</ul>
</li>
</ul>
<h3 id="创建子线程"><a href="#创建子线程" class="headerlink" title="创建子线程"></a>创建子线程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>fork()调用成功后，将会<strong>在父进程中返回子进程的 PID</strong>，而<strong>在子进程中返回值是 0</strong>；如果调用失败，父进 程返回值-1，不创建子进程，并设置 errno。 </li>
<li>fork()系统调用的关键在于，完成对其调用后将存在两个进程，一个是原进程（父进程）、另一个 则是创建出来的子进程，并且<strong>每个进程都会从 fork()函数的返回处继续执行</strong>，会导致调用 fork()返回两次值， <strong>子进程返回一个值、父进程返回一个值</strong>。在程序代码中，可通过返回值来区分是子进程还是父进程。</li>
<li>fork()调用成功后，子进程和父进程会<strong>继续执行 fork()调用之后的指令</strong>，子进程、父进程<strong>各自在自己的进 程空间中运行</strong>。事实上，<strong>子进程是父进程的一个副本，譬如子进程拷贝了父进程的数据段、堆、栈以及继承 了父进程打开的文件描述符，父进程与子进程并不共享这些存储空间</strong>，这是子进程对父进程相应<strong>部分存储 空间的完全复制</strong>，执行 fork()之后，每个进程均可修改各自的栈数据以及堆段中的变量，而并不影响另一个 进程。</li>
<li>虽然子进程是父进程的一个副本，但是对于程序代码段（文本段）来说，<strong>两个进程执行相同的代码段</strong>， 因为代码段是只读的，也就是说父子进程共享代码段，在内存中只存在一份代码段数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">pid_t</span> pid;</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">switch</span> (pid) </span><br><span class="line"> 	&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;这是子进程打印信息&lt;pid: %d, 父进程 pid: %d&gt;\n&quot;</span>,</span><br><span class="line">         getpid(), getppid());</span><br><span class="line">         _exit(<span class="number">0</span>); <span class="comment">//子进程使用_exit()退出</span></span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;这是父进程打印信息&lt;pid: %d, 子进程 pid: %d&gt;\n&quot;</span>,</span><br><span class="line">         getpid(), pid);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进程和子进程之间的文件共享"><a href="#进程和子进程之间的文件共享" class="headerlink" title="进程和子进程之间的文件共享"></a>进程和子进程之间的文件共享</h3><ul>
<li><p>调用 fork()函数之后，子进程会获得父进程所有文件描述符的副本，这些副本的创建方式类似于 dup()， 这也意味着父、子进程对应的文件描述符均指向相同的文件表</p>
</li>
<li><p><img src="/../imgs/image-20220121181944858.png" alt="image-20220121181944858"></p>
</li>
<li><p>由此可知，<strong>子进程拷贝了父进程的文件描述符表</strong>，使得父、子进程中对应的<strong>文件描述符指向了相同的文 件表</strong>，也意味着父、子进程中对应的文件描述符指向了磁盘中相同的文件，因而这些文件在父、子进程间实 现了共享，譬如，如果<strong>子进程更新了文件偏移量，那么这个改变也会影响到父进程中相应文件描述符的位置 偏移量</strong>。</p>
</li>
<li><p><strong>假如是父子进程分别打开同一个文件的话（在fork()之后），则读写文件会互相覆盖，因为偏移量没有互相影响</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">switch</span> (pid)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        fd = open(<span class="string">&quot;./Text.txt&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt; fd)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            _exit(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环写入 4 次</span></span><br><span class="line">            write(fd, <span class="string">&quot;1122&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        fd = open(<span class="string">&quot;./Text.txt&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt; fd)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="comment">//循环写入 4 次</span></span><br><span class="line">            write(fd, <span class="string">&quot;AABB&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>父进程写入5次，子进程写入4次，最终的输出为</p>
<ul>
<li><img src="/../imgs/image-20220121184306317.png" alt="image-20220121184306317"></li>
</ul>
</li>
<li><p><code>vfork()</code></p>
</li>
<li><p>除了 fork()系统调用之外，Linux 系统还提供了 vfork()系统调用用于创建子进程，vfork()与 fork()函数在 功能上是相同的，并且返回值也相同，在一些细节上存在区别</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">vfork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从前面的介绍可知，可以将 fork()认作对父进程的数据段、堆段、栈段以及其它一些数据结构创建拷贝， 由此可以看出，使用 fork()系统调用的代价是很大的，它复制了父进程中的数据段和堆栈段中的绝大部分内 容，这将会消耗比较多的时间，效率会有所降低，<strong>而且太浪费</strong>，原因有很多，其中之一在于，<strong>fork()函数之 后子进程通常会调用 exec 函数</strong>.子进程<strong>不再执行父程序中的代码 段</strong>，而是执行新程序的代码段，从新程序的 main 函数开始执行、并为新程序重新<strong>初始化其数据段、堆段、 栈段等.</strong></p>
</li>
<li><p>出于这一原因，引入了 vfork()系统调用，虽然在一些细节上有所不同，但其效率要高于 fork()函数。类 似于 fork()，vfork()可以为调用该函数的进程创建一个新的子进程，然而，vfork()是为子进程<strong>立即执行 exec()</strong> 新的程序而专门设计的</p>
<ul>
<li>vfork的区别：<ul>
<li>vfork()与 fork()一样都创建了子进程，但 vfork()函数并不会将父进程的地址空间完全复制到子进程 中，因为子进程会立即调用 exec（或_exit），于是也就不会引用该地址空间的数据。不过在子进程 调用 exec 或_exit 之前，它<strong>在父进程的空间中运行</strong>、子进程<strong>共享父进程的内存</strong>。这种优化工作方式 的实现提高的效率；但如果子进程修改了父进程的数据（除了 vfork 返回值的变量）、进行了函数 调用、或者没有调用 exec 或_exit 就返回将可能带来未知的结果。</li>
<li>另一个区别在于，vfork()保证<strong>子进程先运行</strong>，<strong>子进程调用 exec 之后父进程才可能被调度运行</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>现代的 Linux 系统内核已经采 用了写时复制技术来实现 fork()，其效率较之于早期的 fork()实现要高出许多，除非速度绝对重要的场合， 我们的程序当中应舍弃 vfork()而使用 fork()。</p>
</li>
<li><p>调用 fork()之后，子进程成为了一个独立的进程，可被系统调度运行，而父进程也继续被系统调度运行， 这里出现了一个问题，调用 fork 之后，<strong>无法确定父、子两个进程谁将率先访问 CPU</strong></p>
</li>
<li><p>此时可以采用先让某个进程堵塞，然后另一个进程<strong>向其发送信号将其唤醒</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">sigset_t</span> wait_mask;</span><br><span class="line">    <span class="comment">/* 初始化信号集 */</span></span><br><span class="line">    sigemptyset(&amp;wait_mask);</span><br><span class="line">    <span class="comment">/* 设置信号处理方式 */</span></span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGUSR1, &amp;sig, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程开始执行\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程打印信息\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        kill(getppid(), SIGUSR1); <span class="comment">//发送信号给父进程、唤醒它</span></span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> != sigsuspend(&amp;wait_mask)) <span class="comment">//挂起、阻塞</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程开始执行\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程打印信息\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中的父进程先通过调用<code>sigsuspend(&amp;wait_mask)</code>堵塞，然后等待子线程发送<code>kill(getppid(), SIGUSR1)</code>发送信号将其唤醒</li>
</ul>
<p><strong>init 进程的 PID 总是为 1，它是所有子进程的父进程，一切从 1 开始、一切从 init 进程开始</strong></p>
<h3 id="进程的退出"><a href="#进程的退出" class="headerlink" title="进程的退出"></a>进程的退出</h3><ul>
<li>如果程序中注册了进程终止处理函数，那么会调用终止处理函数。在 9.1.2 小节给大家介绍如何注 册进程的终止处理函数；</li>
<li><strong>刷新 stdio 流缓冲区</strong>。</li>
<li>执行_exit()系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个程序会将其中的”Hello World”打印两次，但是假如上述字符串包含换行符的话就不会打印显示，原因如下</p>
<ul>
<li>进程的用户空间内存中维护了 stdio 缓冲区，0 小节给大家 介绍过，因此通过 fork()创建子进程时会复制这些缓冲区。标准输出设备默认使用的是行缓冲，当检测到换 行符\n 时会立即显示函数 printf()输出的字符串，此时输出之后的缓冲区的空的</li>
<li>假如没有换行符的话，系统并不会立即输出内容，这就导致在创建子线程的时候会将缓冲去等待显示的字符串也拷贝一次。当它们<strong>调用 exit()函数时，都会刷 新各自的缓冲区、显示字符串</strong>，所以就会看到打印出了两次相同的字符串<ul>
<li>防止上述问题的办法</li>
<li>在调用 fork()之前，使用函数 <code>fflush()</code>来刷新 stdio 缓冲区，当然，作为另一种选择，也可以使用 setvbuf()和 setbuf()来关闭 stdio 流的缓冲功能</li>
</ul>
</li>
</ul>
<h3 id="监视子进程"><a href="#监视子进程" class="headerlink" title="监视子进程"></a>监视子进程</h3><ul>
<li>系统调用 wait()可以等待进程的任一子进程终止，同时获取子进程 的终止状态信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>status：参数 status 用于存放子进程终止时的状态信息，参数 status 可以为 NULL，表示不接收子进程 终止时的状态信息。</p>
</li>
<li><p> 返回值：若成功则返回终止的子进程对应的进程号；失败则返回-1。</p>
</li>
<li><p>wait函数的内容</p>
<ul>
<li>调用 wait()函数，如果其所有子进程都还在运行，则 <strong>wait()会一直阻塞等待，直到某一个子进程终 止</strong>；</li>
<li>如果进程调用 wait()，但是该进程并没有子进程，也就意味着该进程<strong>并没有需要等待的子进程，那 么 wait()将返回错误，也就是返回-1</strong>、并且会将 errno 设置为 ECHILD。</li>
<li>如果进程调用 wait()之前，它的子进程当中<strong>已经有一个或多个子进程已经终止了，那么调用 wait() 也不会阻塞</strong>。wait()函数的作用除了获取子进程的终止状态信息之外，更重要的一点，就是回收子 进程的一些资源，俗称为子进程“收尸”，关于这个问题后面再给大家进行介绍。所以在调用 wait() 函数之前，已经有子进程终止了，意味着正等待着父进程为其“收尸”，所以调用 wait()将不会阻 塞，而是会立即替该子进程“收尸”、处理它的“后事”，然后返回到正常的程序流程中，<strong>一次 wait() 调用只能处理一次</strong>。</li>
<li>参数 status 不为 NULL 的情况下，则 wait()会将子进程的终止时的状态信息存储在它指向的 int 变量中， 可以通过宏来检查 status 参数（略）</li>
</ul>
</li>
<li><p><code>waitpid()</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pid：参数 pid 用于表示需要等待的某个具体子进程，关于参数 pid 的取值范围如下：</p>
<ul>
<li>如果 pid 大于 0，表示等待进程号为 pid 的子进程；</li>
<li>如果 pid 等于 0，则等待与调用进程（父进程）同一个进程组的所有子进程；</li>
<li>如果 pid 小于-1，则会等待进程组标识符与 pid 绝对值相等的所有子进程；</li>
<li>如果 pid 等于-1，则等待任意子进程。wait(&amp;status)与 waitpid(-1, &amp;status, 0)等价。</li>
</ul>
</li>
<li><p>status：与 wait()函数的 status 参数意义相同。</p>
</li>
<li><p>参数 options 是一个位掩码，可以包括 0 个或多个标志（略）</p>
</li>
</ul>
<h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul>
<li>父进程先于子进程结束，也就是意味着，此时子进程变成了一个“孤儿”，我们把这种进程就称为孤儿 进程。</li>
<li>在 Linux 系统当中，所有的孤儿进程都自动成为 init 进程（进程号为 1）的子进程，换言之，某一子 进程的父进程结束后，该子进程<strong>调用 getppid()将返回 1</strong></li>
</ul>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul>
<li>进程结束之后，通常需要其父进程为其“收尸”，回收子进程占用的一些内存资源，父进程通过调用 wait()（或其变体 waitpid()、waitid()等）函数回收子进程资源，归还给系统。 </li>
<li>如果子进程先于父进程结束，此时父进程还未来得及给子进程“收尸”，那么此时子进程就变成了一个 僵尸进程。</li>
<li>当父进程调用 wait()（或其变体，下文不再强调）为子进程“收尸”后，僵尸进程就会被内核彻底删除。 另外一种情况，如果父进程并没有调用 wait()函数然后就退出了，那么此时 **init 进程将会接管它的子进程并 自动调用 wait()**，故而从系统中移除僵尸进程。</li>
<li>如果系统中存在大量的 僵尸进程，它们<strong>势必会填满内核进程表，从而阻碍新进程的创建</strong>。需要注意的是，僵尸进程是<strong>无法通过信号 将其杀死的</strong>，即使是“一击必杀”信号 SIGKILL 也无法将其杀死，那么这种情况下，只能<strong>杀死僵尸进程的 父进程（或等待其父进程终止）</strong>，这样 init 进程将会<strong>接管这些僵尸进程，从而将它们从系统中清理掉</strong></li>
</ul>
<h2 id="执行新程序"><a href="#执行新程序" class="headerlink" title="执行新程序"></a>执行新程序</h2><h4 id="execve"><a href="#execve" class="headerlink" title="execve()"></a><code>execve()</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>filename：参数 filename 指向需要载入当前进程空间的新程序的路径名，既可以是绝对路径、也可以是 相对路径。 </p>
</li>
<li><p>argv：参数 argv 则指定了传递给新程序的命令行参数。是一个字符串数组，**该数组对应于 main(int argc,  char *argv[])函数的第二个参数 argv，且格式也与之相同，是由字符串指针所组成的数组**，以 NULL 结束。 argv[0]对应的便是新程序自身路径名。 </p>
</li>
<li><p>envp：参数 envp 也是一个字符串指针数组，<strong>指定了新程序的环境变量列表</strong>，参数 envp 其实对应于新程 序的 environ 数组，同样也是以 NULL 结束，所指向的字符串格式为 <strong>name=value</strong>。</p>
</li>
<li><p>execve 调用成功将不会返回；失败将返回-1，并设置 errno。对 execve()的成功调用<strong>将永不返回</strong>，而且也无需检查它的返回值，实际上，一旦该函数返回，就表明它 发生了错误。</p>
</li>
</ul>
<h2 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h2><ul>
<li>使用 system()函数可以很方便地在我们的程序当中执行任意 shell 命令，本小节来学习下 system()函数的 用法，以及介绍 system()函数的实现方法。 首先来看看 system()函数原型，如下所示</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>system()函数其内部的是通过调用 fork()、execl()以及 waitpid()这三个函数来实现它的功能，首先 system() 会调用 fork()创建一个子进程来运行 shell（可以把这个子进程成为 shell 进程），并通过 shell 执行参数 command 所指定的命令。<ul>
<li>当参数 command 为 NULL，如果 shell 可用则返回一个非 0 值，若不可用则返回 0；针对一些非 UNIX 系统，该系统上可能是没有 shell 的，这样就会导致 shell 不可能；如果 command 参数不为 NULL，则返回值从以下的各种情况所决定。</li>
<li>如果无法创建子进程或无法获取子进程的终止状态，那么 system()返回-1；</li>
<li>如果子进程不能执行 shell，则 system()的返回值就好像是子进程通过调用_exit(127)终止了；</li>
<li>如果所有的系统调用都成功，system()函数会返回执行 command 的 shell 进程的终止状态。</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-manjaro停止应用程序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/21/manjaro%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"
    >manjaro停止应用程序</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/21/manjaro%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="article-date">
  <time datetime="2022-01-21T01:33:34.000Z" itemprop="datePublished">2022-01-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="manjaro停止应用程序"><a href="#manjaro停止应用程序" class="headerlink" title="manjaro停止应用程序"></a>manjaro停止应用程序</h1><ul>
<li><p>在命令行输入<code>xkill</code></p>
</li>
<li><p>然后鼠标光标变化，点击想关闭的窗口即可</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-堆排序和快排"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/20/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E6%8E%92/"
    >堆排序和快排</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/20/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E6%8E%92/" class="article-date">
  <time datetime="2022-01-20T14:27:30.000Z" itemprop="datePublished">2022-01-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//heapSort 构建大顶堆或者小顶堆，将堆顶元素与堆尾元素交换后再调整，如此反复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建大顶堆 k为最后一个非叶子节点，逐渐-1，即从下向上，从右往左</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = arr.length/<span class="number">2</span> - <span class="number">1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adjustHeap</span>(arr,k,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序 交换+调整</span></span><br><span class="line">    <span class="keyword">int</span> temp =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        temp =arr [<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="built_in">adjustHeap</span>(arr,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param arr 待调整数组</span></span><br><span class="line"><span class="comment">     * @param i 非叶子节点在数组中的索引</span></span><br><span class="line"><span class="comment">     * @param length 对多少个元素进行调整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];<span class="comment">//取出当前非叶子叶结点的值</span></span><br><span class="line">    <span class="comment">//k为当前节点的左子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>*i+<span class="number">1</span>;k&lt;length;k=<span class="number">2</span>*k+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k+<span class="number">1</span>]&gt;arr[k])</span><br><span class="line">        &#123;<span class="comment">//右子节点大于左子节点</span></span><br><span class="line">            k++;<span class="comment">//k指向右子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[k]&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果当前节点大于父节点就交换</span></span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;<span class="comment">//!!!!!!精髓，因为该子节点值大小发生了改变，可能会使其子根堆发生改变，索引要调整其子根堆</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//否则直接退出，因为其后面的节点一定满足堆定义</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个对象的下标为i，他的左右子节点分别是<code>2i+1</code>和<code>2i+2</code></li>
<li>更换节点的时候</li>
</ul>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//quickSort 每次选择一个元素并且将整个数组以这个元素分为两部分，小于该元素的放右边，大于该元素的放左边</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123; <span class="comment">//跳出递归的条件</span></span><br><span class="line">        <span class="comment">//partition就是划分操作，将arr划分成满足条件的两个子表</span></span><br><span class="line">        <span class="keyword">int</span> pivotpos = <span class="built_in">partition</span>(arr,l,r);</span><br><span class="line">        <span class="comment">//依次对左右两个子表进行递归排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr,l,pivotpos);</span><br><span class="line">        <span class="built_in">quickSort</span>(arr,pivotpos+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//以当前数组的最后一个元素作为中枢pivot，进行划分</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[r];</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r &amp;&amp; arr[l]&lt;pivot) l++;</span><br><span class="line">        arr[r] = arr[l];<span class="comment">//将比中枢值大的移动到右端r处 由于r处为中枢或者该位置值已经被替换到l处，所以直接可以替换</span></span><br><span class="line">        <span class="keyword">while</span> (l&lt;r &amp;&amp; arr[r]&gt;=pivot) r--;</span><br><span class="line">        arr[l] = arr[r];<span class="comment">//将比中枢值小的移动到左端l处 由于前面l处的值已经换到r处，所以该位置值也可以替换掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//l==r时，重合，这个位置就是中枢的最终位置</span></span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    <span class="comment">//返回存放中枢的最终位置</span></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主要的思路是每次选择一个（实际上一般是最右边的那一个）元素作为标准，将比这个元素小的元素移动到数组的左边，大的移动到右边，最后实现这个元素的左边的所有元素都比这个元素小，右边的都比这个大。然后再分别对左边和右边的数组分别排序，实现递归。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-修复manjaro不能识别外接显示器并且开启独显"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/20/%E4%BF%AE%E5%A4%8Dmanjaro%E4%B8%8D%E8%83%BD%E8%AF%86%E5%88%AB%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B9%B6%E4%B8%94%E5%BC%80%E5%90%AF%E7%8B%AC%E6%98%BE/"
    >修复linux不能识别外接显示器并且开启独显</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/20/%E4%BF%AE%E5%A4%8Dmanjaro%E4%B8%8D%E8%83%BD%E8%AF%86%E5%88%AB%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B9%B6%E4%B8%94%E5%BC%80%E5%90%AF%E7%8B%AC%E6%98%BE/" class="article-date">
  <time datetime="2022-01-20T03:00:01.000Z" itemprop="datePublished">2022-01-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="修复linux不能识别外接显示器并且开启独显"><a href="#修复linux不能识别外接显示器并且开启独显" class="headerlink" title="修复linux不能识别外接显示器并且开启独显"></a>修复linux不能识别外接显示器并且开启独显</h1><ul>
<li><p>按照<a target="_blank" rel="noopener" href="https://github.com/Askannz/optimus-manager%E7%9A%84%E7%94%A8%E6%88%B7%E8%AF%B4%E6%98%8E%EF%BC%88manjaro%EF%BC%89">https://github.com/Askannz/optimus-manager的用户说明（manjaro）</a></p>
<ul>
<li><p><img src="/../imgs/image-20220120104302285.png" alt="image-20220120104302285"></p>
</li>
<li><p>将系统的<code>/etc/sddm.conf</code>文件进行修改注释掉两处之后，重启计算机，并且打开<code>optimus-manager-qt</code>，切换到英伟达显卡，再次重启，并且设置开机自启动模式</p>
</li>
</ul>
</li>
</ul>
<p><img src="/../imgs/image-20220120104437272.png" alt="image-20220120104437272"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-manjaro添加快捷键"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/20/manjaro%E6%B7%BB%E5%8A%A0%E5%BF%AB%E6%8D%B7%E9%94%AE/"
    >manjaro添加快捷键</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/20/manjaro%E6%B7%BB%E5%8A%A0%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  <time datetime="2022-01-20T03:00:00.000Z" itemprop="datePublished">2022-01-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="manjaro添加快捷键"><a href="#manjaro添加快捷键" class="headerlink" title="manjaro添加快捷键"></a>manjaro添加快捷键</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xingshen100/article/details/85014978">https://blog.csdn.net/xingshen100/article/details/85014978</a></li>
</ul>
<ul>
<li><p>系统设置</p>
</li>
<li><p><img src="/../imgs/image-20220120105459575.png" alt="image-20220120105459575"></p>
</li>
<li><p><img src="/../imgs/image-20220120105605636.png" alt="image-20220120105605636"></p>
</li>
</ul>
<p>点击edit-new-global shortcut-command/URL新建，设置trigger和action即可</p>
<p><img src="/../imgs/image-20220120105715782.png" alt="image-20220120105715782"></p>
<p><img src="/../imgs/image-20220120105729191.png" alt="image-20220120105729191"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> FrankZhang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.png" alt="Frank’s blogs"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>