<!DOCTYPE html>


<html lang="Chinese">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Frank’s blogs</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/FLogo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/bkgPic.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Frank’s blogs</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['包含但不限于Linux编程', '算法题总结', 'C/C++/python等开发'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">包含但不限于Linux编程、C/C++开发、算法题等等。</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Linux下使用epoll的C语言服务端"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/11/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8epoll%E7%9A%84C%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E7%AB%AF/"
    >Linux下使用epoll的C语言服务端</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/11/Linux%E4%B8%8B%E4%BD%BF%E7%94%A8epoll%E7%9A%84C%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E7%AB%AF/" class="article-date">
  <time datetime="2022-07-11T15:13:44.000Z" itemprop="datePublished">2022-07-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux下使用epoll的C语言服务端"><a href="#Linux下使用epoll的C语言服务端" class="headerlink" title="Linux下使用epoll的C语言服务端"></a>Linux下使用epoll的C语言服务端</h1><ul>
<li>该服务器使用了<code>epoll</code>处理多个同时链接的客户端的事件。</li>
<li>流程为开始使用<code>epoll_create</code>创建一个<code>epoll</code>的Fd，然后将以服务器<code>socket</code>为基础的事件使用<code>epoll_ctl</code>将其添加处理。</li>
<li>然后整个程序进入无限循环，调用<code>epoll_wait</code>等待事件，然后获取到事件列表之后，使用for循环逐个处理，此处仅仅处理收取数据的事件，实际上常见的事件为<code>EPOLLIN</code>、<code>EPOLLET</code>、<code>EPOLLOUT</code>，三者的详细介绍在此不详细解释。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVERPORT 8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*linux上支持（Android上也支持）， 此函数不仅能获取IP，还可以获取MAC地址、掩码和广播地址等*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_local_ip_using_ifconf</span><span class="params">(<span class="keyword">char</span> *str_ip)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sock_fd, intrface;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">buf</span>[<span class="title">INET_ADDRSTRLEN</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ifconf</span> <span class="title">ifc</span>;</span></span><br><span class="line">	<span class="keyword">char</span> *local_ip = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((sock_fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &gt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ifc.ifc_len = <span class="built_in"><span class="keyword">sizeof</span></span>(buf);</span><br><span class="line">		ifc.ifc_buf = (<span class="keyword">caddr_t</span>)buf;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">ioctl</span>(sock_fd, SIOCGIFCONF, (<span class="keyword">char</span> *)&amp;ifc))</span><br><span class="line">		&#123;</span><br><span class="line">			intrface = ifc.ifc_len/<span class="built_in"><span class="keyword">sizeof</span></span>(struct ifreq);</span><br><span class="line">			<span class="keyword">while</span> (intrface-- &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!(<span class="built_in">ioctl</span>(sock_fd, SIOCGIFADDR, (<span class="keyword">char</span> *)&amp;buf[intrface])))</span><br><span class="line">				&#123;</span><br><span class="line">					local_ip = <span class="literal">NULL</span>;</span><br><span class="line">					local_ip = <span class="built_in">inet_ntoa</span>(((struct sockaddr_in*)(&amp;buf[intrface].ifr_addr))-&gt;sin_addr);</span><br><span class="line">					<span class="keyword">if</span>(local_ip)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">strcpy</span>(str_ip, local_ip);</span><br><span class="line">						status = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;127.0.0.1&quot;</span>, str_ip))</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(sock_fd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clientString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* ipAdd;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">&#125; clientStruct;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIGINTHandler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nServer stopping, already closed socket %d. \n&quot;</span>, sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> ip_str[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> addrlen = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> localIPBuf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, (<span class="keyword">sig_t</span>)SIGINTHandler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 打开套接字，得到套接字描述符 */</span></span><br><span class="line">    sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; sockfd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将套接字与指定端口号进行绑定 */</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(SERVERPORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">get_local_ip_using_ifconf</span>(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;(server_addr.sin_addr), localIPBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(localIPBuf));</span><br><span class="line">    <span class="comment">// puts(localIPBuf);</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(sockfd, (struct sockaddr *)&amp;server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 使服务器进入监听状态 */</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(sockfd, <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 阻塞等待客户端连接 */</span></span><br><span class="line">    <span class="keyword">int</span> epfd, connfd;</span><br><span class="line">    epfd = <span class="built_in">epoll_create</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[10];</span></span><br><span class="line">    ev.data.fd = sockfd;</span><br><span class="line">    ev.events = EPOLLIN|EPOLLET|EPOLLOUT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);</span><br><span class="line">    <span class="keyword">int</span> nOfEvent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ipStr;</span><br><span class="line">    <span class="keyword">int</span> clientFd;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">256</span>];</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, clientStruct&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nOfEvent = <span class="built_in">epoll_wait</span>(epfd, events, <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nOfEvent;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd == sockfd)</span><br><span class="line">            &#123;</span><br><span class="line">                clientStruct clientTemp;</span><br><span class="line">                connfd = <span class="built_in">accept</span>(sockfd, (sockaddr* )&amp;client_addr, (<span class="keyword">socklen_t</span>*)&amp;addrlen);</span><br><span class="line">                <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Error: Accept Failure!\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ipStr = <span class="built_in">inet_ntoa</span>(client_addr.sin_addr);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client: %s\n&quot;</span>, ipStr);</span><br><span class="line">                <span class="comment">//将客户端socket与客户端IP的映射关系存入map</span></span><br><span class="line">                clientTemp.ipAdd = ipStr;</span><br><span class="line">                clientTemp.port = <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">                m.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">int</span>, clientStruct&gt;(connfd, clientTemp));</span><br><span class="line">                ev.data.fd = connfd;</span><br><span class="line">                ev.events = EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//修改epoll</span></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;EPOLLIN!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>((clientFd = events[i].data.fd)&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>((n = <span class="built_in">read</span>(clientFd, line, <span class="number">256</span>))&lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close</span>(clientFd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Client Error!\n&quot;</span>);</span><br><span class="line">                    <span class="comment">//从映射关系中抹除之前断开的socket</span></span><br><span class="line">                    m.<span class="built_in">erase</span>(connfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    line[n<span class="number">-1</span>] = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">                    line[n] = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Got message from: %s:&quot;</span>, m.<span class="built_in">count</span>(connfd)&gt;<span class="number">0</span>?m[connfd].ipAdd:<span class="string">&quot;Unkown Client&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%4d\n&quot;</span>, m.<span class="built_in">count</span>(connfd)&gt;<span class="number">0</span>?m[connfd].port:<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;data length = %d\n&quot;</span>, <span class="built_in">strlen</span>(line));</span><br><span class="line">                    <span class="comment">//回显</span></span><br><span class="line">                    <span class="built_in">write</span>(clientFd, line, <span class="built_in">strlen</span>(line)+<span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">memset</span>(line, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(line));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ev.data.fd = clientFd;</span><br><span class="line">                ev.events = EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">// epoll_ctl(epfd, EPOLL_CTL_MOD, clientFd, &amp;ev);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            else if(events[i].events&amp;EPOLLOUT)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                printf(&quot;Sent!&quot;);</span></span><br><span class="line"><span class="comment">                clientFd = events[i].data.fd;</span></span><br><span class="line"><span class="comment">                // write(clientFd, line, strlen(line));</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                ev.data.fd = clientFd;</span></span><br><span class="line"><span class="comment">                ev.events = EPOLLOUT|EPOLLIN|EPOLLET;</span></span><br><span class="line"><span class="comment">                epoll_ctl(epfd, EPOLL_CTL_MOD, clientFd, &amp;ev);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 关闭套接字 */</span></span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上述服务器提供了一个基于C++<code>unordered_map</code>实现的映射，将每次接收到的事件的<code>fd</code>映射到一个存储了该客户端socket对应的IP地址和端口号的结构体上，服务器将其读出即可获取此客户端的相关信息。映射关系是在该客户端初次连接到服务器的时候创建的，并且会在连接关闭或者出现异常的时候从映射中移除。</li>
<li>下面为客户端<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">&quot;0.0.0.0&quot;</span></span></span><br><span class="line"><span class="keyword">int</span> sockFd = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SIGINTHandler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(sockFd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nClient stopping, already closed socket %d. \n&quot;</span>, sockFd);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sock_server_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> sendBuf[<span class="number">100</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> readBuf[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> send_len;</span><br><span class="line"></span><br><span class="line">    sockFd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockFd &lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open socket Error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    sock_server_addr.sin_family = AF_INET;</span><br><span class="line">    sock_server_addr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_aton</span>(SERVER_IP, &amp;sock_server_addr.sin_addr);</span><br><span class="line">    <span class="built_in">memset</span>(sock_server_addr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client started, trying to connect %s:%4d. \n&quot;</span>, SERVER_IP, SERVER_PORT);</span><br><span class="line">    ret = <span class="built_in">connect</span>(sockFd, (struct sockaddr*)&amp;sock_server_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(struct  sockaddr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Client Connected!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect Error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="keyword">char</span> *)&amp;sendBuf);</span><br><span class="line">        <span class="built_in">write</span>(sockFd, sendBuf, <span class="built_in">strlen</span>(sendBuf)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        n = <span class="built_in">read</span>(sockFd, readBuf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Server Repeat: &quot;</span>);</span><br><span class="line">        <span class="comment">// printf(readBuf);</span></span><br><span class="line">        <span class="keyword">while</span> (readBuf[<span class="number">0</span>]!=<span class="number">0</span>&amp;&amp;n&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// puts(&quot;:&quot;);</span></span><br><span class="line">            <span class="built_in">printf</span>(readBuf);</span><br><span class="line">            n = <span class="built_in">read</span>(sockFd, readBuf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(sendBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(sendBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(readBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(readBuf), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-使用VSCode结合hexo撰写博客"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/02/%E4%BD%BF%E7%94%A8VSCode%E7%BB%93%E5%90%88hexo%E6%92%B0%E5%86%99%E5%8D%9A%E5%AE%A2/"
    >使用VSCode结合hexo撰写博客</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/02/%E4%BD%BF%E7%94%A8VSCode%E7%BB%93%E5%90%88hexo%E6%92%B0%E5%86%99%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time datetime="2022-07-02T05:29:22.000Z" itemprop="datePublished">2022-07-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="使用VSCode结合hexo撰写博客"><a href="#使用VSCode结合hexo撰写博客" class="headerlink" title="使用VSCode结合hexo撰写博客"></a>使用VSCode结合hexo撰写博客</h1><ul>
<li><p>VSCode安装<code>Markdown All in One</code>插件<br><img src="/imgs/3bb6348ccf8c066c5afdaeac0eb63f22098a3e1457877205f190013df629f4d8.png" alt="图 5">  </p>
</li>
<li><p>安装<code>Markdown Image</code>插件<br><img src="/imgs/96279228f003610f7191bc2809341b9d48cdc6f2a90cb29725106a506728dfe4.png" alt="图 6">  </p>
</li>
<li><p>安装之后配置该插件的设置部分</p>
</li>
<li><p><img src="/imgs/5460b26cc260f397280cd6ef4c3b623cfc94f70a624dd431f87b9031c2f567e3.png" alt="图 7">  </p>
</li>
<li><p>然后注意将图片目录配置为之前自己指定的<code>hexo</code>图片目录</p>
</li>
<li><p><img src="/imgs/57871a0f3ce7e49bfe93d872ac2302e3ddd9f94be85fb68280597d1b6eb648ba.png" alt="图 8">  </p>
</li>
<li><p>然后在使用的时候使用VSCode<code>打开文件夹</code>打开hexo的<code>source</code>文件夹，然后即可自动加载图片进行预览</p>
</li>
<li><p><img src="/imgs/11b45fa602b1f75a3e282386ac4b7fe3293cb7546191c22265243eba5ca12b06.png" alt="图 9">  </p>
</li>
<li><p>使用VSCode<strong>打开文件夹</strong>之后就<strong>不需要</strong>手动配置<code>Makrdown all in one</code>的根目录</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-二叉树的三种遍历的非递归实现"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/"
    >二叉树的三种遍历的非递归实现</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2022-07-02T03:58:26.000Z" itemprop="datePublished">2022-07-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="二叉树的三种遍历的非递归实现"><a href="#二叉树的三种遍历的非递归实现" class="headerlink" title="二叉树的三种遍历的非递归实现"></a>二叉树的三种遍历的非递归实现</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><ul>
<li>主要思路是先将根节点入栈，然后每次循环从栈顶取出元素输出，同时将该元素的<strong>右节点</strong>和<strong>左节点</strong>压入栈中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            temp = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)s.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)s.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2></li>
<li>主要思路是新建一个结构体，结构体包括二叉树的节点指针信息和是否被访问过的标记信息，标记默认是<code>false</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">nodeStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TreeNode* p; </span><br><span class="line">    <span class="keyword">bool</span> flg; </span><br><span class="line">    <span class="built_in">nodeStruct</span>(TreeNode* ptr):<span class="built_in">p</span>(ptr),<span class="built_in">flg</span>(<span class="literal">false</span>)&#123;&#125;    </span><br><span class="line">    <span class="built_in">nodeStruct</span>(TreeNode* ptr, <span class="keyword">bool</span> flag):<span class="built_in">p</span>(ptr),<span class="built_in">flg</span>(flag)&#123;&#125;   </span><br><span class="line">&#125; nodeS;</span><br></pre></td></tr></table></figure></li>
<li>每次从栈顶取出一个元素，如果该元素的标记提示被访问过，那么直接将元素输出</li>
<li>如果该元素没有被访问过，那么现将该元素的访问标记置为<code>true</code>，然后将该元素的右子节点压入栈中，然后将节点自己压入栈中，最后将左子节点压入栈中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">nodeStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TreeNode* p; </span><br><span class="line">    <span class="keyword">bool</span> flg; </span><br><span class="line">    <span class="built_in">nodeStruct</span>(TreeNode* ptr):<span class="built_in">p</span>(ptr),<span class="built_in">flg</span>(<span class="literal">false</span>)&#123;&#125;    </span><br><span class="line">    <span class="built_in">nodeStruct</span>(TreeNode* ptr, <span class="keyword">bool</span> flag):<span class="built_in">p</span>(ptr),<span class="built_in">flg</span>(flag)&#123;&#125;   </span><br><span class="line">&#125; nodeS;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        stack&lt;nodeS&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(<span class="built_in">nodeS</span>(root));</span><br><span class="line">        <span class="function">nodeS <span class="title">temp</span><span class="params">(<span class="literal">NULL</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            temp = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!temp.flg)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.p-&gt;right)s.<span class="built_in">push</span>(<span class="built_in">nodeS</span>(temp.p-&gt;right));</span><br><span class="line">                temp = <span class="built_in">nodeS</span>(temp.p, <span class="literal">true</span>);</span><br><span class="line">                s.<span class="built_in">push</span>(temp);</span><br><span class="line">                <span class="keyword">if</span>(temp.p-&gt;left)s.<span class="built_in">push</span>(<span class="built_in">nodeS</span>(temp.p-&gt;left));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(temp.p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>##后序遍历</p>
<ul>
<li>结构体方法同上，跟之前的主要区别是针对没有访问过的节点需要<strong>先将自己</strong>压入栈中，然后再将<strong>右节点</strong>和<strong>左节点</strong>压入栈中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"><span class="title">stackUnit</span>&#123;</span></span><br><span class="line">    TreeNode* p;</span><br><span class="line">    <span class="keyword">bool</span> flg;</span><br><span class="line">    <span class="built_in">stackUnit</span>(TreeNode* ptr, <span class="keyword">bool</span> flag):<span class="built_in">p</span>(ptr), <span class="built_in">flg</span>(flag)&#123;&#125;</span><br><span class="line">&#125; nodeS;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        stack&lt;nodeS&gt; s;</span><br><span class="line">        s.<span class="built_in">push</span>(<span class="built_in">nodeS</span>(root, <span class="literal">false</span>));</span><br><span class="line">        <span class="function">nodeS <span class="title">temp</span><span class="params">(<span class="literal">NULL</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            temp = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(temp.flg)</span><br><span class="line">            &#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(temp.p-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">nodeS</span>(temp.p, <span class="literal">true</span>));</span><br><span class="line">                <span class="keyword">if</span>(temp.p-&gt;right)s.<span class="built_in">push</span>(<span class="built_in">nodeS</span>(temp.p-&gt;right,<span class="literal">false</span>));</span><br><span class="line">                <span class="keyword">if</span>(temp.p-&gt;left)s.<span class="built_in">push</span>(<span class="built_in">nodeS</span>(temp.p-&gt;left,<span class="literal">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-分析基于epoll的C-高性能webServer代码（三）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/29/%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84C-%E9%AB%98%E6%80%A7%E8%83%BDwebServer%E4%BB%A3%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89/"
    >分析基于epoll的C++高性能webServer代码（三）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/29/%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84C-%E9%AB%98%E6%80%A7%E8%83%BDwebServer%E4%BB%A3%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89/" class="article-date">
  <time datetime="2022-06-29T11:39:45.000Z" itemprop="datePublished">2022-06-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="分析基于epoll的C-高性能webServer代码（三）"><a href="#分析基于epoll的C-高性能webServer代码（三）" class="headerlink" title="分析基于epoll的C++高性能webServer代码（三）"></a>分析基于epoll的C++高性能webServer代码（三）</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/goosse/article/details/124495526">epoll用法参考</a></p>
<h2 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h2><ul>
<li><p>Socket类基于C语言的tcp通信库实现，将C语言提供的Socket相关操作函数利用C++的面向对象进行了包装</p>
</li>
<li><p>成员数据对象只有一个<code>int serverfd_;</code></p>
</li>
</ul>
<h3 id="构造函数Socket-args"><a href="#构造函数Socket-args" class="headerlink" title="构造函数Socket(/* args */)"></a>构造函数Socket(/* args */)</h3><ul>
<li>创建<code>socket</code>对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Socket::<span class="built_in">Socket</span>(<span class="comment">/* args */</span>)</span><br><span class="line">&#123;</span><br><span class="line">    serverfd_ = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == serverfd_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket create fail!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server create socket&quot;</span> &lt;&lt; serverfd_ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li>关闭<code>socket</code>文件描述符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Socket::~<span class="built_in">Socket</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(serverfd_);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server close...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SetReuseAddr"><a href="#SetReuseAddr" class="headerlink" title="SetReuseAddr()"></a>SetReuseAddr()</h3><ul>
<li>设置地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::SetReuseAddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(serverfd_, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in"><span class="keyword">sizeof</span></span>(on));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Setnonblocking"><a href="#Setnonblocking" class="headerlink" title="Setnonblocking()"></a>Setnonblocking()</h3><ul>
<li>设置为非阻塞模式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Socket::Setnonblocking</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts = <span class="built_in">fcntl</span>(serverfd_, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (opts&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(serverfd_,GETFL)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(serverfd_, F_SETFL, opts | O_NONBLOCK) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(serverfd_,SETFL,opts)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server setnonblocking...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BindAddress-int-serverport"><a href="#BindAddress-int-serverport" class="headerlink" title="BindAddress(int serverport)"></a>BindAddress(int serverport)</h3><ul>
<li>将主机对应的端口号与<code>socket</code>进行绑定</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Socket::BindAddress</span><span class="params">(<span class="keyword">int</span> serverport)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;serveraddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serveraddr));</span><br><span class="line">	serveraddr.sin_family = AF_INET;</span><br><span class="line">	serveraddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//inet_addr(_ServerIP.c_str());</span></span><br><span class="line">	serveraddr.sin_port = <span class="built_in">htons</span>(serverport);</span><br><span class="line">	<span class="keyword">int</span> resval = <span class="built_in">bind</span>(serverfd_, (struct sockaddr*)&amp;serveraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(serveraddr));</span><br><span class="line">	<span class="keyword">if</span> (resval == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">close</span>(serverfd_);</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;error bind&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server bindaddress...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Listen"><a href="#Listen" class="headerlink" title="Listen()"></a>Listen()</h3><ul>
<li>就是调用C提供的<code>Listen</code>函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Socket::Listen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">listen</span>(serverfd_, <span class="number">2048</span>) &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;error listen&quot;</span>);</span><br><span class="line">		<span class="built_in">close</span>(serverfd_);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server listenning...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accept-struct-sockaddr-in-amp-clientaddr"><a href="#Accept-struct-sockaddr-in-amp-clientaddr" class="headerlink" title="Accept(struct sockaddr_in &amp;clientaddr)"></a>Accept(struct sockaddr_in &amp;clientaddr)</h3><ul>
<li>调用C提供的<code>Accept()</code>函数</li>
<li>返回用户<code>socket</code>的文件描述符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket::Accept</span><span class="params">(struct sockaddr_in &amp;clientaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">socklen_t</span> lengthofsockaddr = <span class="built_in"><span class="keyword">sizeof</span></span>(clientaddr);</span><br><span class="line">    <span class="keyword">int</span> clientfd = <span class="built_in">accept</span>(serverfd_, (struct sockaddr*)&amp;clientaddr, &amp;lengthofsockaddr);</span><br><span class="line">    <span class="keyword">if</span> (clientfd &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//perror(&quot;error accept&quot;);</span></span><br><span class="line">        <span class="comment">//if(errno == EAGAIN)</span></span><br><span class="line">            <span class="comment">//return 0;</span></span><br><span class="line">		<span class="comment">//std::cout &lt;&lt; &quot;error accept:there is no new connection accept...&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">return</span> clientfd;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;server accept,clientfd: &quot; &lt;&lt; clientfd &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">return</span> clientfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Close"><a href="#Close" class="headerlink" title="Close()"></a>Close()</h3><ul>
<li>关闭对应的文件描述符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Socket::Close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(serverfd_);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server close...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Epoll介绍"><a href="#Epoll介绍" class="headerlink" title="Epoll介绍"></a>Epoll介绍</h2><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><ul>
<li>当进程A执行到创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象（如下图）。这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。<u>等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程</u>。</li>
</ul>
<p><img src="/imgs/v2-7ce207c92c9dd7085fb7b823e2aa5872_720w.jpg" alt="img"></p>
<ul>
<li>当程序执行到<strong>recv时</strong>，操作系统会将进程A从工作队列移动到该socket的等待队列中（如下图）。由于工作队列只剩下了进程B和C，依据进程调度，cpu会轮流执行这两个进程的程序，不会执行进程A的程序。<strong>所以进程A被阻塞，不会往下执行代码，也不会占用cpu资源</strong>。</li>
</ul>
<p><img src="/imgs/v2-1c7a96c8da16f123388e46f88772e6d8_720w.jpg" alt="img"></p>
<ul>
<li>ps：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</li>
<li>当socket接收到数据后，操作系统将该socket等待队列上的进程<strong>重新放回到工作队列</strong>，该进程变成运行状态，继续执行代码。也由于<u>socket的接收缓冲区已经有了数据，recv可以返回接收到的数据</u>。</li>
</ul>
<h3 id="内核接收网络数据全过程"><a href="#内核接收网络数据全过程" class="headerlink" title="内核接收网络数据全过程"></a>内核接收网络数据全过程</h3><ul>
<li>如下图所示，进程在recv阻塞期间，计算机收到了对端传送的数据（步骤①）。数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知cpu有数据到达，cpu执行中断程序（步骤③）。此处的中断程序主要有两项功能，先将网络数据写入到对应socket的接收缓冲区里面（步骤④），再唤醒进程A（步骤⑤），重新将进程A放入工作队列中。</li>
</ul>
<p><img src="/imgs/v2-696b131cae434f2a0b5ab4d6353864af_720w.jpg" alt="img"></p>
<ul>
<li>一个socket对应着一个端口号，而网络数据包中包含了ip和端口的信息，内核可以通过端口号找到对应的socket。当然，为了提高处理速度，操作系统会维护端口号到socket的索引结构，以快速读取。</li>
</ul>
<h3 id="同时监视多个socket的简单方法"><a href="#同时监视多个socket的简单方法" class="headerlink" title="同时监视多个socket的简单方法"></a><strong>同时监视多个socket的简单方法</strong></h3><ul>
<li>服务端需要管理多个客户端连接，而recv只能监视单个socket，这种矛盾下，人们开始寻找监视多个socket的方法。epoll的要义是<strong>高效</strong>的监视多个socket。从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进。只有先理解了不太高效的方法，才能够理解epoll的本质。</li>
<li>假如能够预先传入一个socket列表，<strong>如果列表中的socket都没有数据，挂起进程，直到有一个socket收到数据，唤醒进程</strong>。这种方法很直接，也是select的设计思想。</li>
<li>为方便理解，我们先复习select的用法。在如下的代码中，先准备一个数组（下面代码中的fds），让fds存放着所有需要监视的socket。然后调用select，如果fds中的所有socket都没有数据，select会阻塞，直到有一个socket接收到数据，select返回，唤醒进程。用户可以遍历fds，通过FD_ISSET判断具体哪个socket收到数据，然后做出处理。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line"><span class="built_in">bind</span>(s, ...)</span><br><span class="line"><span class="built_in">listen</span>(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fds[] =  存放需要监听的socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">select</span>(..., fds, ...)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(fds[i], ...))&#123;</span><br><span class="line">            <span class="comment">//fds[i]的数据处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select的流程"><a href="#select的流程" class="headerlink" title="select的流程"></a>select的流程</h3><ul>
<li>select的实现思路很直接。假如程序同时监视如下图的sock1、sock2和sock3三个socket，那么在调用select之后，操作系统把进程A分别加入这三个socket的等待队列中。</li>
</ul>
<p><img src="/imgs/v2-0cccb4976f8f2c2f8107f2b3a5bc46b3_720w.jpg" alt="img"></p>
<ul>
<li>当任何一个socket收到数据后，中断程序将唤起进程。下图展示了sock2接收到了数据的处理流程。</li>
</ul>
<p><img src="/imgs/v2-85dba5430f3c439e4647ea4d97ba54fc_720w.jpg" alt="img"></p>
<ul>
<li>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面。如下图所示。</li>
</ul>
<p><img src="/imgs/v2-a86b203b8d955466fff34211d965d9eb_720w.jpg" alt="img"></p>
<ul>
<li><p>经由这些步骤，当进程A被唤醒后，它知道至少有一个socket接收了数据。程序只需遍历一遍socket列表，就可以得到就绪的socket。</p>
</li>
<li><p>这种简单方式<strong>行之有效</strong>，在几乎所有操作系统都有对应的实现。</p>
</li>
</ul>
<p><strong>select的缺点</strong></p>
<ul>
<li>其一，每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket。</li>
<li>其二，进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次。</li>
</ul>
<h3 id="epoll的设计思路"><a href="#epoll的设计思路" class="headerlink" title="epoll的设计思路"></a>epoll的设计思路</h3><ul>
<li>epoll是在select出现N多年后才被发明的，是select和poll的增强版本。epoll通过以下一些措施来改进效率。</li>
<li>select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见的，效率就能得到提升。</li>
</ul>
<p><img src="/imgs/eb0153cf87170138262d2109a7e59a447a4b085e7092880892bc91c9652d95c7.png" alt="图 1">  </p>
<ul>
<li>为方便理解后续的内容，我们先复习下epoll的用法。如下的代码中，先用epoll_create创建一个epoll对象epfd，再通过epoll_ctl将需要监视的socket添加到epfd中，最后调用epoll_wait等待数据。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);   </span><br><span class="line"><span class="built_in">bind</span>(s, ...)</span><br><span class="line"><span class="built_in">listen</span>(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>(...);</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">epoll_wait</span>(...)</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>select低效的另一个原因在于程序不知道哪些socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。如下图所示，计算机共有三个socket，收到数据的sock2和sock3被rdlist（就绪列表）所引用。当进程被唤醒后，只要获取rdlist的内容，就能够知道哪些socket收到数据。</li>
</ul>
<p><img src="/imgs/8727b6a09712ba48bc3aa42bc9a8d91213668b9c71e598c66b38952ac63188f0.png" alt="图 2">  </p>
<h3 id="epoll的原理和流程"><a href="#epoll的原理和流程" class="headerlink" title="epoll的原理和流程"></a>epoll的原理和流程</h3><ul>
<li>创建epoll对象<ul>
<li>如下图所示，当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象（也就是程序中epfd所代表的对象）。eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列。</li>
<li><img src="/imgs/91c0d033282976eae916544255575d9624bb815e6c1035da670e0b290b4bcece.png" alt="图 3">  </li>
<li>创建一个代表该epoll的eventpoll对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为eventpoll的成员。</li>
</ul>
</li>
<li>维护监视列表<ul>
<li>创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket。以添加socket为例，如下图，如果通过epoll_ctl添加sock1、sock2和sock3的监视，内核会将eventpoll添加到这三个socket的等待队列中。</li>
<li><img src="/imgs/8a1343796174bd11a6f73f1b52799e0ed22a766d022325d3d5cf02503a4a3ead.png" alt="图 4">  </li>
<li>当socket收到数据后，中断程序会操作eventpoll对象，而不是直接操作进程。</li>
</ul>
</li>
<li>接收数据<ul>
<li>当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。如下图展示的是sock2和sock3收到数据后，中断程序让rdlist引用这两个socket。</li>
<li><img src="/imgs/cc63dd25307e424248a1d6bea9b932f785332bf7af15817f058b6a2884fd6444.png" alt="图 5">  </li>
<li>eventpoll对象相当于是socket和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。</li>
<li>当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。</li>
</ul>
</li>
</ul>
<h2 id="Channel类"><a href="#Channel类" class="headerlink" title="Channel类"></a>Channel类</h2><ul>
<li>该类主要用于处理服务器用到的<code>epoll</code>的各种事件以及该做出反应</li>
<li>主要内容包括设置各种回调函数的操作函数</li>
<li><code>void SetReadHandle(Callback cb)</code>, <code>void SetWriteHandle(Callback cb)</code>, <code>void SetErrorHandle(Callback cb)</code>, <code>void SetCloseHandle(Callback cb)</code>等</li>
<li>另一个是<code>epoll</code>事件的处理函数，负责检测<code>epoll</code>的<strong>读、写、对方关闭或者连接错误</strong>等情况<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::HandleEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(events_ &amp; EPOLLRDHUP)<span class="comment">//对方异常关闭事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event EPOLLRDHUP&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">closehandler_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(events_ &amp; (EPOLLIN | EPOLLPRI))<span class="comment">//读事件，对端有数据或者正常关闭</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;Event EPOLLIN&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="built_in">readhandler_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(events_ &amp; EPOLLOUT)<span class="comment">//写事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event EPOLLOUT&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">writehandler_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Event error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">errorhandler_</span>();<span class="comment">//连接错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><ul>
<li><p>这个类使用面向对象的方式封装了C传统提供的<code>epoll</code>相关的方法</p>
<h3 id="构造函数-Poller-args"><a href="#构造函数-Poller-args" class="headerlink" title="构造函数 Poller(/* args */)"></a>构造函数 Poller(/* args */)</h3></li>
<li><p>使用初始化列表初始化了一个内容为<code>epoll_event</code>的<code>vector</code>，其中<code>epoll_event</code>的结构体定义为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;	<span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;	<span class="comment">/* User data variable */</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化列表创建了一个映射关系为<code>&lt;int, Channel*&gt;</code>的map对象</p>
</li>
<li><p>然后调用<code>epoll_create</code>函数创建<code>epoll</code>对象， <code>epoll_create(int)</code>函数的参数含义是监听socket的数量</p>
<h3 id="poll-ChannelList-amp-activechannellist"><a href="#poll-ChannelList-amp-activechannellist" class="headerlink" title="poll(ChannelList &amp;activechannellist)"></a>poll(ChannelList &amp;activechannellist)</h3></li>
<li><p>等待IO事件的函数</p>
</li>
<li><p>开始使用<code>epoll_wait</code>函数等待IO事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nfds = <span class="built_in">epoll_wait</span>(pollfd_, &amp;*eventlist_.<span class="built_in">begin</span>(), (<span class="keyword">int</span>)eventlist_.<span class="built_in">capacity</span>(), timeout);</span><br></pre></td></tr></table></figure></li>
<li><p>然后就是从等待得到的事件列表中逐个遍历处理，包括从事件数组中取出数据、寻找数据对应的文件描述符，找到之后通过<code>Channel</code>对象的<code>SetEvents</code>设置事件类型，同时将将其加入<code>activechannellist</code>。如果没找到的话就显示未找到的提示</p>
</li>
<li><p>同时还包括假如事件数组的大小不足的时候进行扩容的部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::poll</span><span class="params">(ChannelList &amp;activechannellist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> timeout = TIMEOUT;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;epoll_wait...&quot; &lt;&lt; std::endl;(int)eventlist_.capacity()</span></span><br><span class="line">    <span class="keyword">int</span> nfds = <span class="built_in">epoll_wait</span>(pollfd_, &amp;*eventlist_.<span class="built_in">begin</span>(), (<span class="keyword">int</span>)eventlist_.<span class="built_in">capacity</span>(), timeout);</span><br><span class="line">    <span class="comment">//int nfds = epoll_wait(pollfd_, &amp;*eventlist_.begin(), (int)channelmap_.size()*0.7+1, timeout);</span></span><br><span class="line">    <span class="keyword">if</span>(nfds == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error code is:%d&quot;</span>, errno);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll wait error&quot;</span>);</span><br><span class="line">        <span class="comment">//exit(1);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;event num:%d\n&quot;, nfds);</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;event num:&quot; &lt;&lt; nfds &lt;&lt; &quot;\n&quot;;// &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> events = eventlist_[i].events;</span><br><span class="line">        <span class="comment">//int fd = eventlist_[i].data.fd;</span></span><br><span class="line">        Channel *pchannel = (Channel*)eventlist_[i].data.ptr;</span><br><span class="line">        <span class="keyword">int</span> fd = pchannel-&gt;<span class="built_in">GetFd</span>();</span><br><span class="line">        <span class="keyword">if</span>(channelmap_.<span class="built_in">find</span>(fd) != channelmap_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            pchannel-&gt;<span class="built_in">SetEvents</span>(events);</span><br><span class="line">            activechannellist.<span class="built_in">push_back</span>(pchannel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;not find channel!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nfds == (<span class="keyword">int</span>)eventlist_.<span class="built_in">capacity</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;resize:&quot;</span> &lt;&lt; nfds &lt;&lt; std::endl;</span><br><span class="line">        eventlist_.<span class="built_in">resize</span>(nfds * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//eventlist_.clear();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AddChannel-Channel-pchannel-、RemoveChannel-Channel-pchannel-、UpdateChannel-Channel-pchannel"><a href="#AddChannel-Channel-pchannel-、RemoveChannel-Channel-pchannel-、UpdateChannel-Channel-pchannel" class="headerlink" title="AddChannel(Channel *pchannel)、RemoveChannel(Channel *pchannel)、UpdateChannel(Channel *pchannel)"></a>AddChannel(Channel *pchannel)、RemoveChannel(Channel *pchannel)、UpdateChannel(Channel *pchannel)</h3></li>
<li><p>三个函数大体的代码逻辑相同，都是利用传入的<code>Channel</code>参数获取文件描述符<code>fd</code>，然后将前文提到的映射的<code>map</code>中相应的对象做出修改。然后使用<code>epoll_ctl</code>修改epoll对其的监视。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::AddChannel</span><span class="params">(Channel *pchannel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = pchannel-&gt;<span class="built_in">GetFd</span>();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = pchannel-&gt;<span class="built_in">GetEvents</span>();</span><br><span class="line">    <span class="comment">//data是联合体</span></span><br><span class="line">    <span class="comment">//ev.data.fd = fd;</span></span><br><span class="line">    ev.data.ptr = pchannel;</span><br><span class="line">    channelmap_[fd] = pchannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(pollfd_, EPOLL_CTL_ADD, fd, &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll add error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;addchannel!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::RemoveChannel</span><span class="params">(Channel *pchannel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = pchannel-&gt;<span class="built_in">GetFd</span>();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = pchannel-&gt;<span class="built_in">GetEvents</span>();</span><br><span class="line">    <span class="comment">///ev.data.fd = fd;</span></span><br><span class="line">    ev.data.ptr = pchannel;</span><br><span class="line">    channelmap_.<span class="built_in">erase</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(pollfd_, EPOLL_CTL_DEL, fd, &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll del error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;removechannel!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Poller::UpdateChannel</span><span class="params">(Channel *pchannel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = pchannel-&gt;<span class="built_in">GetFd</span>();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = pchannel-&gt;<span class="built_in">GetEvents</span>();</span><br><span class="line">    <span class="comment">//ev.data.fd = fd;</span></span><br><span class="line">    ev.data.ptr = pchannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(pollfd_, EPOLL_CTL_MOD, fd, &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;epoll update error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;updatechannel!&quot; &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="epoll结构体的定义"><a href="#epoll结构体的定义" class="headerlink" title="epoll结构体的定义"></a>epoll结构体的定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>events的定义</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>事件宏</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>EPOLLIN</td>
<td>表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</td>
</tr>
<tr>
<td>EPOLLOUT</td>
<td>表示对应的文件描述符可以写</td>
</tr>
<tr>
<td>EPOLLPRI</td>
<td>表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</td>
</tr>
<tr>
<td>EPOLLERR</td>
<td>表示对应的文件描述符发生错误</td>
</tr>
<tr>
<td>EPOLLHUP</td>
<td>表示对应的文件描述符被挂断</td>
</tr>
<tr>
<td>EPOLLET</td>
<td>将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</td>
</tr>
<tr>
<td>EPOLLONESHOT</td>
<td>只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</td>
</tr>
</tbody></table>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><ul>
<li><p>这个类的主要作用是维护一个处理网络事件的循环，将<code>Channel</code>从<code>activechannellist</code>中取出，然后处理事件。</p>
<h3 id="构造函数-EventLoop-args"><a href="#构造函数-EventLoop-args" class="headerlink" title="构造函数 EventLoop(/* args */)"></a>构造函数 EventLoop(/* args */)</h3></li>
<li><p>构造<code>vector&lt;Functor&gt; functorlist_</code>，其中<code>functor</code>是<code>function&lt;void()&gt; Functor</code>，同时还构造两个<code>vector&lt;Channel*&gt; ChannelList</code>的数组对象，再构造一个<code>Poller</code>对象，然后将自身的<code>bool</code>标记置为true。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">EventLoop::<span class="built_in">EventLoop</span>(<span class="comment">/* args */</span>)</span><br><span class="line">    : <span class="built_in">functorlist_</span>(),</span><br><span class="line">    <span class="built_in">channellist_</span>(),</span><br><span class="line">    <span class="built_in">activechannellist_</span>(),</span><br><span class="line">    <span class="built_in">poller_</span>(),</span><br><span class="line">    <span class="built_in">quit</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环函数-EventLoop-loop"><a href="#循环函数-EventLoop-loop" class="headerlink" title="循环函数 EventLoop::loop()"></a>循环函数 EventLoop::loop()</h3></li>
<li><p>主要作用是循环调用前面的<code>epoll</code>类的<code>poll</code>函数，然后从<code>activechannellist</code>中遍历处理每个的事件。然后清空<code>activechannellist</code>，并且执行函数列表里的函数完成任务。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    quit = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!quit)</span><br><span class="line">    &#123;</span><br><span class="line">        poller_.<span class="built_in">poll</span>(activechannellist_);</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;server HandleEvent&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">for</span>(Channel *pchannel : activechannellist_)</span><br><span class="line">        &#123;            </span><br><span class="line">            pchannel-&gt;<span class="built_in">HandleEvent</span>();<span class="comment">//处理事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        activechannellist_.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">ExecuteTask</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TcpServer"><a href="#TcpServer" class="headerlink" title="TcpServer"></a>TcpServer</h2><ul>
<li><p><a target="_blank" rel="noopener" href="http://naotu.baidu.com/file/1c993feb2c86cb9e3caf273d19c9d54d?token=f68ea843fc2470f4">成员对象以及函数思维导图</a></p>
</li>
<li><p>注册业务函数函数指针的部分<em>在此处略去</u></em></p>
</li>
</ul>
<h3 id="构造函数-TcpServer-EventLoop-loop-int-port"><a href="#构造函数-TcpServer-EventLoop-loop-int-port" class="headerlink" title="构造函数 TcpServer(EventLoop* loop, int port)"></a>构造函数 TcpServer(EventLoop* loop, int port)</h3><ul>
<li>利用初始化列表初始化<code>Socket</code>的<code>Serversocket</code>对象，初始化循环体<code>loop</code>对象，初始化<code>Channel</code>类型的<code>serverchannel</code>对象，初始化链接计数<code>conncount</code>对象</li>
<li><code>serversocket</code>分别进行<code>SetReuseAddr()</code>、<code>BindAddress(port)</code>, <code>Listen()</code>, <code>Setnonblocking()</code></li>
<li><code>serverchannel_</code>初始化并且设置<code>ReadHandle</code>和<code>ErrorHandle</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop* loop, <span class="keyword">int</span> port)</span><br><span class="line">    : <span class="built_in">serversocket_</span>(),</span><br><span class="line">    <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">serverchannel_</span>(),</span><br><span class="line">    <span class="built_in">conncount_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//serversocket_.SetSocketOption(); </span></span><br><span class="line">    serversocket_.<span class="built_in">SetReuseAddr</span>();   </span><br><span class="line">    serversocket_.<span class="built_in">BindAddress</span>(port);</span><br><span class="line">    serversocket_.<span class="built_in">Listen</span>();</span><br><span class="line">    serversocket_.<span class="built_in">Setnonblocking</span>();</span><br><span class="line"></span><br><span class="line">    serverchannel_.<span class="built_in">SetFd</span>(serversocket_.<span class="built_in">fd</span>());</span><br><span class="line">    serverchannel_.<span class="built_in">SetReadHandle</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::OnNewConnection, <span class="keyword">this</span>));</span><br><span class="line">    serverchannel_.<span class="built_in">SetErrorHandle</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::OnConnectionError, <span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Start-函数"><a href="#Start-函数" class="headerlink" title="Start()函数"></a>Start()函数</h3></li>
<li>设置channel的events，同时将channel添加到循环loop中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    serverchannel_.<span class="built_in">SetEvents</span>(EPOLLIN | EPOLLET);</span><br><span class="line">    loop_-&gt;<span class="built_in">AddChannelToPoller</span>(&amp;serverchannel_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="建立新连接的处理函数"><a href="#建立新连接的处理函数" class="headerlink" title="建立新连接的处理函数"></a>建立新连接的处理函数</h3><ul>
<li>主要功能是接受客户端的连接请求，然后利用接收到的文件描述符创建新的控制链接的成员对象，注册业务函数并且完成调用。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新TCP连接处理,核心功能，业务功能注册，任务分发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::OnNewConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//循环调用accept，获取所有的建立好连接的客户端fd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> clientfd;</span><br><span class="line">    <span class="keyword">while</span>( (clientfd = serversocket_.<span class="built_in">Accept</span>(clientaddr)) &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;New client from IP:&quot; &lt;&lt; inet_ntoa(clientaddr.sin_addr) </span></span><br><span class="line">        <span class="comment">//    &lt;&lt; &quot;:&quot; &lt;&lt; ntohs(clientaddr.sin_port) &lt;&lt; std::endl;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(++conncount_ &gt;= MAXCONNECTION)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(clientfd);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Setnonblocking</span>(clientfd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接，注册业务函数</span></span><br><span class="line">        TcpConnection *ptcpconnection = <span class="keyword">new</span> <span class="built_in">TcpConnection</span>(loop_, clientfd, clientaddr);</span><br><span class="line">        ptcpconnection-&gt;<span class="built_in">SetMessaeCallback</span>(messagecallback_);</span><br><span class="line">        ptcpconnection-&gt;<span class="built_in">SetSendCompleteCallback</span>(sendcompletecallback_);</span><br><span class="line">        ptcpconnection-&gt;<span class="built_in">SetCloseCallback</span>(closecallback_);</span><br><span class="line">        ptcpconnection-&gt;<span class="built_in">SetErrorCallback</span>(errorcallback_);</span><br><span class="line">        ptcpconnection-&gt;<span class="built_in">SetConnectionCleanUp</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::RemoveConnection, <span class="keyword">this</span>, ptcpconnection));</span><br><span class="line">        tcpconnlist_[clientfd] = ptcpconnection;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">newconnectioncallback_</span>(ptcpconnection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RemoveConnection-TcpConnection-ptcpconnection"><a href="#RemoveConnection-TcpConnection-ptcpconnection" class="headerlink" title="RemoveConnection(TcpConnection *ptcpconnection)"></a>RemoveConnection(TcpConnection *ptcpconnection)</h3><ul>
<li>连接断开的操作<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//连接清理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::RemoveConnection</span><span class="params">(TcpConnection *ptcpconnection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     --conncount_;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;clean up connection, conncount is&quot; &lt;&lt; conncount_ &lt;&lt; std::endl;   </span></span><br><span class="line">    tcpconnlist_.<span class="built_in">erase</span>(ptcpconnection-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    <span class="keyword">delete</span> ptcpconnection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="OnConnectionError"><a href="#OnConnectionError" class="headerlink" title="OnConnectionError()"></a>OnConnectionError()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::OnConnectionError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UNKNOWN EVENT&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    serversocket_.<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Setnonblocking-int-fd"><a href="#Setnonblocking-int-fd" class="headerlink" title="Setnonblocking(int fd)"></a>Setnonblocking(int fd)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span> (opts &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(fd,GETFL)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fcntl</span>(fd, F_SETFL, opts | O_NONBLOCK) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(fd,SETFL,opts)&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-分析基于epoll的C-高性能webServer代码（二）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/29/%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84C-%E9%AB%98%E6%80%A7%E8%83%BDwebServer%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/"
    >分析基于epoll的C++高性能webServer代码（二）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/29/%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84C-%E9%AB%98%E6%80%A7%E8%83%BDwebServer%E4%BB%A3%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2022-06-29T04:43:03.000Z" itemprop="datePublished">2022-06-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="分析基于epoll的C-高性能webServer代码（二）"><a href="#分析基于epoll的C-高性能webServer代码（二）" class="headerlink" title="分析基于epoll的C++高性能webServer代码（二）"></a>分析基于epoll的C++高性能webServer代码（二）</h1><h2 id="C-bind-函数用法"><a href="#C-bind-函数用法" class="headerlink" title="C++bind()函数用法"></a>C++<code>bind()</code>函数用法</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dongkun152/article/details/123992292">参考链接</a></p>
</li>
<li><p>std::bind()函数作为<strong>函数的适配器</strong>，它可以<strong>扩大函数是使用场合</strong>，使得函数更加灵活的被使用。<br>template&lt;class F, class… Args&gt;</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span>(F&amp;&amp;f, Args&amp;&amp;… args);</span><br></pre></td></tr></table></figure>

<ul>
<li>参数：<br>f 可以是function object，函数指针，函数引用，成员函数指针，或者数据成员的指针。</li>
<li>返回值：<br>function object</li>
</ul>
<h3 id="可以用std-placeholders-1等替换函数本身的输入参数"><a href="#可以用std-placeholders-1等替换函数本身的输入参数" class="headerlink" title="可以用std::placeholders::_1等替换函数本身的输入参数"></a>可以用<code>std::placeholders::_1</code>等替换函数本身的输入参数</h3><ul>
<li>举例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; (a -b -c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fn1 = <span class="built_in">bind</span>(func, _1, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">auto</span> fn2 = <span class="built_in">bind</span>(func, <span class="number">2</span>, _1, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fn1</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">fn2</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">-11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意上面的三输入函数<code>func</code>使用<code>bind</code>替换掉了其中的两个输入参数，仅仅在<code>placeholder</code>的位置提供一个输入</li>
<li>注意，当具有多个输入的时候，输入的顺序是按照<code>std::placeholders::_1</code>、<code>std::placeholders::_2</code>、<code>std::placeholders::_3</code>等的顺序</li>
<li>举例：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; (a - b -c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fn1= <span class="built_in">bind</span>(func, _2, <span class="number">2</span>, _1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the value of function is :&quot;</span>;</span><br><span class="line">    <span class="built_in">fn1</span>(<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn2 = <span class="built_in">bind</span>(func, _1, <span class="number">2</span>, _2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the value of function after changing placeholder position is :&quot;</span>;</span><br><span class="line">    <span class="built_in">fn2</span>(<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">the value of function is :10</span></span><br><span class="line"><span class="comment">the value of function after changing placeholder position is :-14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意上面的函数中，fn1的实际输入到func中的参数是<code>func(13, 2, 1)</code>，而输入到fn2中的参数实际上是<code>func(1, 2, 13)</code></li>
</ul>
<h2 id="httpServer的成员函数分析"><a href="#httpServer的成员函数分析" class="headerlink" title="httpServer的成员函数分析"></a>httpServer的成员函数分析</h2><ul>
<li><a target="_blank" rel="noopener" href="http://naotu.baidu.com/file/5affaf781a1d7a139d281fba48af613a?token=e03c48870d07da80">类结构思维导图</a></li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>使用初始化列表初始化成员<code>tcpserver_</code>，然后将<code>tcpserver_</code>的函数接口全部初始化为HttpServer提供的处理函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HttpServer::<span class="built_in">HttpServer</span>(EventLoop *loop, <span class="keyword">int</span> port)</span><br><span class="line">    : <span class="built_in">tcpserver_</span>(loop, port),</span><br><span class="line">    <span class="built_in">cnt</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    tcpserver_.<span class="built_in">SetNewConnCallback</span>(std::<span class="built_in">bind</span>(&amp;HttpServer::HandleNewConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    tcpserver_.<span class="built_in">SetMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;HttpServer::HandleMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2));</span><br><span class="line">    tcpserver_.<span class="built_in">SetSendCompleteCallback</span>(std::<span class="built_in">bind</span>(&amp;HttpServer::HandleSendComplete, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    tcpserver_.<span class="built_in">SetCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;HttpServer::HandleClose, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    tcpserver_.<span class="built_in">SetErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;HttpServer::HandleError, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HandleNewConnection-TcpConnection-ptcpconn"><a href="#HandleNewConnection-TcpConnection-ptcpconn" class="headerlink" title="HandleNewConnection(TcpConnection *ptcpconn)"></a>HandleNewConnection(TcpConnection *ptcpconn)</h3><ul>
<li>处理新建立的http连接请求</li>
<li>新建一个<code>HttpSession</code>对象</li>
<li>将该对象放入<code>httpsessionlist_</code>中(<code>httpsessionlist_</code>是一个map，通过TcpConnection映射到httpSession对象)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpServer::HandleNewConnection</span><span class="params">(TcpConnection *ptcpconn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::string msg(s);</span></span><br><span class="line">    HttpSession *phttpsession = <span class="keyword">new</span> <span class="built_in">HttpSession</span>();</span><br><span class="line">    httpsessionnlist_[ptcpconn] = phttpsession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HandleMessage-TcpConnection-ptcpconn-std-string-amp-s"><a href="#HandleMessage-TcpConnection-ptcpconn-std-string-amp-s" class="headerlink" title="HandleMessage(TcpConnection *ptcpconn, std::string &amp;s)"></a>HandleMessage(TcpConnection *ptcpconn, std::string &amp;s)</h3><ul>
<li>调用<code>httpsessionlist_</code>中的对象处理信息</li>
<li>将同样的数据发送回发送方（回显）</li>
<li>处理短链接问题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpServer::HandleMessage</span><span class="params">(TcpConnection *ptcpconn, std::string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;http num is:&quot; &lt;&lt; ++cnt &lt;&lt; std::endl;   </span></span><br><span class="line">    HttpSession *phttpsession =  httpsessionnlist_[ptcpconn];</span><br><span class="line">    phttpsession-&gt;<span class="built_in">PraseHttpRequest</span>(s);</span><br><span class="line">    phttpsession-&gt;<span class="built_in">HttpProcess</span>();</span><br><span class="line">    std::string msg;</span><br><span class="line">    phttpsession-&gt;<span class="built_in">AddToBuf</span>(msg);</span><br><span class="line">    ptcpconn-&gt;<span class="built_in">Send</span>(msg);</span><br><span class="line">    <span class="keyword">if</span>(!phttpsession-&gt;<span class="built_in">KeepAlive</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//短连接，可以告诉框架层数据发完就可以关掉TCP连接，不过这里注释掉，还是交给客户端主动关闭吧</span></span><br><span class="line">        <span class="comment">//ptcpconn-&gt;HandleClose();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>HttpProcess()</code>的行为：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpSession::HttpProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;GET&quot;</span> == httprequestcontext_.method)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;POST&quot;</span> == httprequestcontext_.method)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;HttpServer::HttpParser&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        errormsg = <span class="string">&quot;Method Not Implemented&quot;</span>;</span><br><span class="line">        <span class="built_in">HttpError</span>(<span class="number">501</span>, <span class="string">&quot;Method Not Implemented&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos = httprequestcontext_.url.<span class="built_in">find</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos != std::string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        path_ = httprequestcontext_.url.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">        querystring_ = httprequestcontext_.url.<span class="built_in">substr</span>(pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        path_ = httprequestcontext_.url;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//keepalive判断处理</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt;::const_iterator iter = httprequestcontext_.header.<span class="built_in">find</span>(<span class="string">&quot;Connection&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(iter != httprequestcontext_.header.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        keepalive_ = (iter-&gt;second == <span class="string">&quot;Keep-Alive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(httprequestcontext_.version == <span class="string">&quot;HTTP/1.1&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            keepalive_ = <span class="literal">true</span>;<span class="comment">//HTTP/1.1默认长连接</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            keepalive_ = <span class="literal">false</span>;<span class="comment">//HTTP/1.0默认短连接</span></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    responsebody_.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span> == path_)</span><br><span class="line">    &#123;        </span><br><span class="line">        path_ = <span class="string">&quot;/index.html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;/hello&quot;</span> == path_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Wenbbench 测试用</span></span><br><span class="line">        std::string <span class="built_in">filetype</span>(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        responsebody_ = (<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        responsecontext_ += httprequestcontext_.version + <span class="string">&quot; 200 OK\r\n&quot;</span>;</span><br><span class="line">        responsecontext_ += <span class="string">&quot;Server: Chen Shuaihao&#x27;s NetServer/0.1\r\n&quot;</span>;</span><br><span class="line">        responsecontext_ += <span class="string">&quot;Content-Type: &quot;</span> + filetype + <span class="string">&quot;; charset=utf-8\r\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(iter != httprequestcontext_.header.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            responsecontext_ += <span class="string">&quot;Connection: &quot;</span> + iter-&gt;second + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        responsecontext_ += <span class="string">&quot;Content-Length: &quot;</span> + std::<span class="built_in">to_string</span>(responsebody_.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        responsecontext_ += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        responsecontext_ += responsebody_;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::string responsebody;    </span></span><br><span class="line">    path_.<span class="built_in">insert</span>(<span class="number">0</span>,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    FILE* fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>((fp = <span class="built_in">fopen</span>(path_.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//perror(&quot;error fopen&quot;);</span></span><br><span class="line">        <span class="comment">//404 NOT FOUND</span></span><br><span class="line">        <span class="built_in">HttpError</span>(<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">fread</span>(buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer), <span class="number">1</span>, fp) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            responsebody_.<span class="built_in">append</span>(buffer);</span><br><span class="line">            <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">feof</span>(fp))</span><br><span class="line">        &#123;</span><br><span class="line">            responsebody_.<span class="built_in">append</span>(buffer);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;error fread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;        	</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">filetype</span><span class="params">(<span class="string">&quot;text/html&quot;</span>)</span></span>; <span class="comment">//暂时固定为html</span></span><br><span class="line">    responsecontext_ += httprequestcontext_.version + <span class="string">&quot; 200 OK\r\n&quot;</span>;</span><br><span class="line">    responsecontext_ += <span class="string">&quot;Server: Chen Shuaihao&#x27;s NetServer/0.1\r\n&quot;</span>;</span><br><span class="line">    responsecontext_ += <span class="string">&quot;Content-Type: &quot;</span> + filetype + <span class="string">&quot;; charset=utf-8\r\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(iter != httprequestcontext_.header.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        responsecontext_ += <span class="string">&quot;Connection: &quot;</span> + iter-&gt;second + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    responsecontext_ += <span class="string">&quot;Content-Length: &quot;</span> + std::<span class="built_in">to_string</span>(responsebody_.<span class="built_in">size</span>()) + <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    responsecontext_ += <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    responsecontext_ += responsebody_;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HttpServer-HandleClose-TcpConnection-ptcpconn"><a href="#HttpServer-HandleClose-TcpConnection-ptcpconn" class="headerlink" title="HttpServer::HandleClose(TcpConnection *ptcpconn)"></a>HttpServer::HandleClose(TcpConnection *ptcpconn)</h2><ul>
<li>通过传入的参数<code>TcpConnecton</code>和map映射找到对应的<code>httpSession</code></li>
<li>将<code>httpSession</code>从列表中删除</li>
<li>释放<code>httpSession</code>占用的内存空间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpServer::HandleClose</span><span class="params">(TcpConnection *ptcpconn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpSession *phttpsession = httpsessionnlist_[ptcpconn];</span><br><span class="line">    httpsessionnlist_.<span class="built_in">erase</span>(ptcpconn);</span><br><span class="line">    <span class="keyword">delete</span> phttpsession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HttpServer-HandleError-TcpConnection-ptcpconn"><a href="#HttpServer-HandleError-TcpConnection-ptcpconn" class="headerlink" title="HttpServer::HandleError(TcpConnection *ptcpconn)"></a>HttpServer::HandleError(TcpConnection *ptcpconn)</h2><ul>
<li>删除对应的<code>httpSession</code>同上</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpServer::HandleError</span><span class="params">(TcpConnection *ptcpconn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpSession *phttpsession = httpsessionnlist_[ptcpconn];</span><br><span class="line">    httpsessionnlist_.<span class="built_in">erase</span>(ptcpconn);</span><br><span class="line">    <span class="keyword">delete</span> phttpsession;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HttpServer-Start"><a href="#HttpServer-Start" class="headerlink" title="HttpServer::Start()"></a>HttpServer::Start()</h2><ul>
<li>直接调用内部的<code>tcpserver</code>成员的<code>start</code>函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpServer::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tcpserver_.<span class="built_in">Start</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-分析基于epoll的C-高性能webServer代码"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/29/%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84C-%E9%AB%98%E6%80%A7%E8%83%BDwebServer%E4%BB%A3%E7%A0%81/"
    >分析基于epoll的C++高性能webServer代码（一）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/29/%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8Eepoll%E7%9A%84C-%E9%AB%98%E6%80%A7%E8%83%BDwebServer%E4%BB%A3%E7%A0%81/" class="article-date">
  <time datetime="2022-06-29T03:24:54.000Z" itemprop="datePublished">2022-06-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="分析基于epoll的C-高性能webServer代码（一）"><a href="#分析基于epoll的C-高性能webServer代码（一）" class="headerlink" title="分析基于epoll的C++高性能webServer代码（一）"></a>分析基于epoll的C++高性能webServer代码（一）</h1><h2 id="std-function用法"><a href="#std-function用法" class="headerlink" title="std::function用法"></a>std::function用法</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35721743/article/details/83217416?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3-83217416-blog-123063589.pc_relevant_blogantidownloadv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3-83217416-blog-123063589.pc_relevant_blogantidownloadv1&utm_relevant_index=5">参考链接</a>  <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/utility/functional/function">cpp官方reference</a></li>
<li>类模板<code>std :: function</code>是一个通用的<strong>多态函数包装器</strong>。 <code>std :: function</code>的实例可以存储，复制和调用任何可调用的目标 ：包括函数，lambda表达式，绑定表达式或其他函数对象，以及指向成员函数和指向数据成员的指针。当<code>std::function</code>对象未包裹任何实际的可调用元素，调用该<code>std::function</code>对象将抛出<code>std::bad_function_call</code>异常。</li>
</ul>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><table>
<thead>
<tr>
<th>成员函数声明</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>constructor</td>
<td>构造函数：constructs a new std::function instance</td>
</tr>
<tr>
<td>destructor</td>
<td>析构函数： destroys a std::function instance</td>
</tr>
<tr>
<td>operator=</td>
<td>给定义的function对象赋值</td>
</tr>
<tr>
<td>operator bool</td>
<td>检查定义的function对象是否包含一个有效的对象</td>
</tr>
<tr>
<td>operator()</td>
<td>调用一个对象</td>
</tr>
</tbody></table>
<h3 id="使用例"><a href="#使用例" class="headerlink" title="使用例"></a>使用例</h3><ul>
<li>调用普通函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;func = f;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>)&lt;&lt;endl;      <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>调用模板函数对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function object</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">functor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   functor ft;</span><br><span class="line">   function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; func = ft&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">   cout&lt;&lt;<span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;    <span class="comment">//3</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用lambda表达式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> f = [](<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">	std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;func = f;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;      <span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="epoll原理以及讲解"><a href="#epoll原理以及讲解" class="headerlink" title="epoll原理以及讲解"></a>epoll原理以及讲解</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/haogenmin/article/details/118527213">参考网页</a> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/63179839">知乎原文</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-pytorch训练的模型导出数据或者部署到C-平台"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/28/pytorch%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E6%88%96%E8%80%85%E9%83%A8%E7%BD%B2%E5%88%B0C-%E5%B9%B3%E5%8F%B0/"
    >pytorch训练的模型导出数据或者部署到C++平台</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/28/pytorch%E8%AE%AD%E7%BB%83%E7%9A%84%E6%A8%A1%E5%9E%8B%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E6%88%96%E8%80%85%E9%83%A8%E7%BD%B2%E5%88%B0C-%E5%B9%B3%E5%8F%B0/" class="article-date">
  <time datetime="2022-06-28T13:45:47.000Z" itemprop="datePublished">2022-06-28</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="pytorch训练的模型导出网格数据或者部署到C-平台"><a href="#pytorch训练的模型导出网格数据或者部署到C-平台" class="headerlink" title="pytorch训练的模型导出网格数据或者部署到C++平台"></a>pytorch训练的模型导出网格数据或者部署到C++平台</h1><h2 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h2><ul>
<li>导出为<code>.csv</code>文件</li>
<li>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42464527/article/details/123688909">教程</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义和实例化网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>,<span class="number">30</span>,kernel_size=<span class="number">5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">4320</span>,<span class="number">100</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)),<span class="number">2</span>)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">4320</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x,dim=<span class="number">1</span>)</span><br><span class="line">network = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存.csv格式的参数</span></span><br><span class="line"><span class="keyword">for</span> name,param <span class="keyword">in</span> network.named_parameters():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;name:<span class="subst">&#123;name&#125;</span>\t\t\t,shape:<span class="subst">&#123;param.shape&#125;</span>&quot;</span>)</span><br><span class="line">    data = pd.DataFrame(param.detach().numpy().reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">    filename = <span class="string">f&quot;<span class="subst">&#123;name&#125;</span>.csv&quot;</span></span><br><span class="line">    data.to_csv(<span class="string">f&quot;./<span class="subst">&#123;filename&#125;</span>&quot;</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>, sep=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用Libtorch直接导出C-模型"><a href="#使用Libtorch直接导出C-模型" class="headerlink" title="使用Libtorch直接导出C++模型"></a>使用Libtorch直接导出C++模型</h2><ul>
<li><p>参考 csdn<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43917589/article/details/124509964">文章</a></p>
</li>
<li><p>参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/263626686?ivk_sa=1024320u">知乎文章</a> 和 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/146453159">文章</a></p>
</li>
<li><p>部署 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40198848/article/details/112872844?spm=1001.2014.3001.5506">yoloV5</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://pytorch.org/tutorials/advanced/cpp_export.html">官方教程</a></p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-python多线程以及线程同步"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/28/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"
    >python多线程以及线程同步</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/28/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="article-date">
  <time datetime="2022-06-28T01:22:29.000Z" itemprop="datePublished">2022-06-28</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="python多线程以及线程同步"><a href="#python多线程以及线程同步" class="headerlink" title="python多线程以及线程同步"></a>python多线程以及线程同步</h1><h2 id="多线程基础知识"><a href="#多线程基础知识" class="headerlink" title="多线程基础知识"></a>多线程基础知识</h2><ul>
<li>python创建多线程主要依靠threading库</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br></pre></td></tr></table></figure>

<ul>
<li>线程的创建使用<code>Thread()</code>函数，提供的参数为线程的函数指针和函数的参数（必须为可迭代的对象）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">t1=threading.Thread(target=task, args=(<span class="number">3</span>,)) <span class="comment"># 注意此处不能使用args=(3)，否则会因为传入的参数不可迭代导致错误，必须加逗号</span></span><br></pre></td></tr></table></figure>

<ul>
<li>线程的开始使用<code>start()</code>，使用<code>join()</code>回收线程</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多线程</span></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回收线程</span></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">t3.join()</span><br></pre></td></tr></table></figure>

<h2 id="多线程时间测试"><a href="#多线程时间测试" class="headerlink" title="多线程时间测试"></a>多线程时间测试</h2><ul>
<li>线程执行任务为控制台输出的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">t1=threading.Thread(target=task, args=(<span class="number">3</span>,))</span><br><span class="line">t2=threading.Thread(target=task, args=(<span class="number">3</span>,))</span><br><span class="line">t3=threading.Thread(target=task, args=(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回收线程</span></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">t3.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;多线程用时:%.8f\n&quot;</span>%(time.time()-start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单线程</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    task(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;单线程用时:%.8f\n&quot;</span>%(end-start))</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src="/imgs/image-20220628093137346.png" alt="image-20220628093137346"></p>
<ul>
<li>可见，多线程用时还更多一些</li>
</ul>
</li>
<li><p>多线程执行不涉及IO的操作（比如加法）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">num</span>):</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        count+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">t1=threading.Thread(target=task, args=(<span class="number">3</span>,))</span><br><span class="line">t2=threading.Thread(target=task, args=(<span class="number">3</span>,))</span><br><span class="line">t3=threading.Thread(target=task, args=(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多线程</span></span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回收线程</span></span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">t3.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;多线程用时:%.8f\n&quot;</span>%(time.time()-start))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单线程</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    task(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;单线程用时:%.8f\n&quot;</span>%(end-start))</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果为<ul>
<li><img src="/imgs/image-20220628093356210.png" alt="image-20220628093356210"></li>
<li>可见，单线程比多线程的优势更明显了</li>
</ul>
</li>
</ul>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li><p>你会发现多线程比单线程花费的时间还要更多，这是因为GIL的原因。</p>
<p>GIL的全称是Global Interpreter Lock（全局解释器锁），Python最初的设计理念在于，<u>为了解决多线程之间数据完整性和状态同步的问题，设计为在任意时刻只能由一个线程在解释器中运行</u>。因此Python中的多线程是<strong>表面上的多线程</strong>（同一时刻只有一个线程），不是真正的多线程。</p>
<p>但是如果是因为GIL的原因，就说多线程无用是不对的，对于IO密集的程序，多线程是要比单线程快的。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1715829331938364561&wfr=spider&for=pc">参考链接</a></p>
</li>
</ul>
<h2 id="python线程同步"><a href="#python线程同步" class="headerlink" title="python线程同步"></a>python线程同步</h2><ul>
<li>python线程同步具有一些与C类似的机制，比如各种锁和获取、释放锁等等</li>
<li><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1714105650396326932&wfr=spider&for=pc">参考链接</a></li>
</ul>
<h3 id="同步锁Lock"><a href="#同步锁Lock" class="headerlink" title="同步锁Lock"></a>同步锁Lock</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line">lock.acquire()</span><br><span class="line">lock.release()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用于保护临界区</p>
</li>
<li><p>由于<code>threading.Lock()</code>对象中实现了<strong>enter__()与__exit</strong>()方法，故我们可以使用<strong>with语句</strong>进行上下文管理形式的加锁解锁操作</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> lock:</span><br><span class="line">    <span class="comment"># 自动加锁</span></span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10_000_000</span>):</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 自动解锁</span></span><br></pre></td></tr></table></figure>

<h3 id="RLock-递归锁"><a href="#RLock-递归锁" class="headerlink" title="RLock() 递归锁"></a>RLock() 递归锁</h3><ul>
<li><p>递归锁是同步锁的一个升级版本，在同步锁的基础上可以做到连续重复使用多次acquire()后再重复使用多次release()的操作，但是一定要注意加锁次数和解锁次数必须一致，否则也将引发死锁现象。</p>
</li>
<li><p>其他部分类似，不再详细赘述</p>
</li>
</ul>
<h3 id="Condition-条件锁"><a href="#Condition-条件锁" class="headerlink" title="Condition() 条件锁"></a>Condition() 条件锁</h3><ul>
<li><p>条件锁是在递归锁的基础上增加了能够暂停线程运行的功能。并且我们可以使用wait()与notify()来控制线程执行的个数。</p>
<p>注意：条件锁可以自由设定一次放行几个线程。</p>
</li>
<li><p><img src="/imgs/838ba61ea8d3fd1fc946d753909e6e1694ca5f61.jpeg" alt="img"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">currentRunThreadNumber = <span class="number">0</span></span><br><span class="line">maxSubThreadNumber = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> currentRunThreadNumber</span><br><span class="line">    thName = threading.currentThread().name</span><br><span class="line"></span><br><span class="line">    condLock.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start and wait run thread : %s&quot;</span> % thName)</span><br><span class="line"></span><br><span class="line">    condLock.wait()  <span class="comment"># 暂停线程运行、等待唤醒</span></span><br><span class="line">    currentRunThreadNumber += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;carry on run thread : %s&quot;</span> % thName)</span><br><span class="line"></span><br><span class="line">    condLock.release()  <span class="comment"># 解锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    condLock = threading.Condition()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxSubThreadNumber):</span><br><span class="line">        subThreadIns = threading.Thread(target=task)</span><br><span class="line">        subThreadIns.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> currentRunThreadNumber &lt; maxSubThreadNumber:</span><br><span class="line">        notifyNumber = <span class="built_in">int</span>(</span><br><span class="line">            <span class="built_in">input</span>(<span class="string">&quot;Please enter the number of threads that need to be notified to run：&quot;</span>))</span><br><span class="line"></span><br><span class="line">        condLock.acquire()</span><br><span class="line">        condLock.notify(notifyNumber)  <span class="comment"># 放行</span></span><br><span class="line">        condLock.release()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main thread run end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先启动10个子线程，然后这些子线程会全部变为等待状态</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-1</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-2</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-3</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-4</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-5</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-6</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-7</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-8</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-9</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量发送通知，放行特定数量的子线程继续运行</span></span><br><span class="line"><span class="comment"># Please enter the number of threads that need to be notified to run：5  # 放行5个</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-4</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-3</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-1</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-2</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter the number of threads that need to be notified to run：5  # 放行5个</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-8</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-10</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-6</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-9</span></span><br><span class="line"><span class="comment"># carry on run thread : Thread-7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter the number of threads that need to be notified to run：1</span></span><br><span class="line"><span class="comment"># main thread run end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意，上面的代码中的线程在使用<code>acquire()</code>获取锁之后，进入了休眠状态（也就是<code>wait()</code>），然后等待锁的<code>notify()</code>函数<strong>唤醒相应数量的正在休眠的进程</strong></li>
</ul>
<h3 id="Event-事件锁"><a href="#Event-事件锁" class="headerlink" title="Event() 事件锁"></a>Event() 事件锁</h3><ul>
<li><p>事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。</p>
<p>我们可以将事件锁看为红绿灯，当红灯时所有子线程都暂停运行，并进入“等待”状态，当绿灯时所有子线程都恢复“运行”。</p>
</li>
<li><p><img src="/imgs/b3fb43166d224f4ae902e4228a27db5b9922d146.jpeg" alt="img"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">maxSubThreadNumber = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    thName = threading.currentThread().name    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start and wait run thread : %s&quot;</span> % thName)    </span><br><span class="line">    eventLock.wait()  <span class="comment"># 暂停运行，等待绿灯    </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;green light, %s carry on run&quot;</span> % thName)    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;red light, %s stop run&quot;</span> % thName)    </span><br><span class="line">    eventLock.wait()  <span class="comment"># 暂停运行，等待绿灯    </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;green light, %s carry on run&quot;</span> % thName)    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sub thread %s run end&quot;</span> % thName)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:    </span><br><span class="line">    eventLock = threading.Event()    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxSubThreadNumber):        </span><br><span class="line">        subThreadIns = threading.Thread(target=task)        </span><br><span class="line">        subThreadIns.start()    </span><br><span class="line">        eventLock.<span class="built_in">set</span>()  <span class="comment"># 设置为绿灯    </span></span><br><span class="line">        eventLock.clear()  <span class="comment"># 设置为红灯    </span></span><br><span class="line">        eventLock.<span class="built_in">set</span>()  <span class="comment"># 设置为绿灯</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-1</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-2</span></span><br><span class="line"><span class="comment"># start and wait run thread : Thread-3</span></span><br><span class="line"><span class="comment"># green light, Thread-1 carry on run</span></span><br><span class="line"><span class="comment"># red light, Thread-1 stop run</span></span><br><span class="line"><span class="comment"># green light, Thread-1 carry on run</span></span><br><span class="line"><span class="comment"># sub thread Thread-1 run end</span></span><br><span class="line"><span class="comment"># green light, Thread-3 carry on run</span></span><br><span class="line"><span class="comment"># red light, Thread-3 stop run</span></span><br><span class="line"><span class="comment"># green light, Thread-3 carry on run</span></span><br><span class="line"><span class="comment"># sub thread Thread-3 run end</span></span><br><span class="line"><span class="comment"># green light, Thread-2 carry on run</span></span><br><span class="line"><span class="comment"># red light, Thread-2 stop run</span></span><br><span class="line"><span class="comment"># green light, Thread-2 carry on run</span></span><br><span class="line"><span class="comment"># sub thread Thread-2 run end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>不能使用<code>with</code>语句进行调用</strong></li>
</ul>
<h3 id="Semaphore-信号量锁"><a href="#Semaphore-信号量锁" class="headerlink" title="Semaphore() 信号量锁"></a>Semaphore() 信号量锁</h3><ul>
<li><p>信号量锁也是根据条件锁来做的，它与条件锁和事件锁的区别如下：</p>
<ul>
<li>条件锁：一次可以放行任意个处于“等待”状态的线程</li>
<li>事件锁：一次可以放行全部的处于“等待”状态的线程</li>
<li>信号量锁：通过规定，成批的放行<strong>特定个处于“上锁”状态的线程</strong></li>
</ul>
</li>
<li><p><img src="/imgs/0b55b319ebc4b74555e89af84b2c551e8b82153c.jpeg" alt="img"></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">maxSubThreadNumber = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    thName = threading.currentThread().name</span><br><span class="line">    semaLock.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;run sub thread %s&quot;</span> % thName)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    semaLock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 每次只能放行2个</span></span><br><span class="line">    semaLock = threading.Semaphore(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxSubThreadNumber):</span><br><span class="line">        subThreadIns = threading.Thread(target=task)</span><br><span class="line">        subThreadIns.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># run sub thread Thread-1</span></span><br><span class="line"><span class="comment"># run sub thread Thread-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run sub thread Thread-3</span></span><br><span class="line"><span class="comment"># run sub thread Thread-4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run sub thread Thread-6</span></span><br><span class="line"><span class="comment"># run sub thread Thread-5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意调用<code>Semaphore()</code>初始化的时候传递参数<strong>指定同时能够放行的线程数量</strong></li>
<li>也可以使用<code>with</code>语句</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">maxSubThreadNumber = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    thName = threading.currentThread().name</span><br><span class="line">    <span class="keyword">with</span> semaLock:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;run sub thread %s&quot;</span> % thName)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    semaLock = threading.Semaphore(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxSubThreadNumber):</span><br><span class="line">        subThreadIns = threading.Thread(target=task)</span><br><span class="line">        subThreadIns.start()</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-WSL2上使用matplotlib结合VSCode远程不显示输出的解决方法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/27/WSL2%E4%B8%8A%E4%BD%BF%E7%94%A8matplotlib%E7%BB%93%E5%90%88VSCode%E8%BF%9C%E7%A8%8B%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"
    >WSL2上使用matplotlib结合VSCode远程不显示输出的解决方法</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/27/WSL2%E4%B8%8A%E4%BD%BF%E7%94%A8matplotlib%E7%BB%93%E5%90%88VSCode%E8%BF%9C%E7%A8%8B%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%BE%93%E5%87%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="article-date">
  <time datetime="2022-06-27T05:21:29.000Z" itemprop="datePublished">2022-06-27</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="WSL2上使用matplotlib结合VSCode远程不显示输出的解决方法"><a href="#WSL2上使用matplotlib结合VSCode远程不显示输出的解决方法" class="headerlink" title="WSL2上使用matplotlib结合VSCode远程不显示输出的解决方法"></a>WSL2上使用matplotlib结合VSCode远程不显示输出的解决方法</h1><h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><h3 id="问题一般分为两种"><a href="#问题一般分为两种" class="headerlink" title="问题一般分为两种"></a>问题一般分为两种</h3><ul>
<li>没有报错但是使用<code>plt.show()</code>之后<strong>没有任何输出</strong></li>
<li>使用<code>matplotlib.use(&#39;Tkagg&#39;)</code>之后出现报错<code>Cannot load backend &#39;TkAgg&#39; which requires the &#39;tk&#39; interactive framework, as &#39;headless&#39; is currently running</code>，或者是<code>_tkinter.TclError: couldn&#39;t connect to display &quot;:0.0&quot;</code><ul>
<li><img src="/imgs/image-20220627132430453.png" alt="image-20220627132430453"></li>
</ul>
</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>开始Import的时候改变顺序</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;Tkagg&#x27;</span>) <span class="comment">#这一句修改使用的后端输出设备</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<ul>
<li><p>然后在windows上安装<code>VcXsrv</code>服务器并且启动，具体下载地址为 <a target="_blank" rel="noopener" href="https://sourceforge.net/projects/vcxsrv/">sourceForge</a></p>
</li>
<li><p>安装过程中一路选择默认设置</p>
</li>
<li><p>然后通过桌面图标启动VcXsrv</p>
</li>
<li><p><img src="/imgs/3c06ab6204e183d7f8fcbf6507ef0822_r.jpg" alt="preview"></p>
</li>
<li><p><img src="/imgs/43f9d404f8d8db71b566a9d97439229d_r.jpg" alt="preview"></p>
</li>
<li><p><img src="/imgs/d0f6d5aaaa26b78d6af77e2a7094fff7_r.jpg" alt="preview"></p>
</li>
<li><p><img src="/imgs/v908aa4dd6a4dec03549efd26f418ca49_r.jpg" alt="preview"></p>
</li>
<li><p>然后正常情况会弹出Windows防火墙提示，允许访问即可</p>
</li>
<li><p>然后修改WSL端的环境</p>
</li>
<li><p>首先需要查看Windows系统和WSL2通信使用的<strong>虚拟网卡地址</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/resolv.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># nameserver后面的地址就是Windows系统虚拟网卡的地址,记一下</span></span><br><span class="line"><span class="comment"># 需要取消下面两行内容的注释,禁用自动重新生成配置文件,否则重启后这个地址会变</span></span><br><span class="line">[network]</span><br><span class="line">generateResolvConf = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后修改<code>.bashrc</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line"><span class="comment"># 在文件最后追加下面内容,地址使用上面查看到的</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=&lt;nameServer IP地址&gt;:0</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> ~/.bashrc </span><br></pre></td></tr></table></figure>

<p>详细可以参考配置<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/150555651">VcXsrv</a></p>
<ul>
<li>最终效果</li>
<li><img src="/imgs/image-20220627133421950.png" alt="image-20220627133421950"></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-C语言使用并行执行的for循环"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/22/C%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%9A%84for%E5%BE%AA%E7%8E%AF/"
    >C语言使用并行执行的for循环</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/22/C%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%9A%84for%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time datetime="2022-06-22T07:29:40.000Z" itemprop="datePublished">2022-06-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="C语言使用并行执行的for循环"><a href="#C语言使用并行执行的for循环" class="headerlink" title="C语言使用并行执行的for循环"></a>C语言使用并行执行的for循环</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ test111.cpp -o paraCpp111 -fopenmp</span><br></pre></td></tr></table></figure>

<ul>
<li>注意要添加<code>-fopenmp</code>选项</li>
</ul>
<h2 id="设置线程数量"><a href="#设置线程数量" class="headerlink" title="设置线程数量"></a>设置线程数量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">omp_set_num_threads(<span class="number">2</span>); <span class="comment">//参数为线程的数量</span></span><br></pre></td></tr></table></figure>

<h2 id="使用parallel的for循环"><a href="#使用parallel的for循环" class="headerlink" title="使用parallel的for循环"></a>使用parallel的for循环</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意<code>#pragma omp parallel for</code>这句必须和for循环<strong>紧邻</strong>，中间不能有其他语句，否则会出错</li>
</ul>
<h2 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h2><p>不进行线程设置和线程设置为2的效果对比：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1线程\n&quot;</span>);</span><br><span class="line">    before = clock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    timePeriod = clock()-before;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;timePeriod&lt;&lt;<span class="string">&#x27;!&#x27;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2线程\n&quot;</span>);</span><br><span class="line"><span class="comment">// 此处设置了2线程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    before = clock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    timePeriod = clock()-before;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;timePeriod&lt;&lt;<span class="string">&#x27;!&#x27;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>输出对比：</p>
<ul>
<li><p><img src="/imgs/image-20220622153605823.png" alt="image-20220622153605823"></p>
</li>
<li><p>注意到没有开启并行for循环的输出是按照顺序的，开启的输出是乱序的</p>
</li>
<li><p>同时经过尝试发现，假如开启了并行for循环的输出但是<strong>指定线程为1</strong>的，输出<strong>仍然是乱序</strong>的，暂时还不清楚原因</p>
</li>
</ul>
<p>对比大量计算和多组计算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1e8</span>;</span><br><span class="line">    <span class="keyword">int</span> before, timePeriod;</span><br><span class="line">    <span class="keyword">int</span> array1[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> array2[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> array4[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> array8[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> count = <span class="number">0</span>;count&lt;<span class="number">100</span>;++count)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">        <span class="built_in">omp_set_num_threads</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// printf(&quot;1线程\n&quot;);</span></span><br><span class="line">        before = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        timePeriod = <span class="built_in">clock</span>()-before;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;timePeriod&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// printf(&quot;2线程\n&quot;);</span></span><br><span class="line">        array1[count] = timePeriod;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">        <span class="built_in">omp_set_num_threads</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// printf(&quot;2线程\n&quot;);</span></span><br><span class="line">        before = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        timePeriod = <span class="built_in">clock</span>()-before;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;timePeriod&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// printf(&quot;4线程\n&quot;);</span></span><br><span class="line">        array2[count] = timePeriod;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    </span><br><span class="line">        <span class="built_in">omp_set_num_threads</span>(<span class="number">4</span>);</span><br><span class="line">        before = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        timePeriod = <span class="built_in">clock</span>()-before;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;timePeriod&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// printf(&quot;8线程\n&quot;);</span></span><br><span class="line">        array4[count] = timePeriod;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    </span><br><span class="line">        <span class="built_in">omp_set_num_threads</span>(<span class="number">8</span>);</span><br><span class="line">        before = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        timePeriod = <span class="built_in">clock</span>() - before;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;timePeriod&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        array8[count] = timePeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ofstream out;</span><br><span class="line">    out.<span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;<span class="number">100</span>;++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;array1[cnt]&lt;&lt;<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;<span class="number">100</span>;++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;array2[cnt]&lt;&lt;<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;<span class="number">100</span>;++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;array4[cnt]&lt;&lt;<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;<span class="number">100</span>;++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;array8[cnt]&lt;&lt;<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;python3 showData.py&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>其中分别开启1、2、4、8线程，进行for循环的计算，对比所需时间（通过<code>clock()</code>进行测量），最后调用命令行脚本<code>system</code>，开启另外撰写的python脚本进行数据折线图的显示</p>
</li>
<li><p><img src="/imgs/image-20220622154102661.png" alt="image-20220622154102661"></p>
<ul>
<li>上图是分别开启1、2、4、8线程的计算结果</li>
</ul>
</li>
<li><p>对于代码进行简单修改，在<strong>1线程的时候取消对于parallel的使用</strong>，实验结果如下图</p>
</li>
<li><p><img src="/imgs/image-20220622154349763.png" alt="image-20220622154349763"></p>
<ul>
<li>可见结果在1线程的时候，某些情况下会占用很长的时间</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">1e8</span>;</span><br><span class="line">    <span class="keyword">int</span> before, timePeriod;</span><br><span class="line">    <span class="keyword">int</span> array1[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> array2[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> array4[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> array8[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> count = <span class="number">0</span>;count&lt;<span class="number">100</span>;++count)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// #pragma omp parallel</span></span><br><span class="line"><span class="comment">//         omp_set_num_threads(1);</span></span><br><span class="line">        <span class="comment">// printf(&quot;1线程\n&quot;);</span></span><br><span class="line">        before = <span class="built_in">clock</span>();</span><br><span class="line"><span class="comment">// #pragma omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        timePeriod = <span class="built_in">clock</span>()-before;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;timePeriod&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// printf(&quot;2线程\n&quot;);</span></span><br><span class="line">        array1[count] = timePeriod;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">        <span class="built_in">omp_set_num_threads</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// printf(&quot;2线程\n&quot;);</span></span><br><span class="line">        before = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        timePeriod = <span class="built_in">clock</span>()-before;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;timePeriod&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// printf(&quot;4线程\n&quot;);</span></span><br><span class="line">        array2[count] = timePeriod;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    </span><br><span class="line">        <span class="built_in">omp_set_num_threads</span>(<span class="number">4</span>);</span><br><span class="line">        before = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        timePeriod = <span class="built_in">clock</span>()-before;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;timePeriod&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// printf(&quot;8线程\n&quot;);</span></span><br><span class="line">        array4[count] = timePeriod;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    </span><br><span class="line">        <span class="built_in">omp_set_num_threads</span>(<span class="number">8</span>);</span><br><span class="line">        before = <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        timePeriod = <span class="built_in">clock</span>() - before;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;timePeriod&lt;&lt;&#x27;!&#x27;&lt;&lt;endl;</span></span><br><span class="line">        array8[count] = timePeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ofstream out;</span><br><span class="line">    out.<span class="built_in">open</span>(<span class="string">&quot;data.csv&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;<span class="number">100</span>;++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;array1[cnt]&lt;&lt;<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;<span class="number">100</span>;++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;array2[cnt]&lt;&lt;<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;<span class="number">100</span>;++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;array4[cnt]&lt;&lt;<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cnt = <span class="number">0</span>;cnt&lt;<span class="number">100</span>;++cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        out&lt;&lt;array8[cnt]&lt;&lt;<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    out.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;python3 showData.py&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2023
        <i class="ri-heart-fill heart_icon"></i> FrankZhang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.png" alt="Frank’s blogs"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>