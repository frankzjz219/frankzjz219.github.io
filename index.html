<!DOCTYPE html>


<html lang="Chinese">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Frank’s blogs</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/FLogo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/bkgPic.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Frank’s blogs</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['Linux开发和工科生折腾集锦', '算法题总结', 'C/C++/python等开发'],
        startDelay: 0,
        typeSpeed: 100,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">Linux编程、C/C++开发、算法题、各种工科生折腾开发集锦</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Linux下C语言开发技巧"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/31/Linux%E4%B8%8BC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"
    >Linux下C语言开发技巧</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/31/Linux%E4%B8%8BC%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" class="article-date">
  <time datetime="2024-01-31T03:39:58.000Z" itemprop="datePublished">2024-01-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="比较的宏以及typeof-类型判断宏"><a href="#比较的宏以及typeof-类型判断宏" class="headerlink" title="比较的宏以及typeof()类型判断宏`"></a>比较的宏以及<code>typeof()</code>类型判断宏`</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="comment">// 上述无法处理包含a++等的情况</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>typeof()</code><strong>类转换宏</strong>处理<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) (&#123;        \</span></span><br><span class="line"><span class="meta">    typeof(a) _a = (a);      \</span></span><br><span class="line"><span class="meta">    typeof(b) _b = (b);      \</span></span><br><span class="line"><span class="meta">    (void) (&amp;_a == &amp;_b);   \</span></span><br><span class="line"><span class="meta">    _a &gt; _b ? _a : _b; &#125;)</span></span><br></pre></td></tr></table></figure></li>
<li><code>typeof(a) _a = (a)</code>定义一个a类型的变量，值等于a</li>
<li><code>(void) (&amp;_a == &amp;_b)</code>判断二者类型是否相同，<u>不同的话会出现警告</u><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typeof(<span class="keyword">int</span> *) a,b;<span class="comment">//等价于：int *a,*b;</span></span><br></pre></td></tr></table></figure>
<h2 id="零长数组（变长数组）"><a href="#零长数组（变长数组）" class="headerlink" title="零长数组（变长数组）"></a>零长数组（变长数组）</h2></li>
<li>满足需要变长度的结构体，因此有时也习惯性地称为变长数组。</li>
<li>在一个结构体的最后, 申明一个长度为0的数组, 就可以使得这个结构体是可变长的<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">thisline</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct line) + this_length);</span><br><span class="line">thisline-&gt;length = this_length;</span><br></pre></td></tr></table></figure></li>
<li>上述结构体本身的大小只有一个length的大小，不包括content</li>
<li>创建的时候人为分配空间给contents即可</li>
</ul>
<h2 id="switch-case的条件指定范围"><a href="#switch-case的条件指定范围" class="headerlink" title="switch case的条件指定范围"></a>switch case的条件指定范围</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> low ... high:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> ..<span class="number">.&#x27;</span>Z<span class="number">&#x27;</span>:</span><br></pre></td></tr></table></figure>
<ul>
<li>还可以用整形数来表示范围，但是这里需要注意在“…”两边有空格</li>
</ul>
<h2 id="struct的指定成员初始化"><a href="#struct的指定成员初始化" class="headerlink" title="struct的指定成员初始化"></a>struct的指定成员初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三维点的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3D</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含点操作的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointOperations</span> &#123;</span></span><br><span class="line">    <span class="comment">// 函数指针，用于计算两个点的距离</span></span><br><span class="line">    <span class="keyword">double</span> (*calculateDistance)(<span class="keyword">const</span> struct Point3D* p1, <span class="keyword">const</span> struct Point3D* p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数指针，用于打印点的坐标</span></span><br><span class="line">    <span class="keyword">void</span> (*printCoordinates)(<span class="keyword">const</span> struct Point3D* point);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个点的距离的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculateDistance</span><span class="params">(<span class="keyword">const</span> struct Point3D* p1, <span class="keyword">const</span> struct Point3D* p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx = p1-&gt;x - p2-&gt;x;</span><br><span class="line">    <span class="keyword">int</span> dy = p1-&gt;y - p2-&gt;y;</span><br><span class="line">    <span class="keyword">int</span> dz = p1-&gt;z - p2-&gt;z;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy + dz*dz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印点的坐标的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCoordinates</span><span class="params">(<span class="keyword">const</span> struct Point3D* point)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d, %d)\n&quot;</span>, point-&gt;x, point-&gt;y, point-&gt;z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个三维点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point3D</span> <span class="title">pointA</span> =</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化操作的结构体并初始化函数指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PointOperations</span> <span class="title">pointOps</span> =</span> &#123;</span><br><span class="line">        .calculateDistance = calculateDistance,</span><br><span class="line">        .printCoordinates = printCoordinates</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构体中的函数指针计算两个点的距离</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point3D</span> <span class="title">pointB</span> =</span> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> distance = pointOps.calculateDistance(&amp;pointA, &amp;pointB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Distance between points: %f\n&quot;</span>, distance);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构体中的函数指针打印点的坐标</span></span><br><span class="line">    pointOps.printCoordinates(&amp;pointA);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上文中的指定名称初始化是<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义点操作的结构体并初始化函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointOperations</span> <span class="title">pointOps</span> =</span> &#123;</span><br><span class="line">    .calculateDistance = calculateDistance,</span><br><span class="line">    .printCoordinates = printCoordinates</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这里可以手动指定需要初始化的结构体成员的名字</li>
</ul>
<h2 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_debug(fmt, ...) \</span></span><br><span class="line"><span class="meta">    dynamic_pr_debug(fmt, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>dynamic_pr_debug 是 Linux 内核中用于动态调试打印的宏，而 fmt 和 <code>__VA_ARGS__</code> 则是格式化字符串和可变参数列表。</p>
</li>
<li><p>fmt：格式化字符串，类似于 printf 中的格式化字符串，包含要打印的文本和格式说明符。</p>
</li>
<li><p><code>__VA_ARGS__</code>：表示可变参数的宏，用于将额外的参数传递给 fmt 中的格式说明符。</p>
</li>
<li><p><code>##__VA_ARGS__</code> 是一个预处理器技巧，用于处理当可变参数列表为空时的情况，确保宏在没有额外参数时也能正确展开</p>
</li>
</ul>
<h2 id="函数属性-attribute"><a href="#函数属性-attribute" class="headerlink" title="函数属性 __attribute__"></a>函数属性 <code>__attribute__</code></h2><ul>
<li><p><code>__attribute__ ((attribute-list))</code></p>
</li>
<li><p><code>attribute-list</code>的定义有很多，如<code>noreturn</code>、<code>format</code>以及<code>const</code>等。此外，还可以定义一些和处理器体系结构相关的函数属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__((noreturn)) die(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>其他属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __pure           __attribute__((pure))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __aligned(x)        __attribute__((aligned(x)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __printf(a, b)      __attribute__((format(printf, a, b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __scanf(a, b)       __attribute__((format(scanf, a, b)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noinline          __attribute__((noinline))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __attribute_const__   __attribute__((__const__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __maybe_unused      __attribute__((unused))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __always_unused      __attribute__((unused))</span></span><br></pre></td></tr></table></figure>
<h2 id="变量属性和类属性"><a href="#变量属性和类属性" class="headerlink" title="变量属性和类属性"></a>变量属性和类属性</h2></li>
<li><p>变量属性可以对变量或结构体成员进行属性设置。类型属性常见的属性有<code>alignment</code>、<code>packed</code>和<code>sections</code>等。</p>
</li>
<li><p><code>alignment</code>属性规定变量或者结构体成员的最小对齐格式，以字节为单位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qib_user_info</span> &#123;</span></span><br><span class="line">    __u32 spu_userversion;</span><br><span class="line">    __u64 spu_base_info;</span><br><span class="line">&#125; __aligned(<span class="number">8</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>上述例子中结构体存储会以八字节对齐</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line"> <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> x[<span class="number">2</span>] __attribute__ ((packed));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>x成员使用了packed属性，它会存储在变量a后面，所以这个结构体一共占用9字节</p>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2></li>
<li><p>内建函数以“_builtin_”作为函数名前缀。下面介绍Linux内核常用的一些内建函数</p>
</li>
<li><p><code>__builtin_constant_p(x)</code>：判断x是否在编译时就可以被确定为常量。如果x为常量，该函数返回1，否则返回0</p>
</li>
<li><p><code>__builtin_expect(exp, c)</code>：这里的意思是<code>exp==c</code>的概率很大，用来引导GCC编译器进行条件分支预测</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __swab16(x)        \</span></span><br><span class="line"><span class="meta">(__builtin_constant_p((__u16)(x)) ?  \</span></span><br><span class="line"><span class="meta">___constant_swab16(x) :      \</span></span><br><span class="line"><span class="meta">__fswab16(x))__builtin_expect(exp, c)</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>__builtin_prefetch(const void *addr, int rw, int locality)</code>：主动进行数据预取，在使用<strong>地址addr的值之前就把其值加载到cache中</strong>，<u>减少读取的延迟</u>，从而提高性能。</p>
<ul>
<li><p>该函数可以接受3个参数：</p>
<ul>
<li>第一个参数addr表示要预取数据的地址；</li>
<li>第二个参数rw表示读写属性，1表示可写，0表示只读；</li>
<li>第三个参数locality表示数据在cache中的时间局部性，其中0表示读取完addr的之后不用保留在cache中，而1～3表示时间局部性逐渐增强</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="asmlinkage"><a href="#asmlinkage" class="headerlink" title="asmlinkage"></a>asmlinkage</h2><ul>
<li>在标准C语言中，函数的形参在实际传入参数时会涉及参数存放问题</li>
<li>对于x86架构，函数参数和局部变量被一起分配到函数的局部堆栈里<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;arch/x86/include/<span class="keyword">asm</span>/linkage.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))</span></span><br></pre></td></tr></table></figure></li>
<li>告诉编译器该函数<strong>不需要通过任何寄存器来传递参数，只通过堆栈来传递</strong></li>
<li>对于ARM来说，函数参数的传递有一套ATPCS标准，即通过寄存器来传递。<strong>ARM中的R0～R4寄存器存放传入参数，当参数超过5个时，多余的参数被存放在局部堆栈中</strong><ul>
<li>ARM平台没有定义asmlinkage</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E6%A0%B8/" rel="tag">内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag">嵌入式</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-背包问题（动态规划）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/"
    >背包问题（动态规划）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/26/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/" class="article-date">
  <time datetime="2024-01-26T13:36:09.000Z" itemprop="datePublished">2024-01-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Leetcode-416-分割等和子集"><a href="#Leetcode-416-分割等和子集" class="headerlink" title="Leetcode 416. 分割等和子集"></a>Leetcode 416. 分割等和子集</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">背包原理教程</a></li>
<li>注意不是一定要连续的子集</li>
<li>先通过数组的和是不是奇数筛选掉一部分</li>
<li>思路流程是先计算出利用下标为<code>0</code>-<code>i-1</code>的数字计算出能到达的所有和<ul>
<li>然后再利用下标为<code>i</code>的数字的值加上前面到达过的所有位置，算出<code>0</code>-<code>i</code>能到达的所有和</li>
</ul>
</li>
<li>动态规划的时候从结尾开始遍历这个为止的<strong>可到达性</strong>，也就是能否凑的出来这个位置<ul>
<li>如果一个和减去某个数组中存在的数字的和可达，那么这个和本身也可达<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, maxNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            maxNum = <span class="built_in">max</span>(maxNum, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxNum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= num; --j) &#123;</span><br><span class="line">                dp[j] |= dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-1049-最后一块石头重量-II"><a href="#Leetcode-1049-最后一块石头重量-II" class="headerlink" title="Leetcode 1049. 最后一块石头重量 II"></a>Leetcode 1049. 最后一块石头重量 II</h2><ul>
<li>主要思路还是背包问题，只不过此时的背包容量和装的物品的价值<strong>都是石头的重量</strong></li>
<li><u>注意内存循环必须从后往前遍历，否则会导致前面被添加过的物品被连续重复添加</u></li>
<li>外层循环的意思是使用到的石头是<code>0</code>-<code>i</code>个，内层的意思是石头<u>总重不超过某个值的时候的最大总重是多少</u><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:stones)sum+=i;</span><br><span class="line">        <span class="keyword">int</span> target = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxArr</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;stones.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> wi = stones[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = target; j&gt;=wi; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                maxArr[j] = <span class="built_in">max</span>(maxArr[j], maxArr[j-wi]+wi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - (maxArr[target]*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-474-一和零"><a href="#Leetcode-474-一和零" class="headerlink" title="Leetcode 474. 一和零"></a>Leetcode 474. 一和零</h2><ul>
<li>此题是一个递推问题，做题方式类似于背包法</li>
<li>遍历同样是外层循环指定此时能使用的字符串的最大index</li>
<li>内层循环从已经可达的位置往外递推，类似于广度优先搜索<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// int maxLen;</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; lenMap;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i: strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c0 = <span class="number">0</span>, c1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a:i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a == <span class="string">&#x27;0&#x27;</span>)++c0;</span><br><span class="line">                <span class="keyword">else</span> ++c1;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(c0, c1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        map[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c0 = arr[i].first;</span><br><span class="line">            <span class="keyword">int</span> c1 = arr[i].second;</span><br><span class="line">            <span class="comment">// int s = q.size();</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j&gt;=c0; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = n; k&gt;=c1; --k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(map[j-c0][k-c1]&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    map[j][k] = <span class="built_in">max</span>(map[j-c0][k-c1]+<span class="number">1</span>, map[j][k]);</span><br><span class="line">                    map[m][n] = <span class="built_in">max</span>(map[m][n], map[j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[m][n]&lt;<span class="number">0</span>?<span class="number">0</span>:map[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-518-零钱兑换II"><a href="#Leetcode-518-零钱兑换II" class="headerlink" title="Leetcode 518. 零钱兑换II"></a>Leetcode 518. 零钱兑换II</h2></li>
<li>此题是一个完全背包类型的题<a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">参考链接</a></li>
<li>注意循环次序的变化，0 1背包循环一般内层递推循环都是倒序的，但是这种是正序的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">arr</span><span class="params">(amount+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// queue&lt;int&gt; q;</span></span><br><span class="line">        <span class="comment">// q.push(0);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;coins.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = coins[i]; j&lt;=amount; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[j]+=arr[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-377-组合总和IV"><a href="#Leetcode-377-组合总和IV" class="headerlink" title="Leetcode 377. 组合总和IV"></a>Leetcode 377. 组合总和IV</h2></li>
<li>如果求<strong>组合数</strong>就是外层for循环遍历物品，内层for遍历背包。</li>
<li>如果求<strong>排列数</strong>就是外层for遍历背包，内层for循环遍历物品。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; <span class="title">arr</span><span class="params">(target+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=target; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&gt;=<span class="number">0</span>)</span><br><span class="line">                arr[j]+=arr[j-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-279-完全平方数"><a href="#Leetcode-279-完全平方数" class="headerlink" title="Leetcode 279. 完全平方数"></a>Leetcode 279. 完全平方数</h2><ul>
<li>转化为一个完全背包问题即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; minCnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        minCnt = vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, INT_MAX);</span><br><span class="line">        minCnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i*i&lt;=n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;=n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minCnt[j-i]!=INT_MAX)minCnt[j] = <span class="built_in">min</span>(minCnt[j], minCnt[j-i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCnt[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Linux进程、线程等底层原理笔记（一）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/22/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"
    >Linux进程、线程等底层原理笔记（一）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/22/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2024-01-22T12:11:48.000Z" itemprop="datePublished">2024-01-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h2><ul>
<li><code>fork</code>创建进程的时候，将父进程的所有资源拷贝给子进程<ul>
<li>写时复制的</li>
<li>实际上是将内存地址设置为只读的</li>
<li>假如任何一个进程试图写入的话，会触发<code>page fault</code>导致系统给他分配新的内存，也就是复制</li>
</ul>
</li>
<li><code>vfork</code>的时候是直接将子进程的资源指向父进程的，二者是同时共有资源的，一个修改会影响另一个<h2 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h2></li>
<li>通过<code>pthread_create</code>创建线程的时候，实际上是调用系统的<code>clone</code>（类似于<code>vfork</code>）方式创建了一个<u>与父进程共享一切资源的子进程</u></li>
<li><img src="/imgs/df695c03041cf38aefbc7ecbbdedac0edeb848523d8e8e8de52c8026a22c85fe.png" alt="picture 0">  </li>
<li>本来理论上父子进程之间的资源是写时复制的，但是这里直接共享了</li>
<li>每个线程都有一个独立的PID<h3 id="线程的真假ID"><a href="#线程的真假ID" class="headerlink" title="线程的真假ID"></a>线程的真假ID</h3></li>
<li>用户空间<code>getpid()</code>获得的PID是<u>进程ID</u>，并不是线程独立的PID<ul>
<li><code>gettid()</code>获得的才是真正<strong>线程PID</strong>，也就是内核的真正PID</li>
<li><img src="/imgs/a91e7465f98780d02621e8f5b9b630367fa9ac81365bb4c16b76064c3b778a4c.png" alt="picture 1">  </li>
</ul>
</li>
</ul>
<h2 id="进程的托孤"><a href="#进程的托孤" class="headerlink" title="进程的托孤"></a>进程的托孤</h2><ul>
<li>一个拥有子进程的进程终止的时候，会向init进程或者是自己最近一级的父进程中的subreaper进程托孤，将自己的子进程交给这些进程处理<ul>
<li>subreaper需要一个进程<strong>自己声明自己是</strong>才可以<h2 id="深度睡眠和浅度睡眠"><a href="#深度睡眠和浅度睡眠" class="headerlink" title="深度睡眠和浅度睡眠"></a>深度睡眠和浅度睡眠</h2></li>
</ul>
</li>
<li>深度睡眠只能被资源唤醒<ul>
<li>甚至无法被信号杀死</li>
</ul>
</li>
<li>浅度睡眠可以被资源或者是信号（signal）唤醒</li>
<li>比如程序因为内存没加载导致page fault<ul>
<li>此时如果因为接收到信号开始执行内容，会导致程序继而触发更多的page fault</li>
<li>因此只有等到相关内存页面被分配了才可以</li>
</ul>
</li>
</ul>
<h2 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h2><ul>
<li>程序的睡眠是程序访问资源的时候发现需要等待，自己让出CPU使用权并且将状态设置为sleep</li>
<li>睡眠结束的时候需要判断自己是被什么唤醒的（如果是浅度睡眠的话）<ul>
<li>是被信号唤醒的？是什么信号</li>
<li>是被资源唤醒的？继续执行</li>
</ul>
</li>
</ul>
<h2 id="第一个进程是被谁创建出来的"><a href="#第一个进程是被谁创建出来的" class="headerlink" title="第一个进程是被谁创建出来的"></a>第一个进程是被谁创建出来的</h2><ul>
<li>1进程（也就是init）是被Linux的0进程创建出来的</li>
<li>但是Linux的0进程使用pstree看不到</li>
<li>退化为了IDLE进程<ul>
<li>所有进程停止或者睡眠之后，才会调度的进程</li>
<li>它会把将CPU设置为省电状态，只有中断可以唤醒<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2></li>
</ul>
</li>
<li>进程切换的开销不只是上下文切换，主要还包括进程切换引起的内存cache 的<code>cache miss</code></li>
<li>因为不同进程需要的内存空间不同，导致切换会极大增加miss概率</li>
</ul>
<h2 id="非实时进程的时间片分配"><a href="#非实时进程的时间片分配" class="headerlink" title="非实时进程的时间片分配"></a>非实时进程的时间片分配</h2><ul>
<li>使用<code>nice</code>值分配</li>
<li><code>nice</code>越大，优先级越低</li>
<li>优先级高的相对于优先级低的可以在唤醒的一瞬间抢占，但是之后会一起轮转</li>
<li>优先级越高的在轮转中分配到的时间片越长</li>
<li>在整个循环过程中是所有优先级的进程一起轮转的，不会高优先级阻塞低优先级运行</li>
<li>系统会针对应用是IO类型还是CPU消耗类型来调整nice值<ul>
<li>越CPU占用，nice越低<h2 id="控制实时进程和非实时进程"><a href="#控制实时进程和非实时进程" class="headerlink" title="控制实时进程和非实时进程"></a>控制实时进程和非实时进程</h2></li>
</ul>
</li>
<li><code>sched_rt_period_us</code>和<code>shced_rt_runtime_us</code></li>
<li>控制FIFO和RR最多占用的时间</li>
<li><img src="/imgs/852dd435f32fd9baa80f8fd4e531104996a4aefc62f80afc69816d2f63d3c04a.png" alt="picture 2">  </li>
</ul>
<h2 id="CFS-完全公平调度"><a href="#CFS-完全公平调度" class="headerlink" title="CFS-完全公平调度"></a>CFS-完全公平调度</h2><ul>
<li>每次都调度到当前位置vruntime最小的进程</li>
<li>也就是考虑到优先级修正之后，运行时间最小的进程</li>
<li>完全公平，使得所有进程的vruntime尽可能公平分配<ul>
<li>vruntime是实际运行时间进行一些权重和系数运算得出的</li>
<li>物理runtime除以权重</li>
<li><img src="/imgs/e478ee6ad032f1596c2fb5c13bad47341d7da1c13f4987d3cee46d0360a00958.png" alt="picture 3">  </li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>System Call</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>nice()</td>
<td>Sets a process’s nice value</td>
</tr>
<tr>
<td>sched_setscheduler()</td>
<td>Sets a process’s scheduling policy</td>
</tr>
<tr>
<td>sched_getscheduler()</td>
<td>Gets a process’s scheduling pol1icy</td>
</tr>
<tr>
<td>sched_setparam()</td>
<td>Sets a process’s real-time priority</td>
</tr>
<tr>
<td>sched_getparam()</td>
<td>Gets a process’s real-time priority</td>
</tr>
<tr>
<td>sched_get_priority_max()</td>
<td>Gets the maximum real-time priority</td>
</tr>
<tr>
<td>sched_get_priority_min()</td>
<td>Gets the minimum real-time priority</td>
</tr>
<tr>
<td>sched_rr_get_interval()</td>
<td>Gets a process’s timeslice value</td>
</tr>
<tr>
<td>sched_setaffinity()</td>
<td>Sets a process’s processor affinity</td>
</tr>
<tr>
<td>sched_getaffinity()</td>
<td>Gets a process’s processor affinity</td>
</tr>
<tr>
<td>sched_yield()</td>
<td>Temporarily yields the processor</td>
</tr>
</tbody></table>
<h2 id="设置进程的CPU亲和"><a href="#设置进程的CPU亲和" class="headerlink" title="设置进程的CPU亲和"></a>设置进程的CPU亲和</h2><ul>
<li>使用<code>taskset</code>命令行工具</li>
<li>上文提到的<code>sched_setaffinity()</code></li>
<li>或者单独设置线程的亲和力<code>pthread_setaffinity_np()</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>或者创建新线程时，通过属性结构体，控制新线程的亲和性<code>pthread_attr_setaffinity_np()</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setaffinity_np</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><ul>
<li>cgroup（Control Groups）是 Linux 内核提供的一个功能，用于限制、控制和监视一个或多个进程的资源使用。cgroup 允许你将进程组织在层次结构中，并为每个组分配特定的资源限制。</li>
<li>创建<ul>
<li><code>sudo mkdir /sys/fs/cgroup/cpu/my_cgroup</code></li>
</ul>
</li>
<li>添加进程<ul>
<li><code>echo &lt;PID&gt; &gt; /sys/fs/cgroup/cpu/my_cgroup/tasks</code></li>
</ul>
</li>
<li>设置 cgroup 的资源限制<ul>
<li><code>echo 1000000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us</code></li>
</ul>
</li>
<li>查看 cgroup 信息<ul>
<li><code>cat /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us</code></li>
</ul>
</li>
<li>删除 cgroup<ul>
<li><code>sudo rmdir /sys/fs/cgroup/cpu/my_cgroup</code></li>
</ul>
</li>
</ul>
<h2 id="如何使用sudo权限将echo的输出写入到文件中"><a href="#如何使用sudo权限将echo的输出写入到文件中" class="headerlink" title="如何使用sudo权限将echo的输出写入到文件中"></a>如何使用sudo权限将echo的输出写入到文件中</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;echo string &gt; /path/to/file&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">echo &quot;Hello, world&quot; | sudo tee -a /path/to/file</span><br></pre></td></tr></table></figure>
<h2 id="Linux中进程可以抢占的部分"><a href="#Linux中进程可以抢占的部分" class="headerlink" title="Linux中进程可以抢占的部分"></a>Linux中<code>进程</code>可以抢占的部分</h2><ul>
<li>即使是在下面不可调度的部分唤醒了一个优先级再高的进程，也不允许抢占执行</li>
<li>一个核心上的进程拿到了spinlock，会直接关闭这个核心的调度器停止调度</li>
<li>一个程序的<strong>优先级改变（降低）</strong>的时候，别的优先级高的进程可以<strong>立即抢占</strong></li>
</ul>
<table>
<thead>
<tr>
<th>区间</th>
<th>可调度性</th>
</tr>
</thead>
<tbody><tr>
<td>（硬）中断（不允许中断嵌套）</td>
<td>不可调度</td>
</tr>
<tr>
<td>软中断（可以中断嵌套）</td>
<td>不可调度</td>
</tr>
<tr>
<td>进程上下文中获取到<code>spinlock</code></td>
<td>不可调度</td>
</tr>
<tr>
<td>其他进程上下文</td>
<td>可以调度</td>
</tr>
</tbody></table>
<ul>
<li>自旋锁的自旋一定发生在不同的核心之间<ul>
<li>如果同一个核心的两个进程争夺自旋锁，一个抢到之后就直接关闭了调度器，另一个进程根本上不来，不可能自旋</li>
<li>只有可能是一个核心持有锁，另一个核心自旋</li>
</ul>
</li>
</ul>
<h2 id="进程回收和僵尸进程"><a href="#进程回收和僵尸进程" class="headerlink" title="进程回收和僵尸进程"></a>进程回收和僵尸进程</h2><ul>
<li>一个进程变成僵尸状态之后，进程的资源都消失了</li>
<li>但是进程的<code>task_struct</code>还没有消失</li>
<li>等待父进程使用<code>waitpid</code>回收并且查看进程的<strong>退出码</strong>，判断子进程的死因</li>
<li>只有父进程使用wait等待的时候他的task struct才会消失</li>
<li>这个进程无法使用系统的signal杀死</li>
</ul>
<h2 id="Linux进程状态"><a href="#Linux进程状态" class="headerlink" title="Linux进程状态"></a>Linux进程状态</h2><ul>
<li><img src="/imgs/8234473b9b901abca50f411cfe93f07e7bb03b02e925e19096cfe46f38cd29fb.png" alt="picture 4">  </li>
</ul>
<table>
<thead>
<tr>
<th>状态</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>就绪</td>
<td>等待上CPU（因为时间片结束或者被抢占等）</td>
</tr>
<tr>
<td>运行</td>
<td>执行</td>
</tr>
<tr>
<td>睡眠</td>
<td>等资源（等到了就绪）</td>
</tr>
<tr>
<td>僵尸</td>
<td>执行完但是还没有回收</td>
</tr>
<tr>
<td>停止</td>
<td>STOP或者收到了Ctrl+Z等信号，还可以继续恢复（输入fg，bg等）</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-回溯和递归法题目"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/22/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E6%B3%95%E9%A2%98%E7%9B%AE/"
    >回溯和递归法题目</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/22/%E5%9B%9E%E6%BA%AF%E5%92%8C%E9%80%92%E5%BD%92%E6%B3%95%E9%A2%98%E7%9B%AE/" class="article-date">
  <time datetime="2024-01-21T16:39:27.000Z" itemprop="datePublished">2024-01-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="LeetCode-332-重新安排行程"><a href="#LeetCode-332-重新安排行程" class="headerlink" title="LeetCode 332. 重新安排行程"></a>LeetCode 332. 重新安排行程</h2><ul>
<li>此题的大部分是按照回溯法标准套路进行<ul>
<li>也就是</li>
<li>遍历尝试DFS</li>
<li>满足条件的修改环境</li>
<li>递归</li>
<li>出现结果的话直接返回</li>
<li>没出现的话将环境复原</li>
<li>继续尝试下一种</li>
</ul>
</li>
<li>但是注意需要一个<strong>排序</strong>（因为返回字典序最小的结果）快速的从一个<code>string</code>出发到一个<code>string</code>截止并且能处理重复情况的方式<ul>
<li>使用了<code>unordered_map&lt;string, map&lt;string, int&gt;&gt;</code></li>
<li>外层map将起点映射到终点</li>
<li>内层map将终点映射到出现过的次数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// unordered_set&lt;int&gt; used;</span></span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    unordered_map&lt;string, map&lt;string, <span class="keyword">int</span>&gt;&gt; to;</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:tickets)</span><br><span class="line">        &#123;</span><br><span class="line">            ++to[i[<span class="number">0</span>]][i[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="comment">// ans.resize(tickets.size());</span></span><br><span class="line">        <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets, vector&lt;string&gt;&amp; ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;tickets.size()&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">int</span> cnt = tickets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!ans.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : to[<span class="string">&quot;JFK&quot;</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i.second&gt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --i.second;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(i.first);</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">                    <span class="keyword">if</span>(flag)<span class="keyword">return</span>;</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                    ++i.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == cnt+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : to[ans[ans.<span class="built_in">size</span>()<span class="number">-1</span>]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i.second--;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(i.first);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i.first&lt;&lt;endl;</span></span><br><span class="line">                <span class="built_in">recur</span>(tickets, ans);</span><br><span class="line">                <span class="keyword">if</span>(flag)<span class="keyword">return</span>;</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">                i.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Leetcode-47-全排列II"><a href="#Leetcode-47-全排列II" class="headerlink" title="Leetcode 47. 全排列II"></a>Leetcode 47. 全排列II</h2><ul>
<li>关键是去重</li>
<li>还要强调的是去重一定要对元素进行<strong>排序</strong>，这样我们才方便通过相邻的节点来判断是否重复使用了<ul>
<li><img src="/imgs/e603911ea5befcd9846a5d3ab96f008fd5e373ac9bf6c7720c932888e2a59505.png" alt="picture 0">  </li>
<li>具体判断逻辑<ul>
<li>上一个字母是否与这个一样</li>
<li>一样的话上一个是否是<strong>未使用过</strong>的，如果是就说明上一个字母在当前的这个位置，<u>被其他分支使用过</u>，需要跳过</li>
<li>否则将其添加到结果数组中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度: 最差情况所有元素都是唯一的。复杂度和全排列1都是 O(n! * n) 对于 n 个元素一共有 n! 中排列方案。而对于每一个答案，我们需要 O(n) 去复制最终放到 result 数组</span></span><br><span class="line"><span class="comment">// 空间复杂度: O(n) 回溯树的深度取决于我们有多少个元素```</span></span><br><span class="line">``````</span><br><span class="line">## Leetcode <span class="number">491.</span> 非递减子序列</span><br><span class="line">- 此题主要是基本的从左到右遍历递归</span><br><span class="line">- 使用了哈希的方式查重，也就是先把数组转化为字符串</span><br><span class="line">  - 注意使用了右值引用防止多次复制字符串引起的时间和空间消耗</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;string&gt; us;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="comment">// sort(nums.begin(), nums.end());</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">        <span class="comment">// string hash;</span></span><br><span class="line">        <span class="built_in">recur</span>(nums, seq, <span class="built_in">string</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">int</span>&gt;&amp; seq, string&amp;&amp; hash, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(seq.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;seq[seq.<span class="built_in">size</span>()<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> insertRes = us.<span class="built_in">insert</span>(hash+<span class="built_in">to_string</span>(nums[i])+<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!insertRes.second)<span class="keyword">continue</span>;</span><br><span class="line">            seq.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(seq.<span class="built_in">size</span>()&gt;=<span class="number">2</span>)ret.<span class="built_in">push_back</span>(seq);</span><br><span class="line">            <span class="built_in">recur</span>(nums, seq, hash+<span class="built_in">to_string</span>(nums[i])+<span class="string">&quot;, &quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">            seq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-二叉树的非递归遍历（二）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88%E4%BA%8C%EF%BC%89/"
    >二叉树的非递归遍历（二）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/17/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2024-01-17T04:38:29.000Z" itemprop="datePublished">2024-01-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><ul>
<li>通过在遍历过一次的节点前面加入一个NULL指针，提示下一个节点遍历过一次了<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>遍历过一次的节点第二次直接输出<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>针对没访问过的节点，先把他的左孩子入栈，再把NULL和自身入栈，再入栈右孩子<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>针对没访问过的节点，先把自己和NULL入栈，再把右孩子入栈，再把左孩子入栈</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-携程库实现（一）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/11/%E6%90%BA%E7%A8%8B%E5%BA%93%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/"
    >协程库实现（一）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/11/%E6%90%BA%E7%A8%8B%E5%BA%93%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/" class="article-date">
  <time datetime="2024-01-11T09:50:36.000Z" itemprop="datePublished">2024-01-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ul>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/52886">参考</a><h2 id="ucontext-h上下文切换"><a href="#ucontext-h上下文切换" class="headerlink" title="ucontext.h上下文切换"></a><code>ucontext.h</code>上下文切换</h2></li>
<li>上下文结构体定义</li>
<li> <code>mcontext_t</code>类型与机器相关，并且不透明.<code>ucontext_t</code>结构体则至少拥有以下几个域:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span>         uc_sigmask;</span><br><span class="line">    <span class="keyword">stack_t</span>          uc_stack;</span><br><span class="line">    <span class="keyword">mcontext_t</span>       uc_mcontext;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">ucontext_t</span>;</span><br></pre></td></tr></table></figure></li>
<li>当当前上下文(如使用makecontext创建的上下文）运行终止时系统会恢复<code>uc_link</code>指向的上下文；<code>uc_sigmask</code>为该上下文中的阻塞信号集合；<code>uc_stack</code>为该上下文中使用的栈；<code>uc_mcontext</code>保存的上下文的特定机器表示，包括调用线程的特定寄存器等<h3 id="四个操作函数"><a href="#四个操作函数" class="headerlink" title="四个操作函数"></a>四个操作函数</h3></li>
<li><code>int getcontext(ucontext_t *ucp);</code><ul>
<li>初始化ucp结构体，将当前的上下文保存到ucp中</li>
</ul>
</li>
<li><code>int setcontext(const ucontext_t *ucp);</code><ul>
<li>设置当前的上下文为ucp，setcontext的上下文ucp应该通过getcontext或者makecontext取得，如果调用成功则不返回。</li>
<li>如果上下文是通过调用getcontext()取得,程序会继续执行这个调用。如果上下文是通过调用makecontext取得,程序会调用makecontext函数的第二个参数指向的函数，如果func函数返回,则恢复makecontext第一个参数指向的上下文第一个参数指向的上下文context_t中指向的uc_link</li>
<li>如果uc_link为NULL,则线程退出。</li>
</ul>
</li>
<li><code>void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</code><ul>
<li> <code>makecontext</code>修改通过<code>getcontext</code>取得的上下文ucp(这意味着调用makecontext前必须先调用getcontext)。然后给该上下文指定一个栈空间ucp-&gt;stack，设置后继的上下文ucp-&gt;uc_link.</li>
<li> 当上下文通过setcontext或者swapcontext激活后，执行func函数，argc为func的参数个数，后面是func的参数序列。当func执行返回后，继承的上下文被激活，如果继承上下文为NULL时，线程退出</li>
</ul>
</li>
<li><code>int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</code><ul>
<li><strong>保存当前上下文到oucp结构体中</strong>，<strong>然后激活upc上下文</strong>。 </li>
</ul>
</li>
<li>如果执行成功，<code>getcontext</code>返回0，<code>setcontext</code>和<code>swapcontext</code>不返回；如果执行失败，<code>getcontext</code>,<code>setcontext</code>,<code>swapcontext</code>返回-1，并设置对于的errno.</li>
</ul>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>getcontext</td>
<td>获取上下文</td>
</tr>
<tr>
<td>setcontext</td>
<td>设置上下文</td>
</tr>
<tr>
<td>swapcontext</td>
<td>保存当前上下文，切换上下文</td>
</tr>
<tr>
<td>makecontext</td>
<td>创建新的上下文</td>
</tr>
</tbody></table>
<ul>
<li>例子<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">ucontext_t</span> context;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;context);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">setcontext</span>(&amp;context);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>上述函数会不断重复输出<code>Hello World</code>，因为<code>getcontext</code>将上下文设置在了输出之前，<code>setcontext</code>每次都把整个执行流返回到输出的位置</li>
</ul>
<h3 id="更换为执行时间最短先服务逻辑的调度器版本"><a href="#更换为执行时间最短先服务逻辑的调度器版本" class="headerlink" title="更换为执行时间最短先服务逻辑的调度器版本"></a>更换为执行时间最短先服务逻辑的调度器版本</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Winnerhust/uthread">参考的原版</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/frankzjz219/coThread">我改进代码的github仓库</a></li>
<li>使用了优先级队列重写携程选择逻辑，切换的时候会选择当前已经运行时间最短的携程上处理机执行</li>
<li>运行结果<ul>
<li><img src="/imgs/941347f9abd1720738aefc5d97931550f21aa9612e6620b2f0e59f887e23f2f5.png" alt="picture 0">  </li>
<li>四个线程的优先级分别是4，3，2，1，可见是符合设置的<h3 id="1月12日修改"><a href="#1月12日修改" class="headerlink" title="1月12日修改"></a>1月12日修改</h3></li>
</ul>
</li>
<li>修改为了多线程版本，分别调度，分别设置优先级</li>
<li><img src="/imgs/e31840ca773951d3d8406fb1a527485c5ca3492df2b7055bd5d175e851c5e9d0.png" alt="picture 1">  </li>
<li><img src="/imgs/d78782a55f0dc69ab765b2e962fede515994cce6269969ff93cea72ac87690e4.png" alt="picture 2">  </li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>C/C++文件编译的时候<strong>每个源文件都是独立编译的</strong>，这样会导致即使头文件使用了<code>ifndef</code>之类的保护，仍然可能在整个项目中被<strong>不同的文件</strong>引用多次<ul>
<li>因此如果头文件中出现了函数或者是变量的定义的话，这个变量在整个项目中会被定义多次</li>
<li>因此头文件中只能声明，变量使用<code>extern</code>关键字声明</li>
<li>必须定义的函数用<code>inline</code></li>
</ul>
</li>
<li>注意类的静态<code>static</code>成员变量必须在某个源文件中定义，才能在其他源文件中使用类名和作用域运算符<code>::</code>访问</li>
<li>C++可以使用宏<code>__FILE__</code>判断自己所处的文件名称</li>
<li><code>makecontext</code>的第二个参数无论传入的是什么函数，都要将其转换为<code>void(*)(void)</code>类型的函数指针，然后再给出参数</li>
<li>执行流路径<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------调度器或main中-----------------</span><br><span class="line">创建协程(create)--&gt;</span><br><span class="line">  获取互斥锁</span><br><span class="line">  使用makecontext生成开始执行协程函数的上下文</span><br><span class="line">  令目标函数的上下文的后继位置时刻指向调度器schedule的上下文main</span><br><span class="line">  释放互斥锁</span><br><span class="line">切换到协程(resume)--&gt;</span><br><span class="line">  将当前的上下文保存在调度器schedule.main中，切换到目标函数的上下文</span><br><span class="line">-----------协程函数中----------------</span><br><span class="line">切换回main(yield)--&gt;</span><br><span class="line">  获取锁</span><br><span class="line">  将协程当前的上下文保存在ctx中</span><br><span class="line">  释放锁</span><br><span class="line">  切换回之前指向的main上下文</span><br><span class="line">-----------------main中-----------------</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>因为添加协程<code>create</code>函数与协程调度器不在一个线程中，可能会有竞争关系，因此添加了互斥锁防止冲突</li>
</ul>
<h2 id="lt-setjmp-h-gt-实现切换"><a href="#lt-setjmp-h-gt-实现切换" class="headerlink" title="&lt;setjmp.h&gt;实现切换"></a><code>&lt;setjmp.h&gt;</code>实现切换</h2><h3 id="setjmp-函数："><a href="#setjmp-函数：" class="headerlink" title="setjmp 函数："></a><code>setjmp</code> 函数：</h3><ul>
<li><p><code>setjmp</code> 用于保存当前程序的执行状态，并返回一个整数值。</p>
</li>
<li><p>当首次调用 <code>setjmp</code> 时，它返回0，表示保存了当前执行状态。</p>
</li>
<li><p>当从 <code>longjmp</code> 调用返回时，<code>setjmp</code> 返回一个非零值，通常用于区分<strong>正常返回和通过 <code>longjmp</code> 返回</strong>。</p>
<h3 id="longjmp函数"><a href="#longjmp函数" class="headerlink" title="longjmp函数"></a><code>longjmp</code>函数</h3></li>
<li><p><code>longjmp</code> 用于恢复之前由 <code>setjmp</code> 保存的执行状态。</p>
</li>
<li><p>它接受两个参数：保存的执行状态（由 <code>setjmp</code> 返回的值）和一个非零的返回值。</p>
</li>
<li><p>调用 <code>longjmp</code> 会导致程序跳转到相应 <code>setjmp</code> 处，并且 <code>setjmp</code> 返回的值为 <code>longjmp</code> 的返回值。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3></li>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82492121">参考</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;do not allow division by 0\n&quot;</span>);</span><br><span class="line">        <span class="built_in">longjmp</span>(env, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">setjmp</span>(env);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;return from setjmp\n&quot;</span>);</span><br><span class="line">        <span class="built_in">my_func</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;return from longjmp: %d\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-语言的锁机制"><a href="#C-语言的锁机制" class="headerlink" title="C++语言的锁机制"></a>C++语言的锁机制</h2><h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a><code>unique_lock</code></h3></li>
<li><p><code>#include &lt;mutex&gt;</code>和<code>#include &lt;thread&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(myMutex)</span></span>;  <span class="comment">// 构造 unique_lock，并锁定互斥量</span></span><br></pre></td></tr></table></figure></li>
<li><p>构造就是加锁</p>
</li>
<li><p>析构就是解锁</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lock.<span class="built_in">lock</span>();  <span class="comment">// 手动锁定互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁定期间的其他操作...</span></span><br><span class="line"></span><br><span class="line">lock.<span class="built_in">unlock</span>();  <span class="comment">// 手动释放锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 unique_lock 离开作用域时，会自动释放锁</span></span><br></pre></td></tr></table></figure></li>
<li><p>同样支持手动操作，加锁和解锁</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%90%BA%E7%A8%8B/" rel="tag">携程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-leetcode字符串题目详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/19/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/"
    >leetcode字符串题目详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/19/leetcode%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2023-12-19T02:38:33.000Z" itemprop="datePublished">2023-12-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Leetcode-299-猜数字游戏"><a href="#Leetcode-299-猜数字游戏" class="headerlink" title="Leetcode 299. 猜数字游戏"></a>Leetcode 299. 猜数字游戏</h2><ul>
<li>遍历两个字符串，假如相同的话就加一个公牛，假如不同的话就对各自的char做数量统计（0, 1, 2, …, 9）各有多少个</li>
<li>最终母牛的结果是每个类型的char中谜底和猜测中较小的一个<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bulls = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cntS</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">cntG</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; secret.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret[i] == guess[i]) &#123;</span><br><span class="line">                ++bulls;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++cntS[secret[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">                ++cntG[guess[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            cows += <span class="built_in">min</span>(cntS[i], cntG[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(bulls) + <span class="string">&quot;A&quot;</span> + <span class="built_in">to_string</span>(cows) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-316-去除重复字母"><a href="#Leetcode-316-去除重复字母" class="headerlink" title="Leetcode 316. 去除重复字母"></a>Leetcode 316. 去除重复字母</h2><ul>
<li>对已经入栈的字符而言，只要后面还出现而且字典顺序大于当前字符的一律弹出，将标记重新设置为0</li>
<li>然后加入当前字符，并且设置已经过标记为1</li>
<li>意义就是将较大而且后面还出现的字符的出现尽量推迟靠后<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(<span class="number">26</span>)</span>, <span class="title">num</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">            num[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string stk;</span><br><span class="line">        <span class="comment">// 对已经入栈的字符而言，只要后面还出现而且字典顺序大于当前字符的一律弹出，将标记重新设置为0</span></span><br><span class="line">        <span class="comment">// 然后加入当前字符，并且设置已经过标记为1</span></span><br><span class="line">        <span class="comment">// 意义就是将较大而且后面还出现的字符的出现尽量推迟靠后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[ch - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">back</span>() &gt; ch) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num[stk.<span class="built_in">back</span>() - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        vis[stk.<span class="built_in">back</span>() - <span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">                        stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                vis[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">                stk.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            num[ch - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-动态规划（二）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/"
    >动态规划（二）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time datetime="2023-12-12T09:01:13.000Z" itemprop="datePublished">2023-12-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Leetcode-718-最长重复子数组"><a href="#Leetcode-718-最长重复子数组" class="headerlink" title="Leetcode 718. 最长重复子数组"></a>Leetcode 718. 最长重复子数组</h2><ul>
<li>递推，使用上一个位置的连续长度加上这个位置是否相等递推出这个位置的</li>
<li>如果相等，就是到<code>i-1</code>,<code>j-1</code>位置为止的连续长度+1<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(nums1.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(nums2.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;nums2.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        map[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        map[i][j] = map[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxLen = <span class="built_in">max</span>(map[i][j], maxLen);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-115-不同的子序列"><a href="#Leetcode-115-不同的子序列" class="headerlink" title="Leetcode 115. 不同的子序列"></a>Leetcode 115. 不同的子序列</h2><ul>
<li>因为是从s中找t，所以递归的主要顺序是t找到了哪个位置</li>
<li>假如s的<code>i</code>位置与t的<code>j</code>相等，那么该位置的子字符串种类就是<code>i-1</code>和<code>j-1</code>位置位置+t到<code>j</code>位置时之前的种类之和</li>
<li>不等的话，就继承s字符串在之前位置，j字符串在当前位置的种类数量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(t.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=t.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j]=(map[i<span class="number">-1</span>][j<span class="number">-1</span>]+map[i<span class="number">-1</span>][j])%((<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>); <span class="comment">// 此处就是求和t字符串到j位置的所有可能性（包括s字符串之前的可能性）</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = map[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-583-两个字符串的删除操作"><a href="#Leetcode-583-两个字符串的删除操作" class="headerlink" title="Leetcode 583. 两个字符串的删除操作"></a>Leetcode 583. 两个字符串的删除操作</h2><ul>
<li><p>从<code>i-1</code>和<code>j-1</code>递推<code>i</code>和<code>j</code></p>
</li>
<li><p>当<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>相同的时候，<code>dp[i][j] = dp[i - 1][j - 1]</code></p>
</li>
<li><p>当<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>不相同的时候，有三种情况：</p>
<ul>
<li><p>情况一：删<code>word1[i - 1]</code>，最少操作次数为<code>dp[i - 1][j] + 1</code></p>
</li>
<li><p>情况二：删<code>word2[j - 1]</code>，最少操作次数为<code>dp[i][j - 1] + 1</code></p>
</li>
<li><p>情况三：同时删<code>word1[i - 1]</code>和<code>word2[j - 1]</code>，操作的最少次数为<code>dp[i - 1][j - 1] + 2</code></p>
</li>
</ul>
</li>
<li><p>那最后当然是取最小值，所以当<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>不相同的时候，递推公式：<code>dp[i][j] = min(&#123;dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1&#125;);</code></p>
</li>
<li><p>因为 <code>dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2</code>，所以递推公式可简化为：<code>dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</code></p>
<ul>
<li>因为对于<code>dp[i][j-1]</code>而言，就是第一个字符串到<code>i-1</code>位置和第二个字符串到<code>j-2</code>位置，第一个字符串增加一步删除就可以到<code>i-2</code>和<code>j-2</code>的位置，因此二者只差一步</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode-72-编辑距离"><a href="#Leetcode-72-编辑距离" class="headerlink" title="Leetcode 72. 编辑距离"></a>Leetcode 72. 编辑距离</h2><ul>
<li>此题遇上一个类似，只是增加了几个操作<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-1035-不相交的线"><a href="#Leetcode-1035-不相交的线" class="headerlink" title="Leetcode 1035. 不相交的线"></a>Leetcode 1035. 不相交的线</h2><ul>
<li>此题同样是类似的动态规划</li>
<li>利用<code>i-1</code>和<code>j-1</code>推导<code>i</code>和<code>j</code>位置的值</li>
<li>如果当前位置相等，此时则是在<code>i-1</code>和<code>j-1</code>位置的基础上<code>+1</code></li>
<li>因为递推的上一级是<code>i-1</code>和<code>j-1</code>，这就导致<u>之前的连线最多只涉及之前的数字，不会于新加入的相交</u>，从而防止了相交<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, vector&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(B.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B.<span class="built_in">size</span>(); j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[A.<span class="built_in">size</span>()][B.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-1143-最长公共子序列"><a href="#Leetcode-1143-最长公共子序列" class="headerlink" title="Leetcode 1143. 最长公共子序列"></a>Leetcode 1143. 最长公共子序列</h2><ul>
<li><strong>暴力递归方法（或者动态规划）</strong></li>
<li>每次两个字符串往前走一个位置（比如到达i, j），假如两个字符串在这个位置的值相同，那么就以(i-1, j-1)位置的最长子串的长度+1作为当前位置的值</li>
<li>否则，就从两个字符串分别到（i-1，j）和（i，j-1）位置选择一个较大的作为结果<ul>
<li><strong><u>这么做的关键原因（也就是遇上一题的区别）就是因为这个不必须是连续的</u></strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="LeetCode-72-编辑距离"><a href="#LeetCode-72-编辑距离" class="headerlink" title="LeetCode 72. 编辑距离"></a>LeetCode 72. 编辑距离</h2><ul>
<li>创建一个二维数组，一个维度是第一个字符串的长度，另一个是第二个字符串的长度</li>
<li>当 <code>word1[i] == word2[j]</code>，<code>dp[i][j] = dp[i-1][j-1]</code></li>
<li>当 <code>word1[i] != word2[j]</code>，<code>dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1</code></li>
<li>其中，<code>dp[i-1][j-1]</code> 表示<strong>替换</strong>操作，<code>dp[i-1][j]</code> 表示<strong>删除</strong>操作，<code>dp[i][j-1]</code> 表示<strong>插入</strong>操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> n = word2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, INT_MAX));</span><br><span class="line">        map[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>&amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = map[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = map[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = map[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    map[i][j] = <span class="built_in">min</span>(map[i<span class="number">-1</span>][j], <span class="built_in">min</span>(map[i][j<span class="number">-1</span>], map[i<span class="number">-1</span>][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-474-一和零"><a href="#Leetcode-474-一和零" class="headerlink" title="Leetcode 474. 一和零"></a>Leetcode 474. 一和零</h2><ul>
<li>此题主要是从一个数组中选择几个元素组成某个目的</li>
<li>本质上是遍历每个元素然后决定要/不要的问题</li>
<li>所以遍历每个元素的时候要针对<strong>要这个元素</strong>和<strong>不要这个元素</strong>做出两种情况的递推。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// int maxLen;</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; lenMap;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">smap</span>(strs.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// lenMap</span></span><br><span class="line">        <span class="comment">// maxLen = 0;</span></span><br><span class="line">        lenMap = vector&lt;vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt;(strs.<span class="built_in">size</span>()+<span class="number">1</span>, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">-1</span>)));</span><br><span class="line">        lenMap[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;strs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(index&lt;strs[i].<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                ++smap[i][strs[i][index++] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;strs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;=m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;=n; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(lenMap[i][j][k]&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    lenMap[i+<span class="number">1</span>][j][k]=<span class="built_in">max</span>(lenMap[i][j][k], lenMap[i+<span class="number">1</span>][j][k]); </span><br><span class="line">                    <span class="keyword">if</span>(j+smap[i][<span class="number">0</span>]&lt;=m &amp;&amp; k+smap[i][<span class="number">1</span>]&lt;=n)</span><br><span class="line">                    &#123;</span><br><span class="line">                        lenMap[i+<span class="number">1</span>][j+smap[i][<span class="number">0</span>]][k+smap[i][<span class="number">1</span>]] = <span class="built_in">max</span>(lenMap[i][j][k]+<span class="number">1</span>, lenMap[i+<span class="number">1</span>][j+smap[i][<span class="number">0</span>]][k+smap[i][<span class="number">1</span>]]);</span><br><span class="line">                        maxLen = <span class="built_in">max</span>(maxLen, lenMap[i+<span class="number">1</span>][j+smap[i][<span class="number">0</span>]][k+smap[i][<span class="number">1</span>]]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen&lt;<span class="number">0</span>?<span class="number">0</span>:maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a>647. 回文子串</h2><ul>
<li>注意循环顺序，从中间到两边，所以要从<strong>末端开始</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><ul>
<li>此题大体与上面类似，唯一的区别是不需连续</li>
<li>因此需要在条件不成立的时候使用<code>dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</code>保存结果递推<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> result = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) </span><br><span class="line">                    &#123; </span><br><span class="line">                        <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        dp[i][j] = j-i+<span class="number">1</span>;</span><br><span class="line">                        result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                        result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul>
<li>从大序列中找小序列的问题，假如是连续序列的话，不满足对应的条件的时候可以不处理</li>
<li>但是假如不是连续序列的话，往往需要类似于<code>dp[i][j] = max(dp[i+1][j], dp[i][j-1]);</code>的操作来保存递推结果</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Leetcode数组题目"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/06/Leetcode%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE/"
    >Leetcode数组题目</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/06/Leetcode%E6%95%B0%E7%BB%84%E9%A2%98%E7%9B%AE/" class="article-date">
  <time datetime="2023-12-06T07:12:07.000Z" itemprop="datePublished">2023-12-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="LeetCode-153-寻找旋转排序数组中的最小值"><a href="#LeetCode-153-寻找旋转排序数组中的最小值" class="headerlink" title="LeetCode 153. 寻找旋转排序数组中的最小值"></a>LeetCode 153. 寻找旋转排序数组中的最小值</h2><ul>
<li>我们考虑数组中的最后一个元素<code>x</code>：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定都严格小于<code>x</code>；而在最小值左侧的元素，它们的值一定都严格大于<code>x</code>。因此，我们可以根据这一条性质，通过二分查找的方法找出最小值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-4-寻找两个正序数组的中位数"><a href="#Leetcode-4-寻找两个正序数组的中位数" class="headerlink" title="Leetcode 4. 寻找两个正序数组的中位数"></a>Leetcode 4. 寻找两个正序数组的中位数</h2></li>
<li>此题较为复杂，建议查看<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/?envType=study-plan-v2&envId=top-100-liked">题解</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="keyword">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="keyword">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-136-只出现一次的数字"><a href="#Leetcode-136-只出现一次的数字" class="headerlink" title="Leetcode 136. 只出现一次的数字"></a>Leetcode 136. 只出现一次的数字</h2><ul>
<li>对整个数组元素挨个求异或，最后剩下的一个就是只出现一次的那个</li>
<li>因为出现过两次的会因为自己异或自己而变为0<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            sum^=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="LeetCode-31-下一个排列"><a href="#LeetCode-31-下一个排列" class="headerlink" title="LeetCode 31. 下一个排列"></a>LeetCode 31. 下一个排列</h2><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/solutions/80560/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/">参考</a></li>
<li>从后向前 查找第一个 相邻升序 的元素对 <code>(i,j)</code>，满足 <code>A[i] &lt; A[j]</code>。此时 <code>[j,end)</code> 必然是降序</li>
<li>在 <code>[j,end)</code> 从后向前 查找第一个满足 <code>A[i] &lt; A[k]</code> 的 <code>k</code>。<code>A[i]</code>、<code>A[k]</code> 分别就是上文所说的「小数」、「大数」</li>
<li>将 <code>A[i]</code> 与 <code>A[k]</code> 交换</li>
<li>可以断定这时 <code>[j,end)</code> 必然是降序，逆置 <code>[j,end)</code>，使其升序</li>
<li>如果在步骤 1 找不到符合的相邻元素对，说明当前 <code>[begin,end)</code> 为一个降序顺序，则直接跳到步骤 4</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=nums.<span class="built_in">size</span>(),i=l<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=l<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//找出nums[i]后面大于nums[i]的最小数的下标</span></span><br><span class="line">            <span class="keyword">while</span>(nums[j]&lt;=nums[i])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>());<span class="comment">//交换完后对nums[i]后面的数字进行从小到大排列</span></span><br><span class="line">            <span class="comment">//因为此时nums.begin()+i+1到nums.end()一定是降序排列,所以只需reverse就是从小到大排列了</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//说明是最大排列,下一个应该是最小排列</span></span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode-452-用最少数量的箭引爆气球"><a href="#Leetcode-452-用最少数量的箭引爆气球" class="headerlink" title="Leetcode 452. 用最少数量的箭引爆气球"></a>Leetcode 452. 用最少数量的箭引爆气球</h2><ul>
<li>按照区间的<strong>右端点排序</strong>，取右端点的值，直到目前的区间的右端点的值小于下一个区间的左端点的值的时候就说明没有重叠部分了，需要增加新的区间<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; u, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> pos = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; balloon: points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (balloon[<span class="number">0</span>] &gt; pos) &#123;</span><br><span class="line">                pos = balloon[<span class="number">1</span>];</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Leetcode图相关遍历"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/12/05/Leetcode%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%81%8D%E5%8E%86/"
    >Leetcode图相关遍历</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/12/05/Leetcode%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%81%8D%E5%8E%86/" class="article-date">
  <time datetime="2023-12-05T08:25:50.000Z" itemprop="datePublished">2023-12-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="图的拓扑排序"><a href="#图的拓扑排序" class="headerlink" title="图的拓扑排序"></a>图的拓扑排序</h2><h3 id="广度优先搜索（Leetcode-207-课程表）"><a href="#广度优先搜索（Leetcode-207-课程表）" class="headerlink" title="广度优先搜索（Leetcode 207.课程表）"></a>广度优先搜索（Leetcode 207.课程表）</h3><ul>
<li>用一个数组记录每个节点的进入边的数量</li>
<li>开始的时候将所有入度为0的点加入队列</li>
<li>依次从队列中弹出点，将从这个点出发指向的所有点的入度-1，然后将跟这个点相关的路径全部删除<ul>
<li>假如此时遇到点的入度是0的话，将这个点加入队列</li>
</ul>
</li>
<li>将队列中弹出的点加入输出序列中</li>
<li>假如最后图上的<strong>所有点都在输出序列中</strong>，说明无环，否则有环<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">vMap</span>(numCourses);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inCnt</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prerequisites.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vMap[prerequisites[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            ++inCnt[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inCnt[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:vMap[temp])</span><br><span class="line">            &#123;</span><br><span class="line">                --inCnt[i];</span><br><span class="line">                <span class="keyword">if</span>(inCnt[i] == <span class="number">0</span>)q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            vMap[temp] = vector&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>()&lt;numCourses)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul>
<li>遍历所有节点，先标记自己被遍历过了</li>
<li>每个节点递归的遍历<strong>自己所有边</strong>指向的没有被打上遍历过的标签的节点</li>
<li>回溯的时候（也就是之后的节点都遍历结束之后）将自己添加到拓扑顺序的栈中</li>
<li>依次弹出栈中元素，得到顺序<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vertices;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Graph</span>(<span class="keyword">int</span> V) : <span class="built_in">vertices</span>(V), <span class="built_in">adjList</span>(V) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        adjList[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topologicalSortUtil</span><span class="params">(<span class="keyword">int</span> v, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited, stack&lt;<span class="keyword">int</span>&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        visited[v] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : adjList[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                <span class="built_in">topologicalSortUtil</span>(neighbor, visited, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(vertices, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertices; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">topologicalSortUtil</span>(i, visited, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Topological Sort: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!result.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; result.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            result.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    g.<span class="built_in">addEdge</span>(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">topologicalSort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Leetcode-127-单词接龙"><a href="#Leetcode-127-单词接龙" class="headerlink" title="Leetcode 127. 单词接龙"></a>Leetcode 127. 单词接龙</h2><ul>
<li>此题是讲字母相邻的单词组织成一张图</li>
<li>实际上是求图上两个点的最近距离</li>
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/solutions/473600/dan-ci-jie-long-by-leetcode-solution/?envType=study-plan-v2&envId=top-interview-150">题解</a></li>
<li>广度优先搜索法<ul>
<li>每循环一次，找一个没有接触过的位置，将其距离更新为接触过的位置+1，然后也放入队列遍历</li>
<li>注意，只考虑之前没有加入过的点，防止环的影响<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; wordId;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; edge;</span><br><span class="line">    <span class="keyword">int</span> nodeNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordId.<span class="built_in">count</span>(word)) &#123;</span><br><span class="line">            wordId[word] = nodeNum++;</span><br><span class="line">            edge.<span class="built_in">emplace_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(string&amp; word)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addWord</span>(word);</span><br><span class="line">        <span class="keyword">int</span> id1 = wordId[word];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>&amp; it : word) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = it;</span><br><span class="line">            it = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="built_in">addWord</span>(word);</span><br><span class="line">            <span class="keyword">int</span> id2 = wordId[word];</span><br><span class="line">            edge[id1].<span class="built_in">push_back</span>(id2);</span><br><span class="line">            edge[id2].<span class="built_in">push_back</span>(id1);</span><br><span class="line">            it = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; word : wordList) &#123;</span><br><span class="line">            <span class="built_in">addEdge</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">addEdge</span>(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (!wordId.<span class="built_in">count</span>(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(nodeNum, INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> beginId = wordId[beginWord], endId = wordId[endWord];</span><br><span class="line">        dis[beginId] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(beginId);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (x == endId) &#123;</span><br><span class="line">                <span class="keyword">return</span> dis[endId] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>&amp; it : edge[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[it] == INT_MAX) &#123;</span><br><span class="line">                    dis[it] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Leetcode/" rel="tag">Leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2024
        <i class="ri-heart-fill heart_icon"></i> FrankZhang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.png" alt="Frank’s blogs"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>