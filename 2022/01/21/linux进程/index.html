<!DOCTYPE html>


<html lang="Chinese">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>linux进程 |  Frank’s blogs</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/FLogo.png" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-linux进程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  linux进程
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/21/linux%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2022-01-21T05:26:22.000Z" itemprop="datePublished">2022-01-21</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">22 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h1><ul>
<li>main传参</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></table></figure>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li><p>进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后 它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。</p>
</li>
<li><p>Linux 系统下的每一个进程都有一个进程号（processID，简称 PID），进程号是一个正数，用于唯一标 识系统中的某一个进程。在 Ubuntu 系统下执行 **<code>ps -aux </code>**命令可以查到系统中进程相关的一些信息，包括每个进程 的进程号</p>
</li>
<li><p><img src="/../imgs/image-20220121134232404.png" alt="image-20220121134232404"></p>
</li>
<li><p>通过系统调用 getpid()来获取<strong>本进程</strong>的进程号</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>还可以使用 getppid()系统调用获取父进程的进程号</li>
</ul>
<h2 id="进程的环境变量"><a href="#进程的环境变量" class="headerlink" title="进程的环境变量"></a>进程的环境变量</h2><ul>
<li><p>每一个进程都有一组与其相关的环境变量，这些环境变量以字符串形式存储在一个字符串数组列表中， 把这个数组称为环境列表。其中每个字符串都是以<strong>“名称=值（name=value）”</strong>形式定义</p>
</li>
<li><p>在 shell 终端下可以使用 env 命令查看到 shell 进程的所有环境变量</p>
</li>
<li><p>使用 export 命令还可以添加一个新的环境变量或删除一个环境变量</p>
<ul>
<li><code>export LINUX_APP=123456</code></li>
</ul>
</li>
<li><p>使用”export -n LINUX_APP”命令则可以删除 LINUX_APP 环境变量</p>
<ul>
<li><code>export -n LINUX_APP</code></li>
</ul>
</li>
</ul>
<p>环境变量存放在一个字符串数组中，在应用程序中，通过 environ 变量指向它，environ 是一个全局变 量，在我们的应用程序中只需申明它即可使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ; <span class="comment">// 申明外部全局变量 environ</span></span><br></pre></td></tr></table></figure>

<p>如果只想要<strong>获取某个指定的环境变量</strong>，可以使用库函数 getenv()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不应该去修改其返回的字符串，修改该字符串意味着修改了环境变量对应的值</p>
</li>
<li><p><strong>添加/修改</strong>环境变量</p>
</li>
<li><p>putenv()函数</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​            string：参数 string 是一个字符串指针，指向 name=value 形式的字符串。 </p>
<p>​            返回值：成功返回 0；失败将返回非 0 值，并设置 errno。</p>
<ul>
<li>setenv()函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​            name：需要添加或修改的环境变量名称。 </p>
<p>​            value：环境变量的值。 </p>
<p>​            overwrite：若参数 name 标识的环境变量已经存在，在参数 overwrite 为 0 的情况下，setenv()函数将不 改变现有环境变量的值，也就是说本次调用没有产生任何影响；如果参数 overwrite 的值为非 0，若参数 name 标识的环境变量已经存在，则覆盖，不存在则表示添加新的环境变量。</p>
<p>​             返回值：成功返回 0；失败将返回-1，并设置 errno。</p>
<p>​        setenv()函数为<strong>形如 name=value 的字符串</strong>分配一块内存缓冲区，并将参数 name 和参数 value 所指向的 字符串复制到此缓冲区中，以此来创建一个新的环境变量</p>
<ul>
<li>除了上面给大家介绍的函数之外，我们还可以通过一种更简单地方式向进程环境变量表中添加环境变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME=value ./app</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在执行程序的时候，<strong>在其路径前面添加环境变量，以 name=value 的形式添加</strong>，如果是<strong>多个</strong>环境变量， 则在./app 前面放置多对 name=value 即可，以<strong>空格分隔</strong>。</p>
</li>
<li><p>清除环境变量：</p>
<ul>
<li><code>environ = NULL;</code>或者</li>
<li>使用stdlib中的<code>int clearenv(void);</code></li>
</ul>
</li>
</ul>
<h3 id="环境变量的作用"><a href="#环境变量的作用" class="headerlink" title="环境变量的作用"></a>环境变量的作用</h3><ul>
<li>环境变量常见的用途之一是在 shell 中，每一个环境变量都有它所表示的含义，譬如 HOME 环境变量表 示用户的家目录，USER 环境变量表示当前用户名，SHELL 环境变量表示 shell 解析器名称，PWD 环境变 量表示当前所在目录等，在我们自己的应用程序当中，也可以使用进程的环境变量。</li>
</ul>
<h2 id="进程的内存布置"><a href="#进程的内存布置" class="headerlink" title="进程的内存布置"></a>进程的内存布置</h2><ul>
<li><p><strong>正文段。</strong>也可称为代码段，这是 CPU 执行的机器语言指令部分，文本段具有只读属性，以防止程 序由于意外而修改其指令；正文段是可以共享的，即使在多个进程间也可同时运行同一段程序。</p>
</li>
<li><p><strong>初始化数据段。</strong>通常将此段称为数据段，包含了显式初始化的全局变量和静态变量，当程序加载到 内存中时，从可执行文件中读取这些变量的值。</p>
</li>
<li><p><strong>未初始化数据段</strong>。包含了<strong>未进行显式初始化的全局变量和静态变量</strong>，通常将此段称为 bss 段，这一 名词来源于早期汇编程序中的一个操作符，意思是“由符号开始的块”（block started by symbol）， 在程序开始执行之前，系统会将本段内所有内存初始化为 0，可执行文件并没有为 bss 段变量分配 存储空间，在可执行文件中只需记录 bss 段的位置及其所需大小，直到程序运行时，由加载器来分 配这一段内存空间。</p>
</li>
<li><p><strong>栈。</strong>函数内的<strong>局部变量</strong>以及每次函数调用时所需保存的信息都放在此段中，每次调用函数时，函数 传递的实参以及函数返回值等也都存放在栈中。栈是一个动态增长和收缩的段，由栈帧组成，系统 会为每个当前调用的函数分配一个栈帧，栈帧中存储了函数的局部变量（所谓自动变量）、实参和 返回值。</p>
</li>
<li><p><strong>堆</strong>。可在运行时<strong>动态进行内存分配</strong>的一块区域，譬如使用 **malloc()**分配的内存空间，就是从系统堆 内存中申请分配的。</p>
</li>
<li><p><img src="/../imgs/image-20220121141423676.png" alt="image-20220121141423676"></p>
</li>
</ul>
<h2 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h2><ul>
<li><p>在 32 位系统中，每个进程的逻辑地址空间均为 4GB，这 4GB 的内存空间按照 3:1 的比例 进行分配，其中用户进程享有 3G 的空间，而内核独自享有剩下的 1G 空间，如下所示：</p>
</li>
<li><p><img src="/../imgs/image-20220121141526808.png" alt="image-20220121141526808"></p>
</li>
<li><p>学习过驱动开发的读者对“虚拟地址”这个概念应该并不陌生，虚拟地址会通过硬件 <strong>MMU（内存管理 单元）</strong>映射到实际的物理地址空间中，建立虚拟地址到物理地址的映射关系后，对虚拟地址的读写操作实际 上就是对物理地址的读写操作，MMU 会将物理地址“翻译”为对应的物理地址</p>
<ul>
<li>虚拟地址解决的问题</li>
<li><strong>内存使用效率低</strong>。内存空间不足时，就需要将其它程序暂时拷贝到硬盘中，然后将新的程序装入内 存。然而由于大量的数据装入装出，内存的使用效率就会非常低。（实际上不会真正给程序分配所有的空间，程序用到的时候才会分配空间）</li>
<li>进程地址<strong>空间不隔离</strong>。由于程序是直接访问物理内存的，所以每一个进程都可以修改其它进程的 内存数据，甚至修改内核地址空间中的数据，所以有些恶意程序可以随意修改别的进程，就会造成 一些破坏，系统不安全、不稳定。</li>
<li>无法<strong>确定程序的链接地址</strong>。程序运行时，链接地址和运行地址必须一致，否则程序无法运行！因为 程序代码加载到内存的地址是由系统随机分配的，是无法预知的，所以程序的运行地址在编译程序 时是无法确认的。</li>
<li>在某些应用场合下，两个或者更多进程能够共享内存。因为每个进程都有自己的映射表，可以让不 同进程的虚拟地址空间映射到相同的物理地址空间中。通常，共享内存可用于实现进程间通信。</li>
<li>便于实现内存保护机制。譬如在多个进程共享内存时，允许每个进程对内存采取不同的保护措施， 例如，一个进程可能以只读方式访问内存，而另一进程则能够以可读可写的方式访问。</li>
</ul>
</li>
</ul>
<h3 id="创建子线程"><a href="#创建子线程" class="headerlink" title="创建子线程"></a>创建子线程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>fork()调用成功后，将会<strong>在父进程中返回子进程的 PID</strong>，而<strong>在子进程中返回值是 0</strong>；如果调用失败，父进 程返回值-1，不创建子进程，并设置 errno。 </li>
<li>fork()系统调用的关键在于，完成对其调用后将存在两个进程，一个是原进程（父进程）、另一个 则是创建出来的子进程，并且<strong>每个进程都会从 fork()函数的返回处继续执行</strong>，会导致调用 fork()返回两次值， <strong>子进程返回一个值、父进程返回一个值</strong>。在程序代码中，可通过返回值来区分是子进程还是父进程。</li>
<li>fork()调用成功后，子进程和父进程会<strong>继续执行 fork()调用之后的指令</strong>，子进程、父进程<strong>各自在自己的进 程空间中运行</strong>。事实上，<strong>子进程是父进程的一个副本，譬如子进程拷贝了父进程的数据段、堆、栈以及继承 了父进程打开的文件描述符，父进程与子进程并不共享这些存储空间</strong>，这是子进程对父进程相应<strong>部分存储 空间的完全复制</strong>，执行 fork()之后，每个进程均可修改各自的栈数据以及堆段中的变量，而并不影响另一个 进程。</li>
<li>虽然子进程是父进程的一个副本，但是对于程序代码段（文本段）来说，<strong>两个进程执行相同的代码段</strong>， 因为代码段是只读的，也就是说父子进程共享代码段，在内存中只存在一份代码段数据。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">pid_t</span> pid;</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">switch</span> (pid) </span><br><span class="line"> 	&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">         perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;这是子进程打印信息&lt;pid: %d, 父进程 pid: %d&gt;\n&quot;</span>,</span><br><span class="line">         getpid(), getppid());</span><br><span class="line">         _exit(<span class="number">0</span>); <span class="comment">//子进程使用_exit()退出</span></span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;这是父进程打印信息&lt;pid: %d, 子进程 pid: %d&gt;\n&quot;</span>,</span><br><span class="line">         getpid(), pid);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进程和子进程之间的文件共享"><a href="#进程和子进程之间的文件共享" class="headerlink" title="进程和子进程之间的文件共享"></a>进程和子进程之间的文件共享</h3><ul>
<li><p>调用 fork()函数之后，子进程会获得父进程所有文件描述符的副本，这些副本的创建方式类似于 dup()， 这也意味着父、子进程对应的文件描述符均指向相同的文件表</p>
</li>
<li><p><img src="/../imgs/image-20220121181944858.png" alt="image-20220121181944858"></p>
</li>
<li><p>由此可知，<strong>子进程拷贝了父进程的文件描述符表</strong>，使得父、子进程中对应的<strong>文件描述符指向了相同的文 件表</strong>，也意味着父、子进程中对应的文件描述符指向了磁盘中相同的文件，因而这些文件在父、子进程间实 现了共享，譬如，如果<strong>子进程更新了文件偏移量，那么这个改变也会影响到父进程中相应文件描述符的位置 偏移量</strong>。</p>
</li>
<li><p><strong>假如是父子进程分别打开同一个文件的话（在fork()之后），则读写文件会互相覆盖，因为偏移量没有互相影响</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">switch</span> (pid)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        fd = open(<span class="string">&quot;./Text.txt&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt; fd)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            _exit(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//循环写入 4 次</span></span><br><span class="line">            write(fd, <span class="string">&quot;1122&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        fd = open(<span class="string">&quot;./Text.txt&quot;</span>, O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt; fd)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="comment">//循环写入 4 次</span></span><br><span class="line">            write(fd, <span class="string">&quot;AABB&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>父进程写入5次，子进程写入4次，最终的输出为</p>
<ul>
<li><img src="/../imgs/image-20220121184306317.png" alt="image-20220121184306317"></li>
</ul>
</li>
<li><p><code>vfork()</code></p>
</li>
<li><p>除了 fork()系统调用之外，Linux 系统还提供了 vfork()系统调用用于创建子进程，vfork()与 fork()函数在 功能上是相同的，并且返回值也相同，在一些细节上存在区别</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">vfork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从前面的介绍可知，可以将 fork()认作对父进程的数据段、堆段、栈段以及其它一些数据结构创建拷贝， 由此可以看出，使用 fork()系统调用的代价是很大的，它复制了父进程中的数据段和堆栈段中的绝大部分内 容，这将会消耗比较多的时间，效率会有所降低，<strong>而且太浪费</strong>，原因有很多，其中之一在于，<strong>fork()函数之 后子进程通常会调用 exec 函数</strong>.子进程<strong>不再执行父程序中的代码 段</strong>，而是执行新程序的代码段，从新程序的 main 函数开始执行、并为新程序重新<strong>初始化其数据段、堆段、 栈段等.</strong></p>
</li>
<li><p>出于这一原因，引入了 vfork()系统调用，虽然在一些细节上有所不同，但其效率要高于 fork()函数。类 似于 fork()，vfork()可以为调用该函数的进程创建一个新的子进程，然而，vfork()是为子进程<strong>立即执行 exec()</strong> 新的程序而专门设计的</p>
<ul>
<li>vfork的区别：<ul>
<li>vfork()与 fork()一样都创建了子进程，但 vfork()函数并不会将父进程的地址空间完全复制到子进程 中，因为子进程会立即调用 exec（或_exit），于是也就不会引用该地址空间的数据。不过在子进程 调用 exec 或_exit 之前，它<strong>在父进程的空间中运行</strong>、子进程<strong>共享父进程的内存</strong>。这种优化工作方式 的实现提高的效率；但如果子进程修改了父进程的数据（除了 vfork 返回值的变量）、进行了函数 调用、或者没有调用 exec 或_exit 就返回将可能带来未知的结果。</li>
<li>另一个区别在于，vfork()保证<strong>子进程先运行</strong>，<strong>子进程调用 exec 之后父进程才可能被调度运行</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>现代的 Linux 系统内核已经采 用了写时复制技术来实现 fork()，其效率较之于早期的 fork()实现要高出许多，除非速度绝对重要的场合， 我们的程序当中应舍弃 vfork()而使用 fork()。</p>
</li>
<li><p>调用 fork()之后，子进程成为了一个独立的进程，可被系统调度运行，而父进程也继续被系统调度运行， 这里出现了一个问题，调用 fork 之后，<strong>无法确定父、子两个进程谁将率先访问 CPU</strong></p>
</li>
<li><p>此时可以采用先让某个进程堵塞，然后另一个进程<strong>向其发送信号将其唤醒</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;接收到信号\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">sigset_t</span> wait_mask;</span><br><span class="line">    <span class="comment">/* 初始化信号集 */</span></span><br><span class="line">    sigemptyset(&amp;wait_mask);</span><br><span class="line">    <span class="comment">/* 设置信号处理方式 */</span></span><br><span class="line">    sig.sa_handler = sig_handler;</span><br><span class="line">    sig.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGUSR1, &amp;sig, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程开始执行\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子进程打印信息\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;~~~~~~~~~~~~~~~\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        kill(getppid(), SIGUSR1); <span class="comment">//发送信号给父进程、唤醒它</span></span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> != sigsuspend(&amp;wait_mask)) <span class="comment">//挂起、阻塞</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程开始执行\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父进程打印信息\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中的父进程先通过调用<code>sigsuspend(&amp;wait_mask)</code>堵塞，然后等待子线程发送<code>kill(getppid(), SIGUSR1)</code>发送信号将其唤醒</li>
</ul>
<p><strong>init 进程的 PID 总是为 1，它是所有子进程的父进程，一切从 1 开始、一切从 init 进程开始</strong></p>
<h3 id="进程的退出"><a href="#进程的退出" class="headerlink" title="进程的退出"></a>进程的退出</h3><ul>
<li>如果程序中注册了进程终止处理函数，那么会调用终止处理函数。在 9.1.2 小节给大家介绍如何注 册进程的终止处理函数；</li>
<li><strong>刷新 stdio 流缓冲区</strong>。</li>
<li>执行_exit()系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (fork())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个程序会将其中的”Hello World”打印两次，但是假如上述字符串包含换行符的话就不会打印显示，原因如下</p>
<ul>
<li>进程的用户空间内存中维护了 stdio 缓冲区，0 小节给大家 介绍过，因此通过 fork()创建子进程时会复制这些缓冲区。标准输出设备默认使用的是行缓冲，当检测到换 行符\n 时会立即显示函数 printf()输出的字符串，此时输出之后的缓冲区的空的</li>
<li>假如没有换行符的话，系统并不会立即输出内容，这就导致在创建子线程的时候会将缓冲去等待显示的字符串也拷贝一次。当它们<strong>调用 exit()函数时，都会刷 新各自的缓冲区、显示字符串</strong>，所以就会看到打印出了两次相同的字符串<ul>
<li>防止上述问题的办法</li>
<li>在调用 fork()之前，使用函数 <code>fflush()</code>来刷新 stdio 缓冲区，当然，作为另一种选择，也可以使用 setvbuf()和 setbuf()来关闭 stdio 流的缓冲功能</li>
</ul>
</li>
</ul>
<h3 id="监视子进程"><a href="#监视子进程" class="headerlink" title="监视子进程"></a>监视子进程</h3><ul>
<li>系统调用 wait()可以等待进程的任一子进程终止，同时获取子进程 的终止状态信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>status：参数 status 用于存放子进程终止时的状态信息，参数 status 可以为 NULL，表示不接收子进程 终止时的状态信息。</p>
</li>
<li><p> 返回值：若成功则返回终止的子进程对应的进程号；失败则返回-1。</p>
</li>
<li><p>wait函数的内容</p>
<ul>
<li>调用 wait()函数，如果其所有子进程都还在运行，则 <strong>wait()会一直阻塞等待，直到某一个子进程终 止</strong>；</li>
<li>如果进程调用 wait()，但是该进程并没有子进程，也就意味着该进程<strong>并没有需要等待的子进程，那 么 wait()将返回错误，也就是返回-1</strong>、并且会将 errno 设置为 ECHILD。</li>
<li>如果进程调用 wait()之前，它的子进程当中<strong>已经有一个或多个子进程已经终止了，那么调用 wait() 也不会阻塞</strong>。wait()函数的作用除了获取子进程的终止状态信息之外，更重要的一点，就是回收子 进程的一些资源，俗称为子进程“收尸”，关于这个问题后面再给大家进行介绍。所以在调用 wait() 函数之前，已经有子进程终止了，意味着正等待着父进程为其“收尸”，所以调用 wait()将不会阻 塞，而是会立即替该子进程“收尸”、处理它的“后事”，然后返回到正常的程序流程中，<strong>一次 wait() 调用只能处理一次</strong>。</li>
<li>参数 status 不为 NULL 的情况下，则 wait()会将子进程的终止时的状态信息存储在它指向的 int 变量中， 可以通过宏来检查 status 参数（略）</li>
</ul>
</li>
<li><p><code>waitpid()</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pid：参数 pid 用于表示需要等待的某个具体子进程，关于参数 pid 的取值范围如下：</p>
<ul>
<li>如果 pid 大于 0，表示等待进程号为 pid 的子进程；</li>
<li>如果 pid 等于 0，则等待与调用进程（父进程）同一个进程组的所有子进程；</li>
<li>如果 pid 小于-1，则会等待进程组标识符与 pid 绝对值相等的所有子进程；</li>
<li>如果 pid 等于-1，则等待任意子进程。wait(&amp;status)与 waitpid(-1, &amp;status, 0)等价。</li>
</ul>
</li>
<li><p>status：与 wait()函数的 status 参数意义相同。</p>
</li>
<li><p>参数 options 是一个位掩码，可以包括 0 个或多个标志（略）</p>
</li>
</ul>
<h2 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><ul>
<li>父进程先于子进程结束，也就是意味着，此时子进程变成了一个“孤儿”，我们把这种进程就称为孤儿 进程。</li>
<li>在 Linux 系统当中，所有的孤儿进程都自动成为 init 进程（进程号为 1）的子进程，换言之，某一子 进程的父进程结束后，该子进程<strong>调用 getppid()将返回 1</strong></li>
</ul>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><ul>
<li>进程结束之后，通常需要其父进程为其“收尸”，回收子进程占用的一些内存资源，父进程通过调用 wait()（或其变体 waitpid()、waitid()等）函数回收子进程资源，归还给系统。 </li>
<li>如果子进程先于父进程结束，此时父进程还未来得及给子进程“收尸”，那么此时子进程就变成了一个 僵尸进程。</li>
<li>当父进程调用 wait()（或其变体，下文不再强调）为子进程“收尸”后，僵尸进程就会被内核彻底删除。 另外一种情况，如果父进程并没有调用 wait()函数然后就退出了，那么此时 **init 进程将会接管它的子进程并 自动调用 wait()**，故而从系统中移除僵尸进程。</li>
<li>如果系统中存在大量的 僵尸进程，它们<strong>势必会填满内核进程表，从而阻碍新进程的创建</strong>。需要注意的是，僵尸进程是<strong>无法通过信号 将其杀死的</strong>，即使是“一击必杀”信号 SIGKILL 也无法将其杀死，那么这种情况下，只能<strong>杀死僵尸进程的 父进程（或等待其父进程终止）</strong>，这样 init 进程将会<strong>接管这些僵尸进程，从而将它们从系统中清理掉</strong></li>
</ul>
<h2 id="执行新程序"><a href="#执行新程序" class="headerlink" title="执行新程序"></a>执行新程序</h2><h4 id="execve"><a href="#execve" class="headerlink" title="execve()"></a><code>execve()</code></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>filename：参数 filename 指向需要载入当前进程空间的新程序的路径名，既可以是绝对路径、也可以是 相对路径。 </p>
</li>
<li><p>argv：参数 argv 则指定了传递给新程序的命令行参数。是一个字符串数组，**该数组对应于 main(int argc,  char *argv[])函数的第二个参数 argv，且格式也与之相同，是由字符串指针所组成的数组**，以 NULL 结束。 argv[0]对应的便是新程序自身路径名。 </p>
</li>
<li><p>envp：参数 envp 也是一个字符串指针数组，<strong>指定了新程序的环境变量列表</strong>，参数 envp 其实对应于新程 序的 environ 数组，同样也是以 NULL 结束，所指向的字符串格式为 <strong>name=value</strong>。</p>
</li>
<li><p>execve 调用成功将不会返回；失败将返回-1，并设置 errno。对 execve()的成功调用<strong>将永不返回</strong>，而且也无需检查它的返回值，实际上，一旦该函数返回，就表明它 发生了错误。</p>
</li>
</ul>
<h2 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h2><ul>
<li>使用 system()函数可以很方便地在我们的程序当中执行任意 shell 命令，本小节来学习下 system()函数的 用法，以及介绍 system()函数的实现方法。 首先来看看 system()函数原型，如下所示</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>system()函数其内部的是通过调用 fork()、execl()以及 waitpid()这三个函数来实现它的功能，首先 system() 会调用 fork()创建一个子进程来运行 shell（可以把这个子进程成为 shell 进程），并通过 shell 执行参数 command 所指定的命令。<ul>
<li>当参数 command 为 NULL，如果 shell 可用则返回一个非 0 值，若不可用则返回 0；针对一些非 UNIX 系统，该系统上可能是没有 shell 的，这样就会导致 shell 不可能；如果 command 参数不为 NULL，则返回值从以下的各种情况所决定。</li>
<li>如果无法创建子进程或无法获取子进程的终止状态，那么 system()返回-1；</li>
<li>如果子进程不能执行 shell，则 system()的返回值就好像是子进程通过调用_exit(127)终止了；</li>
<li>如果所有的系统调用都成功，system()函数会返回执行 command 的 shell 进程的终止状态。</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://frankzhang0219.gitee.io/2022/01/21/linux%E8%BF%9B%E7%A8%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/01/21/linux%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            linux进程（二）
          
        </div>
      </a>
    
    
      <a href="/2022/01/21/manjaro%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">manjaro停止应用程序</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2023
        <i class="ri-heart-fill heart_icon"></i> FrankZhang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.png" alt="Frank’s blogs"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>