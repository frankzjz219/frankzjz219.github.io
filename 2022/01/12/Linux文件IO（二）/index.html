<!DOCTYPE html><html lang="Chinese"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux文件IO（二）"><meta name="keywords" content=""><meta name="author" content="FrankZhang"><meta name="copyright" content="FrankZhang"><title>Linux文件IO（二） | Frank’s blogs</title><link rel="shortcut icon" href="/Flogo.png"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">Linux文件IO（二）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E6%89%93%E5%BC%80%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">多次打开同一个文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E6%89%93%E5%BC%80%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6%E4%B8%8EO-APPEND"><span class="toc-number">1.1.1.</span> <span class="toc-text">多次打开同一文件与O_APPEND</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">复制文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dup-%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">dup 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup2%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">dup2函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">共享文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8-open-%E5%87%BD%E6%95%B0%E6%89%93%E5%BC%80%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">同一个进程中多次调用 open 函数打开同一个文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8-open-%E5%87%BD%E6%95%B0%E6%89%93%E5%BC%80%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">不同进程中分别使用 open 函数打开同一个文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E9%80%9A%E8%BF%87-dup%EF%BC%88dup2%EF%BC%89%E5%87%BD%E6%95%B0%E5%AF%B9%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%BF%9B%E8%A1%8C%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">同一个进程中通过 dup（dup2）函数对文件描述符进行复制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C%E7%AB%9E%E4%BA%89%E5%86%92%E9%99%A9%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">文件操作中的原子操作和竞争冒险问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%B8%8A%E8%BF%B0%E9%97%AE%E9%A2%98%E7%94%A8%E5%88%B0%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">解决上述问题用到的原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.5.</span> <span class="toc-text">截断文件</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">FrankZhang</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">84</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Frank’s blogs</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/archives">Archives</a></span><span class="pull-right"></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Linux文件IO（二）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-12</time></div><div class="article-container" id="post-content"><h1 id="Linux文件IO（二）"><a href="#Linux文件IO（二）" class="headerlink" title="Linux文件IO（二）"></a>Linux文件IO（二）</h1><h2 id="多次打开同一个文件"><a href="#多次打开同一个文件" class="headerlink" title="多次打开同一个文件"></a>多次打开同一个文件</h2><ul>
<li>一个进程内多次 open 打开同一个文件，那么会得到多个不同的文件描述符 fd，同理在关闭文件的 时候也需要调用 close 依次关闭各个文件描述符。</li>
<li>一个进程内多次 open 打开同一个文件，在内存中<strong>并不会存在</strong>多份动态文件。</li>
<li>一个进程内多次 open 打开同一个文件，不同文件描述符所对应的读写位置偏移量是相互独立的。</li>
<li><img src="/imgs/image-20220112193343091.png" alt="image-20220112193343091"></li>
<li>实例</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> buffer[<span class="number">4</span>];</span><br><span class="line">     <span class="keyword">int</span> fd1, fd2;</span><br><span class="line">     <span class="keyword">int</span> ret;</span><br><span class="line">     <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line">     fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line">     S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == fd1) &#123;</span><br><span class="line">         perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 再次打开 test_file 文件 */</span></span><br><span class="line">     fd2 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR);</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line">         perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">         ret = <span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">goto</span> err1;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 通过 fd1 文件描述符写入 4 个字节数据 */</span></span><br><span class="line">     buffer[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line">     buffer[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line">     buffer[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line">     buffer[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line">     ret = write(fd1, buffer, <span class="number">4</span>);</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">         perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">         <span class="keyword">goto</span> err2;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line">     ret = lseek(fd2, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">         perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line">         <span class="keyword">goto</span> err2;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 读取数据 */</span></span><br><span class="line">     <span class="built_in">memset</span>(buffer, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">     ret = read(fd2, buffer, <span class="number">4</span>);</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">         perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">         <span class="keyword">goto</span> err2;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;0x%x 0x%x 0x%x 0x%x\n&quot;</span>, buffer[<span class="number">0</span>], buffer[<span class="number">1</span>],</span><br><span class="line">     buffer[<span class="number">2</span>], buffer[<span class="number">3</span>]);</span><br><span class="line">     ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line">     close(fd2);</span><br><span class="line">err1:</span><br><span class="line">     <span class="comment">/* 关闭文件 */</span></span><br><span class="line">     close(fd1);</span><br><span class="line">     <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ul>
<li><p>当前目录下<strong>不存在 test_file 文件</strong>，上述代码中，第一次调用 open 函数新建并打开 test_file 文件，第二次 调用 open 函数再次打开它，新建文件时，文件大小为 0；首先通过文件描述符 fd1 写入 4 个字节数据 （0x11/0x22/0x33/0x44），从文件头开始写；然后再通过文件描述符 fd2 读取 4 个字节数据，也是从文件头 开始读取。假如，内存中只有一份动态文件，那么读取得到的数据应该就是 0x11、0x22、0x33、0x44，如 果存在多份动态文件，那么通过 fd2 读取的是与它对应的动态文件中的数据，那就不是 0x11、0x22、0x33、 0x44，而是读取出 0 个字节数据，因为它的文件大小是 0。</p>
</li>
<li><p><img src="/imgs/image-20220112193309416.png" alt="image-20220112193309416"></p>
</li>
<li><p>上图中打印显示读取出来的数据是 0x11/0x22/0x33/0x44，所以由此可知，即使多次打开同一个文件，内 存中也只有一份动态文件。</p>
</li>
</ul>
<h3 id="多次打开同一文件与O-APPEND"><a href="#多次打开同一文件与O-APPEND" class="headerlink" title="多次打开同一文件与O_APPEND"></a>多次打开同一文件与O_APPEND</h3><ul>
<li>假如不使用<code>O_APPEND</code>的话，程序将会以不同的文件标识符为准的偏移量分别写入数据，多个文件标识符同时写一个文件的时候，不会互相更新标识符的位置，因此有可能互相覆盖。</li>
<li>使用<code>O_APPEND</code>标志的时候，会<strong>自动将偏移量移动到文件尾部</strong>，会互相更新，比如一个文件标识符写入的时候会更新另一个文件标识符的写入偏移量。此时多个文件标识符进行读写的时候就不会互相覆盖了</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line">     <span class="keyword">int</span> fd1, fd2;</span><br><span class="line">     <span class="keyword">int</span> ret;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line">	 fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL | O_APPEND,</span><br><span class="line">            S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == fd1) &#123;</span><br><span class="line">         perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">/* 再次打开 test_file 文件 */</span></span><br><span class="line">     fd2 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line">         perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">         ret = <span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">goto</span> err1;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line">     buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line">     buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line">     buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line">     buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line">     buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line">     buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line">     buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line">     buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line">     <span class="comment">/* 循环写入数据 */</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">         ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">             perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">             <span class="keyword">goto</span> err2;</span><br><span class="line">         &#125;</span><br><span class="line">         ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">             perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">             <span class="keyword">goto</span> err2;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line">     ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">         perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line">         <span class="keyword">goto</span> err2;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/* 读取数据 */</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">         ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line">         <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">             perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">             <span class="keyword">goto</span> err2;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line">         buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">     ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line">     close(fd2);</span><br><span class="line">err1:</span><br><span class="line">     <span class="comment">/* 关闭文件 */</span></span><br><span class="line">     close(fd1);</span><br><span class="line">     <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><img src="/imgs/image-20220112202602282.png" alt="image-20220112202602282"></li>
</ul>
<p>可见，每次fd1和fd2写入的内容都是交替出现的，也就是说<strong>一个标识符写入之后会自动更新另一个的偏移量</strong></p>
<h3 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h3><ul>
<li>在 Linux 系统中，open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新的文件 描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，<strong>复制得到的文件描述符和旧的文件描述符拥有相同的权限</strong>，譬如使用旧的文件描述符对文件有读写权限，那么新的文件描述符同样也具 有读写权限；在 Linux 系统下，可以使用 dup 或 dup2 这两个系统调用对文件描述符进行复制，本小节就给 大家介绍这两个函数的用法以及它们之间的区别。 <strong>复制得到的文件描述符与旧的文件描述符都指向了同一个文件表</strong>，假设 fd1 为原文件描述符，fd2 为复 制得到的文件描述符，如下图所示：</li>
<li><img src="/imgs/image-20220112202809873.png" alt="image-20220112202809873"></li>
</ul>
<h4 id="dup-函数"><a href="#dup-函数" class="headerlink" title="dup 函数"></a>dup 函数</h4><ul>
<li>dup 函数用于复制文件描述符</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>oldfd：需要被复制的文件描述符。</li>
<li>成功时将返回一个新的文件描述符，由操作系统分配，分配置原则遵循文件描述符分配原则； 如果复制失败将返回-1，并且会设置 errno 值。</li>
<li>同一个程序中使用一个描述符和复制得到的描述符进行写内容的时候，会<strong>自动连接起来而不是互相覆盖</strong>，因为两个描述符<strong>使用的是用一个偏移量</strong>。</li>
</ul>
<h4 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h4><ul>
<li>dup 系统调用分配的文件描述符是由系统分配的，遵循文件描述符分配原则，并不能自己指定一个文件 描述符，这是 dup 系统调用的一个缺陷；而 dup2 系统调用修复了这个缺陷，<strong>可以手动指定文件描述符，而 不需要遵循文件描述符分配原则</strong>，当然在实际的编程工作中，需要根据自己的情况来进行选择。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>oldfd：需要被复制的文件描述符。</p>
</li>
<li><p>newfd：指定一个文件描述符（需要指定一个当前进程没有使用到的文件描述符）。</p>
</li>
<li><p>返回值：成功时将返回一个新的文件描述符，也就是手动指定的文件描述符 newfd；如果复制失败将返 回-1，并且会设置 errno 值。</p>
</li>
</ul>
<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><ul>
<li>文件共享指的是同一个文件（譬如磁盘上的同一个文件，对应同一个 inode）被 多个独立的读写体同时进行 IO 操作。多个独立的读写体大家可以将其简单地理解为对应于同一个文件的多 个不同的文件描述符，譬如多次打开同一个文件所得到的多个不同的 fd，或使用 dup()（或 dup2）函数复制 得到的多个不同的 fd 等。</li>
<li>同时进行 IO 操作指的是一个读写体操作文件尚未调用 close 关闭的情况下，另一个读写体去操作文件</li>
<li>文件共享的意义有很多，多用于多进程或多线程编程环境中，譬如我们可以通过文件共享的方式来实现 多个线程同时操作同一个大文件，以减少文件读写时间、提升效率。</li>
<li>文件共享的核心是：如何制造出多个不同的文件描述符来指向同一个文件。譬如多次调用 open 函数重复打开同一个文件得到多个不同的文件描述符、使用 dup() 或 dup2()函数对文件描述符进行复制以得到多个不同的文件描述符。</li>
</ul>
<h4 id="同一个进程中多次调用-open-函数打开同一个文件"><a href="#同一个进程中多次调用-open-函数打开同一个文件" class="headerlink" title="同一个进程中多次调用 open 函数打开同一个文件"></a>同一个进程中多次调用 open 函数打开同一个文件</h4><ul>
<li><img src="/imgs/image-20220112205040312.png" alt="image-20220112205040312"></li>
</ul>
<h4 id="不同进程中分别使用-open-函数打开同一个文件"><a href="#不同进程中分别使用-open-函数打开同一个文件" class="headerlink" title="不同进程中分别使用 open 函数打开同一个文件"></a>不同进程中分别使用 open 函数打开同一个文件</h4><ul>
<li><img src="/imgs/image-20220112205112471.png" alt="image-20220112205112471"></li>
</ul>
<h4 id="同一个进程中通过-dup（dup2）函数对文件描述符进行复制"><a href="#同一个进程中通过-dup（dup2）函数对文件描述符进行复制" class="headerlink" title="同一个进程中通过 dup（dup2）函数对文件描述符进行复制"></a>同一个进程中通过 dup（dup2）函数对文件描述符进行复制</h4><ul>
<li><img src="/imgs/image-20220112205156025.png" alt="image-20220112205156025"></li>
</ul>
<h3 id="文件操作中的原子操作和竞争冒险问题"><a href="#文件操作中的原子操作和竞争冒险问题" class="headerlink" title="文件操作中的原子操作和竞争冒险问题"></a>文件操作中的原子操作和竞争冒险问题</h3><ul>
<li><p>假设有两个独立的进程 A 和进程 B 都对同一个文件进行追加写操作（也就是在文件末尾写入数据）， 每一个进程都调用了 open 函数打开了该文件，但未使用 O_APPEND 标志，此时，各数据结构之间的关系 如图 3.8.2 所示。每个进程都有它自己的进程控制块 PCB，有自己的文件表（意味着有自己独立的读写位置 偏移量），但是共享同一个 inode 节点（也就是对应同一个文件）。假定此时进程 A 处于运行状态，B 未处 于等待运行状态，进程 A 调用了 lseek 函数，它将进程 A 的该文件当前位置偏移量设置为 1500 字节处（假 设这里是文件末尾），刚好此时进程 A 的时间片耗尽，然后内核切换到了进程 B，进程 B 执行 lseek 函数， 也将其对该文件的当前位置偏移量设置为 1500 个字节处（文件末尾）。然后进程 B 调用 write 函数，写入 了 100 个字节数据，那么此时在进程 B 中，该文件的当前位置偏移量已经移动到了 1600 字节处。B 进程时 间片耗尽，内核又切换到了进程 A，使进程 A 恢复运行，当进程 A 调用 write 函数时，是从进程 A 的该文 件当前位置偏移量（1500 字节处）开始写入，此时文件 1500 字节处已经不再是文件末尾了，如果还从 1500 字节处写入就会覆盖进程 B 刚才写入到该文件中的数据。</p>
</li>
<li><p><img src="/imgs/image-20220112205422813.png" alt="image-20220112205422813"></p>
</li>
<li><p>以上给大家所描述的这样一种情形就属于竞争状态（也成为竞争冒险），<strong>操作共享资源的两个进程</strong>（<strong>或 线程</strong>），其操作之后的所得到的结果<strong>往往是不可预期的</strong>，因为每个进程（或线程）去操作文件的顺序是不可 预期的，<strong>即这些进程获得 CPU 使用权的先后顺序是不可预期的</strong>，完全由操作系统调配，这就是所谓的竞争 状态。</p>
</li>
</ul>
<h4 id="解决上述问题用到的原子操作"><a href="#解决上述问题用到的原子操作" class="headerlink" title="解决上述问题用到的原子操作"></a>解决上述问题用到的原子操作</h4><ul>
<li><p>所谓原子操作，是有多步操作组成的一个操作，原子操作要么一步也不执行，一旦执行，必须要执行完所有 步骤，不可能只执行所有步骤中的一个子集。</p>
</li>
<li><p>使用<code>O_APPEND</code>实现原子操作</p>
<ul>
<li>当 open 函数的 flags 参数中包含了 O_APPEND 标志，每次执行 write 写入 操作时都会<strong>将文件当前写位置偏移量移动到文件末尾，然后再写入数据</strong>，这里“<strong>移动当前写位置偏移量到文 件末尾、写入数据</strong>”这两个操作步骤就组成了一个原子操作，加入 O_APPEND 标志后，不管怎么写入数据 都会是从文件末尾写，这样就不会导致出现“进程 A 写入的数据覆盖了进程 B 写入的数据”这种情况了。</li>
</ul>
</li>
<li><p>使用<code>pread()</code>和<code>pwrite()</code>进行操作</p>
<ul>
<li>pread()和 pwrite()都是系统调用，与 read()、write()函数的作用一样，用于读取和写入数据。区别在于， pread()和 pwrite()可用于实现原子操作，<strong>调用 pread 函数或 pwrite 函数可传入一个位置偏移量 offset 参数</strong>， 用于指定文件当前读或写的位置偏移量，所以调用 <strong>pread 相当于调用 lseek 后再调用 read</strong>；同理，调用 pwrite 相当于调用 lseek 后再调用 write。所以可知，使用 pread 或 pwrite 函数不需要使用 lseek 来调整当前位置偏 移量，并会将“<strong>移动当前位置偏移量、读或写</strong>”这两步操作组成一个原子操作。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>fd、buf、count 参数与 read 或 write 函数意义相同。</p>
</li>
<li><p> offset：表示当前需要进行读或写的位置偏移量。 </p>
</li>
<li><p>返回值：返回值与 read、write 函数返回值意义一样。</p>
</li>
<li><p>虽然 pread（或 pwrite）函数相当于 lseek 与 pread（或 pwrite）函数的集合，但还是有下列区别：</p>
<ul>
<li>调用 pread 函数时，<strong>无法中断</strong>其定位和读操作（也就是原子操作）；</li>
<li><strong>不更新</strong>文件表中的当前位置偏移量。</li>
</ul>
</li>
<li><p>**<code>fcntl()</code>和<code>ioctl()</code>**详见原子的《I.MX6U嵌入式Linux C应用编程指南》</p>
</li>
</ul>
<h3 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h3><ul>
<li>使用系统调用 truncate()或 ftruncate()可将普通文件截断为指定字节长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这两个函数的区别在于：ftruncate()使用文件描述符 fd 来指定目标文件，而 truncate()则直接使用文件路 径 path 来指定目标文件，其功能一样。</p>
</li>
<li><p>这两个函数都可以对文件进行截断操作，将文件截断为参数 length 指定的字节长度，什么是截断？如 果文件目前的大小大于参数 length 所指定的大小，则多余的数据将被丢失，类似于多余的部分被“砍”掉 了；如果文件目前的<strong>大小小于参数 length 所指定的大小，则将其进行扩展，对扩展部分进行读取将得到空字 节”\0”。</strong></p>
</li>
<li><p>使用 ftruncate()函数进行文件截断操作之前，必须调用 open()函数打开该文件得到文件描述符，并且必 须要具有可写权限，也就是调用 open()打开文件时需要指定 O_WRONLY 或 O_RDWR。</p>
</li>
<li><p>调用这两个函数并不会导致文件读写位置偏移量发生改变，所以截断之后一般需要重新设置文件当前 的读写位置偏移量，以免由于之前所指向的位置已经不存在而发生错误（譬如文件长度变短了，文件当前所 指向的读写位置已不存在）。</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">FrankZhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://frankzhang0219.gitee.io/2022/01/12/Linux文件IO（二）/">http://frankzhang0219.gitee.io/2022/01/12/Linux文件IO（二）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/01/12/%E9%85%8D%E7%BD%AELinux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"><i class="fa fa-chevron-left">  </i><span>配置Linux开机启动脚本</span></a></div><div class="next-post pull-right"><a href="/2022/01/12/Linux%E6%96%87%E4%BB%B6IO%E4%BD%BF%E7%94%A8/"><span>Linux文件IO使用</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2021 - 2022 By FrankZhang</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>